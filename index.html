<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DDAM Meeting Background Generator</title>
    
    <!-- Google Fonts API Links -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&family=Roboto:wght@400;500;700&family=Open+Sans:wght@400;600&family=Lato:wght@400;700&family=Montserrat:wght@400;600&family=Aoboshi+One&family=Kaisei+Decol:wght@400;500;700&display=swap" rel="stylesheet">
    
    <!-- HTML2Canvas CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <style>
        /* CSS Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Roboto', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Mobile-First Responsive Layout */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
        }
        
        .header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 1rem 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
        }
        
        .header h1 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }
        
        .header p {
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        /* Main Layout Grid */
        .main-layout {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }
        
        /* Control Panel */
        .control-panel {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .control-section {
            margin-bottom: 1.5rem;
        }
        
        .control-section:last-child {
            margin-bottom: 0;
        }
        
        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #2c3e50;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 0.5rem;
        }
        
        /* Preview Panel */
        .preview-panel {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .preview-container {
            width: 100%;
            max-width: 100%;
            aspect-ratio: 16/9;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        
        #preview-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        /* Form Controls */
        .form-group {
            margin-bottom: 1rem;
        }
        
        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #495057;
        }
        
        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 1rem;
            transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }
        
        .form-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
        }
        
        .form-select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 1rem;
            background-color: white;
            cursor: pointer;
        }
        
        .form-help {
            display: block;
            margin-top: 0.25rem;
            font-size: 0.875rem;
            color: #6c757d;
            line-height: 1.4;
        }
        
        .text-form {
            width: 100%;
        }
        
        .form-input:invalid {
            border-color: #dc3545;
        }
        
        .form-input:invalid:focus {
            border-color: #dc3545;
            box-shadow: 0 0 0 0.2rem rgba(220, 53, 69, 0.25);
        }
        
        .form-input.error {
            border-color: #dc3545;
        }
        
        .form-input.error:focus {
            border-color: #dc3545;
            box-shadow: 0 0 0 0.2rem rgba(220, 53, 69, 0.25);
        }
        
        .form-error {
            display: none;
            margin-top: 0.25rem;
            font-size: 0.875rem;
            color: #dc3545;
            line-height: 1.4;
        }
        
        /* Button Styles */
        .btn {
            display: inline-block;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 500;
            text-align: center;
            text-decoration: none;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease-in-out;
        }
        
        .btn-primary {
            background-color: #667eea;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #5a6fd8;
        }
        
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #5a6268;
        }
        
        /* Utility Classes */
        .text-center {
            text-align: center;
        }
        
        .mb-1 { margin-bottom: 0.5rem; }
        .mb-2 { margin-bottom: 1rem; }
        .mb-3 { margin-bottom: 1.5rem; }
        
        .mt-1 { margin-top: 0.5rem; }
        .mt-2 { margin-top: 1rem; }
        .mt-3 { margin-top: 1.5rem; }
        
        /* Tablet Styles */
        @media (min-width: 768px) {
            .container {
                padding: 2rem;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .header p {
                font-size: 1rem;
            }
            
            .main-layout {
                grid-template-columns: 1fr 1fr;
                gap: 2rem;
            }
            
            .control-panel,
            .preview-panel {
                padding: 2rem;
            }
        }
        
        /* Desktop Styles */
        @media (min-width: 1024px) {
            .main-layout {
                grid-template-columns: 400px 1fr;
            }
            
            .header h1 {
                font-size: 2.5rem;
            }
            
            /* Sticky Preview Panel */
            .preview-panel {
                position: sticky;
                top: 1rem;
                height: fit-content;
                max-height: calc(100vh - 2rem);
                overflow-y: auto;
            }
        }
        
        /* Loading and Error States */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 200px;
            color: #6c757d;
        }
        
        .error {
            background-color: #f8d7da;
            color: #721c24;
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
        }
        
        .success {
            background-color: #d4edda;
            color: #155724;
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
        }
        
        /* Layout Selection Styles */
        .layout-selection {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
        }
        
        .layout-card {
            border: 2px solid #e9ecef;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .layout-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
            transform: translateY(-2px);
        }
        
        .layout-card.active {
            border-color: #667eea;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.25);
            background: linear-gradient(135deg, #f8f9ff 0%, #ffffff 100%);
        }
        
        .layout-preview {
            height: 120px;
            position: relative;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }
        
        .layout-preview-content {
            position: relative;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
        }
        
        .layout1-preview {
            position: relative;
        }
        
        .layout1-preview .preview-frame {
            position: absolute;
            top: 8px;
            left: 8px;
            right: 8px;
            bottom: 8px;
            border: 2px solid rgba(0, 0, 0, 0.8);
            border-radius: 8px;
        }
        
        .layout1-preview .preview-overlay {
            position: absolute;
            top: 8px;
            right: 8px;
            bottom: 8px;
            width: 40%;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 0 6px 6px 0;
        }
        
        .layout2-preview {
            position: relative;
        }
        
        .preview-logo {
            position: absolute;
            top: 8px;
            left: 12px;
            font-size: 10px;
            font-weight: bold;
            color: white;
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            backdrop-filter: blur(4px);
        }
        
        .preview-text {
            position: absolute;
            font-size: 8px;
            color: white;
            line-height: 1.2;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .preview-text-layout1 {
            top: 12px;
            right: 12px;
            text-align: right;
        }
        
        .preview-text-layout2 {
            top: 50%;
            right: 12px;
            transform: translateY(-50%);
            text-align: right;
        }
        
        .preview-copyright {
            position: absolute;
            bottom: 8px;
            left: 12px;
            font-size: 6px;
            color: white;
            opacity: 0.8;
        }
        
        .layout-info {
            padding: 1rem;
        }
        
        .layout-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }
        
        .layout-description {
            font-size: 0.9rem;
            color: #6c757d;
            margin-bottom: 0.75rem;
            line-height: 1.4;
        }
        
        .layout-features {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
        }
        
        .feature-tag {
            font-size: 0.75rem;
            background: #e9ecef;
            color: #495057;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-weight: 500;
        }
        
        .layout-card.active .feature-tag {
            background: #667eea;
            color: white;
        }
        
        .layout-selector {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: all 0.3s ease;
            backdrop-filter: blur(4px);
        }
        
        .layout-card.active .layout-selector {
            opacity: 1;
            background: #667eea;
        }
        
        .selector-icon {
            font-size: 12px;
            font-weight: bold;
            color: #667eea;
        }
        
        .layout-card.active .selector-icon {
            color: white;
        }
        
        /* Tablet Layout Selection Styles */
        @media (min-width: 768px) {
            .layout-selection {
                grid-template-columns: 1fr 1fr;
                gap: 1.5rem;
            }
            
            .layout-preview {
                height: 140px;
            }
            
            .preview-text {
                font-size: 9px;
            }
            
            .preview-logo {
                font-size: 11px;
            }
            
            .preview-copyright {
                font-size: 7px;
            }
        }
        
        /* Desktop Layout Selection Styles */
        @media (min-width: 1024px) {
            .layout-selection {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .layout-preview {
                height: 100px;
            }
            
            .preview-text {
                font-size: 8px;
            }
            
            .layout-title {
                font-size: 1rem;
            }
            
            .layout-description {
                font-size: 0.85rem;
            }
        }
        
        /* Selection Feedback Animation */
        .layout-card.selection-feedback {
            transform: scale(1.02);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
        }
        
        /* Text Position Classes for Preview */
        .preview-text.position-top-right {
            top: 12px;
            right: 12px;
            text-align: right;
        }
        
        .preview-text.position-middle {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        
        .preview-text.position-bottom-left {
            bottom: 20px;
            left: 12px;
            text-align: left;
        }
        
        .preview-text.position-bottom-right {
            bottom: 20px;
            right: 12px;
            text-align: right;
        }
        
        /* Layout Selection Error Styles */
        .layout-selection-error {
            margin-bottom: 1rem;
            display: none;
        }
        
        /* Accessibility Improvements */
        .layout-card:focus {
            outline: 2px solid #667eea;
            outline-offset: 2px;
        }
        
        .layout-card[aria-selected="true"] {
            border-color: #667eea;
        }
        
        /* High Contrast Mode Support */
        @media (prefers-contrast: high) {
            .layout-card {
                border-width: 3px;
            }
            
            .layout-card.active {
                border-color: #000;
            }
            
            .feature-tag {
                border: 1px solid #495057;
            }
        }
        
        /* Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            .layout-card {
                transition: none;
            }
            
            .layout-card.selection-feedback {
                transform: none;
            }
            
            .layout-selector {
                transition: none;
            }
        }
        
        /* Font Family Definitions for System Fonts */
        .font-hiragino-sans {
            font-family: "Hiragino Sans", "ヒラギノ角ゴシック", "Hiragino Kaku Gothic ProN", "ヒラギノ角ゴ ProN W3", "メイリオ", Meiryo, sans-serif;
        }
        
        .font-yu-gothic {
            font-family: "Yu Gothic", "游ゴシック", "YuGothic", "游ゴシック体", "ヒラギノ角ゴ Pro W3", "メイリオ", Meiryo, sans-serif;
        }
        
        .font-meiryo {
            font-family: Meiryo, "メイリオ", "Hiragino Kaku Gothic ProN", "ヒラギノ角ゴ ProN W3", sans-serif;
        }
        
        /* Typography Control Styles */
        .font-preview {
            margin-top: 0.5rem;
            padding: 0.75rem;
            background-color: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #e9ecef;
        }
        
        .font-preview-text {
            font-size: 16px;
            line-height: 1.4;
            color: #495057;
        }
        
        .font-loading {
            display: inline-block;
            margin-left: 0.5rem;
            font-size: 0.875rem;
            color: #6c757d;
        }
        
        .font-error {
            margin-bottom: 1rem;
            display: none;
        }
        
        /* Range Slider Styles */
        .form-range {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }
        
        .form-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.15s ease-in-out;
        }
        
        .form-range::-webkit-slider-thumb:hover {
            background: #5a6fd8;
            transform: scale(1.1);
        }
        
        .form-range::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            transition: all 0.15s ease-in-out;
        }
        
        .form-range::-moz-range-thumb:hover {
            background: #5a6fd8;
            transform: scale(1.1);
        }
        
        .form-range:focus::-webkit-slider-thumb {
            box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
        }
        
        .form-range:focus::-moz-range-thumb {
            box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
        }
        
        /* Color Toggle Button Styles */
        .color-toggle-group {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .color-toggle-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            background: white;
            color: #495057;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease-in-out;
            flex: 1;
            justify-content: center;
        }
        
        .color-toggle-btn:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }
        
        .color-toggle-btn.active {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }
        
        .color-toggle-btn:focus {
            outline: none;
            box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
        }
        
        .color-preview {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #dee2e6;
            display: inline-block;
        }
        
        .color-preview-white {
            background: white;
        }
        
        .color-preview-black {
            background: #212529;
        }
        
        .color-toggle-btn.active .color-preview {
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        /* Mobile Responsive Adjustments for Typography Controls */
        @media (max-width: 767px) {
            .color-toggle-group {
                flex-direction: column;
            }
            
            .color-toggle-btn {
                justify-content: flex-start;
            }
        }
        
        /* Asset Management Styles */
        .asset-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 0.75rem;
            margin-top: 1rem;
        }
        
        .asset-item {
            position: relative;
            aspect-ratio: 1;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.15s ease-in-out;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .asset-item:hover {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.15);
            transform: translateY(-1px);
        }
        
        .asset-item.active {
            border-color: #667eea;
            box-shadow: 0 2px 12px rgba(102, 126, 234, 0.25);
            background: linear-gradient(135deg, #f8f9ff 0%, #ffffff 100%);
        }
        
        .asset-item:focus {
            outline: none;
            box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
        }
        
        .asset-thumbnail {
            width: 100%;
            height: 100%;
            object-fit: contain;
            padding: 4px;
        }
        
        .asset-selector {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 18px;
            height: 18px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: all 0.15s ease-in-out;
            backdrop-filter: blur(4px);
        }
        
        .asset-item.active .asset-selector {
            opacity: 1;
            background: #667eea;
        }
        
        .asset-selector-icon {
            font-size: 10px;
            font-weight: bold;
            color: #667eea;
        }
        
        .asset-item.active .asset-selector-icon {
            color: white;
        }
        
        .asset-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 120px;
            color: #6c757d;
            font-size: 0.9rem;
        }
        
        .asset-error {
            background-color: #f8d7da;
            color: #721c24;
            padding: 1rem;
            border-radius: 4px;
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        
        .asset-empty {
            text-align: center;
            padding: 2rem 1rem;
            color: #6c757d;
            font-size: 0.9rem;
            border: 2px dashed #e9ecef;
            border-radius: 8px;
            margin-top: 1rem;
        }
        
        /* Logo Gallery Specific Styles */
        .logo-gallery {
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        }
        
        .logo-item {
            background: #f8f9fa;
        }
        
        .logo-thumbnail {
            padding: 8px;
        }
        
        /* Background Gallery Specific Styles */
        .background-gallery {
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        }
        
        .background-item {
            aspect-ratio: 16/9;
        }
        
        .background-thumbnail {
            padding: 2px;
        }
        
        /* Custom Upload Styles */
        .upload-area {
            border: 2px dashed #e9ecef;
            border-radius: 8px;
            padding: 2rem 1rem;
            text-align: center;
            margin-top: 1rem;
            transition: all 0.15s ease-in-out;
            cursor: pointer;
            background: #f8f9fa;
        }
        
        .upload-area:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }
        
        .upload-area.dragover {
            border-color: #667eea;
            background: #f0f4ff;
            transform: scale(1.02);
        }
        
        .upload-icon {
            font-size: 2rem;
            color: #6c757d;
            margin-bottom: 0.5rem;
        }
        
        .upload-text {
            color: #495057;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }
        
        .upload-hint {
            color: #6c757d;
            font-size: 0.8rem;
        }
        
        .upload-input {
            display: none;
        }
        
        /* Asset Section Tabs */
        .asset-tabs {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 1rem;
        }
        
        .asset-tab {
            flex: 1;
            padding: 0.75rem 1rem;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            color: #6c757d;
            transition: all 0.15s ease-in-out;
        }
        
        .asset-tab:hover {
            color: #495057;
            background: #f8f9fa;
        }
        
        .asset-tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: #f8f9ff;
        }
        
        .asset-tab:focus {
            outline: none;
            box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
        }
        
        /* Tablet Asset Gallery Styles */
        @media (min-width: 768px) {
            .asset-gallery {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 1rem;
            }
            
            .logo-gallery {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }
            
            .background-gallery {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            }
        }
        
        /* Desktop Asset Gallery Styles */
        @media (min-width: 1024px) {
            .asset-gallery {
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            }
            
            .logo-gallery {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            }
            
            .background-gallery {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }
        }
        
        /* High Contrast Mode Support for Assets */
        @media (prefers-contrast: high) {
            .asset-item {
                border-width: 3px;
            }
            
            .asset-item.active {
                border-color: #000;
            }
        }
        
        /* Reduced Motion Support for Assets */
        @media (prefers-reduced-motion: reduce) {
            .asset-item {
                transition: none;
            }
            
            .upload-area.dragover {
                transform: none;
            }
        }
        
        /* Export Control Styles */
        .range-value {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: #495057;
        }
        
        #export-quality-value {
            font-weight: 600;
            color: #667eea;
        }
        
        #export-btn {
            position: relative;
            overflow: hidden;
        }
        
        #export-btn:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        #export-btn:disabled:hover {
            background-color: #6c757d;
        }
        
        .export-progress-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            transition: width 0.3s ease;
            width: 0%;
        }
        
        #export-info {
            transition: color 0.3s ease;
        }
        
        #export-info.success {
            color: #28a745 !important;
        }
        
        #export-info.error {
            color: #dc3545 !important;
        }
        
        /* Text Position Control Styles */
        .position-control-group {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.75rem;
            margin-top: 1rem;
        }
        
        .position-option {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.15s ease-in-out;
            position: relative;
        }
        
        .position-option:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }
        
        .position-option.active {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }
        
        .position-option:focus-within {
            outline: none;
            box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
        }
        
        .position-radio {
            width: 18px;
            height: 18px;
            border: 2px solid #ced4da;
            border-radius: 50%;
            background: white;
            position: relative;
            flex-shrink: 0;
            transition: all 0.15s ease-in-out;
        }
        
        .position-option.active .position-radio {
            border-color: white;
            background: white;
        }
        
        .position-radio::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 8px;
            height: 8px;
            background: #667eea;
            border-radius: 50%;
            transition: transform 0.15s ease-in-out;
        }
        
        .position-option.active .position-radio::after {
            transform: translate(-50%, -50%) scale(1);
            background: #667eea;
        }
        
        .position-info {
            flex: 1;
        }
        
        .position-title {
            font-weight: 600;
            font-size: 0.95rem;
            margin-bottom: 0.25rem;
            color: #2c3e50;
        }
        
        .position-option.active .position-title {
            color: white;
        }
        
        .position-description {
            font-size: 0.85rem;
            color: #6c757d;
            line-height: 1.3;
        }
        
        .position-option.active .position-description {
            color: rgba(255, 255, 255, 0.9);
        }
        
        .position-preview {
            width: 60px;
            height: 34px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
            border: 1px solid #dee2e6;
        }
        
        .position-option.active .position-preview {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9ff 100%);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .position-preview-dot {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #667eea;
            border-radius: 50%;
            transition: all 0.15s ease-in-out;
        }
        
        .position-option.active .position-preview-dot {
            background: #667eea;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.5);
        }
        
        /* Position-specific dot placements */
        .position-preview-dot.top-right {
            top: 6px;
            right: 6px;
        }
        
        .position-preview-dot.middle {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .position-preview-dot.middle-right {
            top: 50%;
            right: 6px;
            transform: translateY(-50%);
        }
        
        .position-preview-dot.bottom-left {
            bottom: 6px;
            left: 6px;
        }
        
        .position-preview-dot.bottom-right {
            bottom: 6px;
            right: 6px;
        }
        
        /* Layout-specific position control visibility */
        .position-control-section {
            display: none;
        }
        
        .position-control-section.active {
            display: block;
        }
        
        /* Hidden radio inputs for accessibility */
        .position-input {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }
        
        /* Tablet Position Control Styles */
        @media (min-width: 768px) {
            .position-control-group {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }
            
            .position-option {
                padding: 0.875rem;
            }
            
            .position-preview {
                width: 70px;
                height: 40px;
            }
        }
        
        /* Desktop Position Control Styles */
        @media (min-width: 1024px) {
            .position-control-group {
                gap: 0.5rem;
            }
            
            .position-option {
                padding: 0.75rem;
            }
            
            .position-title {
                font-size: 0.9rem;
            }
            
            .position-description {
                font-size: 0.8rem;
            }
            
            .position-preview {
                width: 60px;
                height: 34px;
            }
        }
        
        /* High Contrast Mode Support for Position Controls */
        @media (prefers-contrast: high) {
            .position-option {
                border-width: 3px;
            }
            
            .position-option.active {
                border-color: #000;
            }
            
            .position-radio {
                border-width: 3px;
            }
        }
        
        /* Reduced Motion Support for Position Controls */
        @media (prefers-reduced-motion: reduce) {
            .position-option {
                transition: none;
            }
            
            .position-radio::after {
                transition: none;
            }
            
            .position-preview-dot {
                transition: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <h1>DDAM Meeting Background Generator</h1>
            <p>Create personalized virtual meeting backgrounds for Dentsu Data Artist Mongol</p>
        </header>
        
        <!-- Main Layout -->
        <main class="main-layout">
            <!-- Control Panel -->
            <aside class="control-panel">
                <div class="control-section">
                    <h2 class="section-title">Layout Selection</h2>
                    <div class="layout-selection">
                        <div class="layout-card" data-layout="layout1" id="layout1-card">
                            <div class="layout-preview">
                                <div class="layout-preview-content layout1-preview">
                                    <div class="preview-logo">LOGO</div>
                                    <div class="preview-frame"></div>
                                    <div class="preview-overlay"></div>
                                    <div class="preview-text preview-text-layout1">
                                        <div>John Smith</div>
                                        <div>ジョン</div>
                                        <div>Senior Data Analyst</div>
                                        <div>シニアデータアナリスト</div>
                                    </div>
                                    <div class="preview-copyright">©2025 DDAM LLC</div>
                                </div>
                            </div>
                            <div class="layout-info">
                                <h3 class="layout-title">Layout 1</h3>
                                <p class="layout-description">Rounded frame with overlay and flexible text positioning</p>
                                <div class="layout-features">
                                    <span class="feature-tag">Rounded Frame</span>
                                    <span class="feature-tag">Right Overlay</span>
                                    <span class="feature-tag">3 Text Positions</span>
                                </div>
                            </div>
                            <div class="layout-selector">
                                <div class="selector-icon">✓</div>
                            </div>
                        </div>
                        
                        <div class="layout-card" data-layout="layout2" id="layout2-card">
                            <div class="layout-preview">
                                <div class="layout-preview-content layout2-preview">
                                    <div class="preview-logo">LOGO</div>
                                    <div class="preview-text preview-text-layout2">
                                        <div>John Smith</div>
                                        <div>ジョン</div>
                                        <div>Senior Data Analyst</div>
                                        <div>シニアデータアナリスト</div>
                                    </div>
                                    <div class="preview-copyright">©2025 DDAM LLC</div>
                                </div>
                            </div>
                            <div class="layout-info">
                                <h3 class="layout-title">Layout 2</h3>
                                <p class="layout-description">Clean design with flexible text positioning options</p>
                                <div class="layout-features">
                                    <span class="feature-tag">Clean Design</span>
                                    <span class="feature-tag">No Overlay</span>
                                    <span class="feature-tag">3 Text Positions</span>
                                </div>
                            </div>
                            <div class="layout-selector">
                                <div class="selector-icon">✓</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="control-section">
                    <h2 class="section-title">Text Information</h2>
                    <form id="text-form" class="text-form">
                        <div class="form-group">
                            <label for="fullName" class="form-label">Full Name</label>
                            <input 
                                type="text" 
                                id="fullName" 
                                name="fullName" 
                                class="form-input" 
                                value="John Smith"
                                placeholder="Enter your full name"
                                maxlength="100"
                                aria-describedby="fullName-help"
                                required
                            >
                            <small id="fullName-help" class="form-help">Your full name as it should appear on the background</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="nickname" class="form-label">Nickname (ニックネーム)</label>
                            <input 
                                type="text" 
                                id="nickname" 
                                name="nickname" 
                                class="form-input" 
                                value="ジョン"
                                placeholder="Enter your nickname in Japanese"
                                maxlength="50"
                                aria-describedby="nickname-help"
                                required
                            >
                            <small id="nickname-help" class="form-help">Your nickname in Japanese characters</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="positionEn" class="form-label">Position (English)</label>
                            <input 
                                type="text" 
                                id="positionEn" 
                                name="positionEn" 
                                class="form-input" 
                                value="Senior Data Analyst"
                                placeholder="Enter your position in English"
                                maxlength="100"
                                aria-describedby="positionEn-help"
                                required
                            >
                            <small id="positionEn-help" class="form-help">Your job title in English</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="positionJp" class="form-label">Position (Japanese) - DDAMのポジション</label>
                            <input 
                                type="text" 
                                id="positionJp" 
                                name="positionJp" 
                                class="form-input" 
                                value="シニアデータアナリスト"
                                placeholder="Enter your position in Japanese"
                                maxlength="100"
                                aria-describedby="positionJp-help"
                                required
                            >
                            <small id="positionJp-help" class="form-help">Your job title in Japanese characters</small>
                        </div>
                    </form>
                </div>
                
                <div class="control-section">
                    <h2 class="section-title">Typography</h2>
                    
                    <div class="form-group">
                        <label for="japaneseFont" class="form-label">Japanese Font</label>
                        <select 
                            id="japaneseFont" 
                            name="japaneseFont" 
                            class="form-select"
                            aria-describedby="japaneseFont-help"
                        >
                            <option value="Noto Sans JP" selected>Noto Sans JP</option>
                            <option value="Hiragino Sans">Hiragino Sans</option>
                            <option value="Yu Gothic">Yu Gothic</option>
                            <option value="Meiryo">Meiryo</option>
                            <option value="Aoboshi One">Aoboshi One</option>
                            <option value="Kaisei Decol">Kaisei Decol</option>
                        </select>
                        <small id="japaneseFont-help" class="form-help">Font family for Japanese text (nickname and position)</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="englishFont" class="form-label">English Font</label>
                        <select 
                            id="englishFont" 
                            name="englishFont" 
                            class="form-select"
                            aria-describedby="englishFont-help"
                        >
                            <option value="Roboto" selected>Roboto</option>
                            <option value="Open Sans">Open Sans</option>
                            <option value="Lato">Lato</option>
                            <option value="Montserrat">Montserrat</option>
                            <option value="Arial">Arial</option>
                            <option value="Times New Roman">Times New Roman</option>
                        </select>
                        <small id="englishFont-help" class="form-help">Font family for English text (full name and position)</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="fontSize" class="form-label">Font Size: <span id="fontSize-value">18px</span></label>
                        <input 
                            type="range" 
                            id="fontSize" 
                            name="fontSize" 
                            class="form-range" 
                            min="12" 
                            max="24" 
                            value="18" 
                            step="1"
                            aria-describedby="fontSize-help"
                        >
                        <small id="fontSize-help" class="form-help">Adjust the size of all text elements (12px - 24px)</small>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Text Color</label>
                        <div class="color-toggle-group" role="radiogroup" aria-labelledby="textColor-label">
                            <button 
                                type="button" 
                                id="textColor-white" 
                                class="color-toggle-btn active" 
                                data-color="white"
                                role="radio"
                                aria-checked="true"
                                aria-describedby="textColor-help"
                            >
                                <span class="color-preview color-preview-white"></span>
                                White
                            </button>
                            <button 
                                type="button" 
                                id="textColor-black" 
                                class="color-toggle-btn" 
                                data-color="black"
                                role="radio"
                                aria-checked="false"
                                aria-describedby="textColor-help"
                            >
                                <span class="color-preview color-preview-black"></span>
                                Black
                            </button>
                        </div>
                        <small id="textColor-help" class="form-help">Choose text color for optimal contrast with your background</small>
                    </div>
                </div>
                
                <div class="control-section">
                    <h2 class="section-title">Text Position</h2>
                    
                    <!-- Layout 1 Position Controls -->
                    <div class="position-control-section active" id="layout1-positions">
                        <div class="form-group">
                            <label class="form-label">Position for Layout 1</label>
                            <div class="position-control-group" role="radiogroup" aria-labelledby="layout1-position-label">
                                <label class="position-option active" for="layout1-top-right">
                                    <input 
                                        type="radio" 
                                        id="layout1-top-right" 
                                        name="layout1-position" 
                                        value="top-right" 
                                        class="position-input"
                                        checked
                                        aria-describedby="layout1-position-help"
                                    >
                                    <div class="position-radio"></div>
                                    <div class="position-info">
                                        <div class="position-title">Top Right</div>
                                        <div class="position-description">Text appears in the top-right corner over the overlay</div>
                                    </div>
                                    <div class="position-preview">
                                        <div class="position-preview-dot top-right"></div>
                                    </div>
                                </label>
                                
                                <label class="position-option" for="layout1-middle-right">
                                    <input 
                                        type="radio" 
                                        id="layout1-middle-right" 
                                        name="layout1-position" 
                                        value="middle-right" 
                                        class="position-input"
                                        aria-describedby="layout1-position-help"
                                    >
                                    <div class="position-radio"></div>
                                    <div class="position-info">
                                        <div class="position-title">Middle Right</div>
                                        <div class="position-description">Text appears centered vertically on the right side over the overlay</div>
                                    </div>
                                    <div class="position-preview">
                                        <div class="position-preview-dot middle-right"></div>
                                    </div>
                                </label>
                                
                                <label class="position-option" for="layout1-bottom-right">
                                    <input 
                                        type="radio" 
                                        id="layout1-bottom-right" 
                                        name="layout1-position" 
                                        value="bottom-right" 
                                        class="position-input"
                                        aria-describedby="layout1-position-help"
                                    >
                                    <div class="position-radio"></div>
                                    <div class="position-info">
                                        <div class="position-title">Bottom Right</div>
                                        <div class="position-description">Text appears in the bottom-right corner over the overlay</div>
                                    </div>
                                    <div class="position-preview">
                                        <div class="position-preview-dot bottom-right"></div>
                                    </div>
                                </label>
                            </div>
                            <small id="layout1-position-help" class="form-help">Choose where your text information should appear in Layout 1</small>
                        </div>
                    </div>
                    
                    <!-- Layout 2 Position Controls -->
                    <div class="position-control-section" id="layout2-positions">
                        <div class="form-group">
                            <label class="form-label">Position for Layout 2</label>
                            <div class="position-control-group" role="radiogroup" aria-labelledby="layout2-position-label">
                                <label class="position-option active" for="layout2-top-right">
                                    <input 
                                        type="radio" 
                                        id="layout2-top-right" 
                                        name="layout2-position" 
                                        value="top-right" 
                                        class="position-input"
                                        checked
                                        aria-describedby="layout2-position-help"
                                    >
                                    <div class="position-radio"></div>
                                    <div class="position-info">
                                        <div class="position-title">Top Right</div>
                                        <div class="position-description">Text appears in the top-right corner of the background</div>
                                    </div>
                                    <div class="position-preview">
                                        <div class="position-preview-dot top-right"></div>
                                    </div>
                                </label>
                                
                                <label class="position-option" for="layout2-middle-right">
                                    <input 
                                        type="radio" 
                                        id="layout2-middle-right" 
                                        name="layout2-position" 
                                        value="middle-right" 
                                        class="position-input"
                                        aria-describedby="layout2-position-help"
                                    >
                                    <div class="position-radio"></div>
                                    <div class="position-info">
                                        <div class="position-title">Middle Right</div>
                                        <div class="position-description">Text appears centered vertically on the right side</div>
                                    </div>
                                    <div class="position-preview">
                                        <div class="position-preview-dot middle-right"></div>
                                    </div>
                                </label>
                                
                                <label class="position-option" for="layout2-bottom-right">
                                    <input 
                                        type="radio" 
                                        id="layout2-bottom-right" 
                                        name="layout2-position" 
                                        value="bottom-right" 
                                        class="position-input"
                                        aria-describedby="layout2-position-help"
                                    >
                                    <div class="position-radio"></div>
                                    <div class="position-info">
                                        <div class="position-title">Bottom Right</div>
                                        <div class="position-description">Text appears in the bottom-right corner above copyright</div>
                                    </div>
                                    <div class="position-preview">
                                        <div class="position-preview-dot bottom-right"></div>
                                    </div>
                                </label>
                                
                                <label class="position-option" for="layout2-bottom-left">
                                    <input 
                                        type="radio" 
                                        id="layout2-bottom-left" 
                                        name="layout2-position" 
                                        value="bottom-left" 
                                        class="position-input"
                                        aria-describedby="layout2-position-help"
                                    >
                                    <div class="position-radio"></div>
                                    <div class="position-info">
                                        <div class="position-title">Bottom Left</div>
                                        <div class="position-description">Text appears in the bottom-left corner above copyright</div>
                                    </div>
                                    <div class="position-preview">
                                        <div class="position-preview-dot bottom-left"></div>
                                    </div>
                                </label>
                            </div>
                            <small id="layout2-position-help" class="form-help">Choose where your text information should appear in Layout 2</small>
                        </div>
                    </div>
                </div>
                
                <div class="control-section">
                    <h2 class="section-title">Layout 1 Overlay</h2>
                    
                    <div class="form-group">
                        <label for="overlay-opacity" class="form-label">Overlay Transparency</label>
                        <input 
                            type="range" 
                            id="overlay-opacity" 
                            class="form-range" 
                            min="0" 
                            max="100" 
                            value="80" 
                            step="5"
                            aria-describedby="overlay-opacity-help"
                        >
                        <div class="range-value">
                            <span>Transparent</span>
                            <span id="overlay-opacity-value">80%</span>
                            <span>Opaque</span>
                        </div>
                        <small id="overlay-opacity-help" class="form-help">Adjust the transparency of the right overlay (Layout 1 only)</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="overlay-size" class="form-label">Overlay Size</label>
                        <input 
                            type="range" 
                            id="overlay-size" 
                            class="form-range" 
                            min="20" 
                            max="80" 
                            value="40" 
                            step="5"
                            aria-describedby="overlay-size-help"
                        >
                        <div class="range-value">
                            <span>Small</span>
                            <span id="overlay-size-value">40%</span>
                            <span>Large</span>
                        </div>
                        <small id="overlay-size-help" class="form-help">Control how much of the right side is covered by the overlay</small>
                    </div>
                </div>
                
                <div class="control-section">
                    <h2 class="section-title">Assets</h2>
                    
                    <!-- Asset Tabs -->
                    <div class="asset-tabs">
                        <button type="button" class="asset-tab active" data-tab="logos" id="logos-tab">
                            Logos
                        </button>
                        <button type="button" class="asset-tab" data-tab="backgrounds" id="backgrounds-tab">
                            Backgrounds
                        </button>
                        <button type="button" class="asset-tab" data-tab="upload" id="upload-tab">
                            Upload
                        </button>
                    </div>
                    
                    <!-- Logo Selection Panel -->
                    <div class="asset-panel" id="logos-panel">
                        <div class="asset-loading" id="logos-loading">
                            Loading logos...
                        </div>
                        <div class="asset-gallery logo-gallery" id="logos-gallery" style="display: none;">
                            <!-- Logo items will be populated by JavaScript -->
                        </div>
                        <div class="asset-error" id="logos-error" style="display: none;">
                            Failed to load logos. Please refresh the page.
                        </div>
                    </div>
                    
                    <!-- Background Selection Panel -->
                    <div class="asset-panel" id="backgrounds-panel" style="display: none;">
                        <div class="asset-loading" id="backgrounds-loading">
                            Loading backgrounds...
                        </div>
                        <div class="asset-gallery background-gallery" id="backgrounds-gallery" style="display: none;">
                            <!-- Background items will be populated by JavaScript -->
                        </div>
                        <div class="asset-error" id="backgrounds-error" style="display: none;">
                            Failed to load backgrounds. Please refresh the page.
                        </div>
                    </div>
                    
                    <!-- Custom Upload Panel -->
                    <div class="asset-panel" id="upload-panel" style="display: none;">
                        <div class="upload-area" id="upload-area">
                            <div class="upload-icon">📁</div>
                            <div class="upload-text">Click to upload or drag and drop</div>
                            <div class="upload-hint">Supports JPEG, PNG, WebP (max 10MB)</div>
                            <input type="file" id="upload-input" class="upload-input" accept="image/jpeg,image/png,image/webp">
                        </div>
                        <div class="asset-error" id="upload-error" style="display: none;">
                            <!-- Upload error messages will appear here -->
                        </div>
                    </div>
                </div>
                
                <div class="control-section">
                    <h2 class="section-title">Logo Settings</h2>
                    
                    <div class="form-group">
                        <label for="logoScale" class="form-label">Logo Size: <span id="logoScale-value">100%</span></label>
                        <input 
                            type="range" 
                            id="logoScale" 
                            name="logoScale" 
                            class="form-range" 
                            min="0.5" 
                            max="2.0" 
                            value="1.0" 
                            step="0.1"
                            aria-describedby="logoScale-help"
                        >
                        <small id="logoScale-help" class="form-help">Adjust the size of the logo (50% - 200%)</small>
                    </div>
                </div>
                
                <div class="control-section">
                    <h2 class="section-title">Export</h2>
                    
                    <div class="form-group">
                        <label class="form-label" for="export-filename">Filename Preview</label>
                        <input type="text" id="export-filename" class="form-input" readonly>
                        <small class="form-help">Filename is automatically generated from your full name</small>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="export-quality">Export Quality</label>
                        <input type="range" id="export-quality" class="form-range" min="0.5" max="1.0" step="0.1" value="1.0">
                        <div class="range-value">
                            <span>Quality: </span>
                            <span id="export-quality-value">100%</span>
                        </div>
                        <small class="form-help">Higher quality results in larger file sizes</small>
                    </div>
                    
                    <button type="button" id="export-btn" class="btn btn-primary" style="width: 100%; margin-top: 1rem;">
                        <span id="export-btn-text">Export Background (1920×1080)</span>
                    </button>
                    
                    <div id="export-info" class="mt-2" style="font-size: 0.85rem; color: #6c757d; text-align: center;">
                        High-quality PNG format • Ready for video conferencing
                    </div>
                </div>
            </aside>
            
            <!-- Preview Panel -->
            <section class="preview-panel">
                <h2 class="section-title">Preview</h2>
                <div class="preview-container">
                    <canvas id="preview-canvas" width="1920" height="1080"></canvas>
                </div>
                <div class="text-center mt-2">
                    <small class="text-muted">Preview will update in real-time as you make changes</small>
                </div>
            </section>
        </main>
    </div>
    
    <script>
        // Application State Management System
        
        // Core Application State
        const appState = {
            layout: {
                type: 'layout1',
                dimensions: { width: 1920, height: 1080 },
                overlay: {
                    opacity: 80,  // 0-100 percentage
                    size: 40      // 20-80 percentage of width
                }
            },
            
            text: {
                fields: {
                    fullName: 'John Smith',
                    nickname: 'ジョン',
                    positionEn: 'Senior Data Analyst',
                    positionJp: 'シニアデータアナリスト'
                },
                typography: {
                    japaneseFont: 'Noto Sans JP',
                    englishFont: 'Roboto',
                    fontSize: 18,
                    textColor: 'white'
                },
                positioning: {
                    layout1: 'top-right',
                    layout2: 'top-right'
                }
            },
            
            assets: {
                selectedLogo: 'logo/no-bg-logo-1.png',
                selectedBackground: null,
                customBackground: null,
                logoScale: 1.0
            },
            
            export: {
                filename: '',
                quality: 1.0
            }
        };
        
        // State Change Event System
        class StateEventEmitter {
            constructor() {
                this.listeners = {};
            }
            
            on(event, callback) {
                if (!this.listeners[event]) {
                    this.listeners[event] = [];
                }
                this.listeners[event].push(callback);
            }
            
            off(event, callback) {
                if (!this.listeners[event]) return;
                this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);
            }
            
            emit(event, data) {
                if (!this.listeners[event]) return;
                this.listeners[event].forEach(callback => {
                    try {
                        callback(data);
                    } catch (error) {
                        console.error('Error in state event listener:', error);
                    }
                });
            }
        }
        
        // Global state event emitter
        const stateEvents = new StateEventEmitter();
        
        // State Validation Rules
        const stateValidators = {
            'layout.type': (value) => {
                const validLayouts = ['layout1', 'layout2'];
                if (!validLayouts.includes(value)) {
                    throw new Error(`Invalid layout type: ${value}. Must be one of: ${validLayouts.join(', ')}`);
                }
                return true;
            },
            
            'text.fields.fullName': (value) => {
                if (typeof value !== 'string') {
                    throw new Error('Full name must be a string');
                }
                if (value.length > 100) {
                    throw new Error('Full name must be 100 characters or less');
                }
                return true;
            },
            
            'text.fields.nickname': (value) => {
                if (typeof value !== 'string') {
                    throw new Error('Nickname must be a string');
                }
                if (value.length > 50) {
                    throw new Error('Nickname must be 50 characters or less');
                }
                return true;
            },
            
            'text.fields.positionEn': (value) => {
                if (typeof value !== 'string') {
                    throw new Error('English position must be a string');
                }
                if (value.length > 100) {
                    throw new Error('English position must be 100 characters or less');
                }
                return true;
            },
            
            'text.fields.positionJp': (value) => {
                if (typeof value !== 'string') {
                    throw new Error('Japanese position must be a string');
                }
                if (value.length > 100) {
                    throw new Error('Japanese position must be 100 characters or less');
                }
                return true;
            },
            
            'text.typography.japaneseFont': (value) => {
                const validFonts = ['Noto Sans JP', 'Hiragino Sans', 'Yu Gothic', 'Meiryo', 'Aoboshi One', 'Kaisei Decol'];
                if (!validFonts.includes(value)) {
                    throw new Error(`Invalid Japanese font: ${value}. Must be one of: ${validFonts.join(', ')}`);
                }
                return true;
            },
            
            'text.typography.englishFont': (value) => {
                const validFonts = ['Roboto', 'Open Sans', 'Lato', 'Montserrat', 'Arial', 'Times New Roman'];
                if (!validFonts.includes(value)) {
                    throw new Error(`Invalid English font: ${value}. Must be one of: ${validFonts.join(', ')}`);
                }
                return true;
            },
            
            'text.typography.fontSize': (value) => {
                const size = Number(value);
                if (isNaN(size) || size < 12 || size > 24) {
                    throw new Error('Font size must be a number between 12 and 24');
                }
                return true;
            },
            
            'text.typography.textColor': (value) => {
                const validColors = ['white', 'black'];
                if (!validColors.includes(value)) {
                    throw new Error(`Invalid text color: ${value}. Must be one of: ${validColors.join(', ')}`);
                }
                return true;
            },
            
            'text.positioning.layout1': (value) => {
                const validPositions = ['top-right', 'middle-right', 'bottom-right'];
                if (!validPositions.includes(value)) {
                    throw new Error(`Invalid layout1 position: ${value}. Must be one of: ${validPositions.join(', ')}`);
                }
                return true;
            },
            
            'text.positioning.layout2': (value) => {
                const validPositions = ['top-right', 'middle-right', 'bottom-right', 'bottom-left'];
                if (!validPositions.includes(value)) {
                    throw new Error(`Invalid layout2 position: ${value}. Must be one of: ${validPositions.join(', ')}`);
                }
                return true;
            },
            
            'export.quality': (value) => {
                const quality = Number(value);
                if (isNaN(quality) || quality < 0.1 || quality > 1.0) {
                    throw new Error('Export quality must be a number between 0.1 and 1.0');
                }
                return true;
            },
            
            'layout.overlay.opacity': (value) => {
                const opacity = Number(value);
                if (isNaN(opacity) || opacity < 0 || opacity > 100) {
                    throw new Error('Overlay opacity must be a number between 0 and 100');
                }
                return true;
            },
            
            'layout.overlay.size': (value) => {
                const size = Number(value);
                if (isNaN(size) || size < 20 || size > 80) {
                    throw new Error('Overlay size must be a number between 20 and 80');
                }
                return true;
            }
        };
        
        // State Management Functions
        function validateStateValue(path, value) {
            const validator = stateValidators[path];
            if (validator) {
                return validator(value);
            }
            return true;
        }
        
        function updateAppState(path, value, options = {}) {
            try {
                // Validate the new value
                if (!options.skipValidation) {
                    validateStateValue(path, value);
                }
                
                // Get the old value for comparison
                const oldValue = getAppState(path);
                
                // Update the state
                const keys = path.split('.');
                let current = appState;
                
                for (let i = 0; i < keys.length - 1; i++) {
                    if (!current[keys[i]]) {
                        current[keys[i]] = {};
                    }
                    current = current[keys[i]];
                }
                
                current[keys[keys.length - 1]] = value;
                
                // Emit state change event if value actually changed
                if (oldValue !== value) {
                    stateEvents.emit('stateChange', {
                        path: path,
                        oldValue: oldValue,
                        newValue: value,
                        timestamp: Date.now()
                    });
                    
                    // Emit specific path change event
                    stateEvents.emit(`stateChange:${path}`, {
                        oldValue: oldValue,
                        newValue: value,
                        timestamp: Date.now()
                    });
                }
                
                // Auto-save state if enabled
                if (!options.skipPersistence) {
                    saveStateToStorage();
                }
                
                console.log('App state updated:', path, value);
                return true;
                
            } catch (error) {
                console.error('Failed to update app state:', error.message);
                throw error;
            }
        }
        
        function getAppState(path) {
            try {
                if (!path) {
                    return { ...appState }; // Return a copy of the entire state
                }
                
                const keys = path.split('.');
                let current = appState;
                
                for (const key of keys) {
                    if (current === null || current === undefined) {
                        return undefined;
                    }
                    current = current[key];
                }
                
                return current;
            } catch (error) {
                console.error('Failed to get app state:', error.message);
                return undefined;
            }
        }
        
        function resetAppState() {
            try {
                // Reset to default values
                const defaultState = {
                    layout: {
                        type: 'layout1',
                        dimensions: { width: 1920, height: 1080 }
                    },
                    text: {
                        fields: {
                            fullName: 'John Smith',
                            nickname: 'ジョン',
                            positionEn: 'Senior Data Analyst',
                            positionJp: 'シニアデータアナリスト'
                        },
                        typography: {
                            japaneseFont: 'Noto Sans JP',
                            englishFont: 'Roboto',
                            fontSize: 18,
                            textColor: 'white'
                        },
                        positioning: {
                            layout1: 'top-right',
                            layout2: 'top-right'
                        }
                    },
                    assets: {
                        selectedLogo: 'logo/no-bg-logo-1.png',
                        selectedBackground: null,
                        customBackground: null,
                        logoScale: 1.0
                    },
                    export: {
                        filename: '',
                        quality: 1.0
                    }
                };
                
                // Update each property to trigger events
                Object.keys(defaultState).forEach(key => {
                    appState[key] = defaultState[key];
                });
                
                // Emit reset event
                stateEvents.emit('stateReset', {
                    timestamp: Date.now()
                });
                
                // Save to storage
                saveStateToStorage();
                
                console.log('App state reset to defaults');
                return true;
                
            } catch (error) {
                console.error('Failed to reset app state:', error.message);
                return false;
            }
        }
        
        // State Persistence Functions
        function saveStateToStorage() {
            try {
                const stateJson = JSON.stringify(appState);
                localStorage.setItem('ddamBackgroundGenerator_state', stateJson);
                console.log('State saved to localStorage');
                return true;
            } catch (error) {
                console.error('Failed to save state to localStorage:', error.message);
                return false;
            }
        }
        
        function loadStateFromStorage() {
            try {
                const stateJson = localStorage.getItem('ddamBackgroundGenerator_state');
                if (!stateJson) {
                    console.log('No saved state found in localStorage');
                    return false;
                }
                
                const savedState = JSON.parse(stateJson);
                
                // Validate and merge saved state with current state
                Object.keys(savedState).forEach(key => {
                    if (appState.hasOwnProperty(key)) {
                        appState[key] = { ...appState[key], ...savedState[key] };
                    }
                });
                
                // Emit state loaded event
                stateEvents.emit('stateLoaded', {
                    timestamp: Date.now()
                });
                
                console.log('State loaded from localStorage');
                return true;
                
            } catch (error) {
                console.error('Failed to load state from localStorage:', error.message);
                return false;
            }
        }
        
        function clearStoredState() {
            try {
                localStorage.removeItem('ddamBackgroundGenerator_state');
                console.log('Stored state cleared');
                return true;
            } catch (error) {
                console.error('Failed to clear stored state:', error.message);
                return false;
            }
        }
        
        // Batch State Updates
        function batchUpdateState(updates, options = {}) {
            try {
                const results = [];
                const errors = [];
                
                // Disable persistence during batch updates
                const batchOptions = { ...options, skipPersistence: true };
                
                updates.forEach(({ path, value }, index) => {
                    try {
                        updateAppState(path, value, batchOptions);
                        results.push({ index, path, success: true });
                    } catch (error) {
                        errors.push({ index, path, error: error.message });
                        results.push({ index, path, success: false, error: error.message });
                    }
                });
                
                // Save state once after all updates
                if (!options.skipPersistence) {
                    saveStateToStorage();
                }
                
                // Emit batch update event
                stateEvents.emit('batchStateUpdate', {
                    results: results,
                    errors: errors,
                    timestamp: Date.now()
                });
                
                console.log('Batch state update completed:', results.length, 'updates,', errors.length, 'errors');
                return { results, errors };
                
            } catch (error) {
                console.error('Failed to perform batch state update:', error.message);
                throw error;
            }
        }
        
        // State Debugging Utilities
        function debugState() {
            console.group('DDAM App State Debug');
            console.log('Current State:', JSON.stringify(appState, null, 2));
            console.log('Event Listeners:', Object.keys(stateEvents.listeners));
            console.log('LocalStorage State:', localStorage.getItem('ddamBackgroundGenerator_state'));
            console.groupEnd();
        }
        
        // Export state management functions to global scope for use in other tasks
        window.ddamState = {
            get: getAppState,
            update: updateAppState,
            reset: resetAppState,
            save: saveStateToStorage,
            load: loadStateFromStorage,
            clear: clearStoredState,
            batch: batchUpdateState,
            debug: debugState,
            events: stateEvents
        };
        
        // Layout Selection Management
        class LayoutSelector {
            constructor() {
                this.currentLayout = getAppState('layout.type') || 'layout1';
                this.layoutCards = {};
                this.init();
            }
            
            init() {
                // Get layout card elements
                this.layoutCards.layout1 = document.getElementById('layout1-card');
                this.layoutCards.layout2 = document.getElementById('layout2-card');
                
                if (!this.layoutCards.layout1 || !this.layoutCards.layout2) {
                    console.error('Layout cards not found in DOM');
                    return;
                }
                
                // Set up event listeners
                this.setupEventListeners();
                
                // Set initial active state
                this.updateActiveLayout(this.currentLayout);
                
                // Initialize preview text content
                this.updatePreviewTextContent();
                
                console.log('Layout selector initialized with layout:', this.currentLayout);
            }
            
            setupEventListeners() {
                // Add click listeners to layout cards
                Object.keys(this.layoutCards).forEach(layoutType => {
                    const card = this.layoutCards[layoutType];
                    if (card) {
                        card.addEventListener('click', () => {
                            this.selectLayout(layoutType);
                        });
                        
                        // Add keyboard support
                        card.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                this.selectLayout(layoutType);
                            }
                        });
                        
                        // Make cards focusable
                        card.setAttribute('tabindex', '0');
                        card.setAttribute('role', 'button');
                        card.setAttribute('aria-label', `Select ${layoutType === 'layout1' ? 'Layout 1' : 'Layout 2'}`);
                    }
                });
                
                // Listen for state changes
                stateEvents.on('stateChange:layout.type', (data) => {
                    this.currentLayout = data.newValue;
                    this.updateActiveLayout(data.newValue);
                });
                
                // Listen for text field changes to update preview
                stateEvents.on('stateChange:text.fields.fullName', () => this.updatePreviewTextContent());
                stateEvents.on('stateChange:text.fields.nickname', () => this.updatePreviewTextContent());
                stateEvents.on('stateChange:text.fields.positionEn', () => this.updatePreviewTextContent());
                stateEvents.on('stateChange:text.fields.positionJp', () => this.updatePreviewTextContent());
                
                // Listen for text positioning changes
                stateEvents.on('stateChange:text.positioning.layout1', () => this.updatePreviewTextPosition(this.currentLayout));
                stateEvents.on('stateChange:text.positioning.layout2', () => this.updatePreviewTextPosition(this.currentLayout));
                
                // Listen for overlay changes (Layout 1 only)
                stateEvents.on('stateChange:layout.overlay.opacity', () => {
                    if (this.currentLayout === 'layout1') {
                        updatePreview();
                    }
                });
                stateEvents.on('stateChange:layout.overlay.size', () => {
                    if (this.currentLayout === 'layout1') {
                        updatePreview();
                    }
                });
            }
            
            selectLayout(layoutType) {
                if (!this.layoutCards[layoutType]) {
                    console.error('Invalid layout type:', layoutType);
                    return;
                }
                
                if (this.currentLayout === layoutType) {
                    console.log('Layout already selected:', layoutType);
                    return;
                }
                
                try {
                    // Update application state
                    updateAppState('layout.type', layoutType);
                    
                    // Visual feedback
                    this.showSelectionFeedback(layoutType);
                    
                    console.log('Layout selected:', layoutType);
                    
                } catch (error) {
                    console.error('Failed to select layout:', error.message);
                    this.showError('Failed to select layout. Please try again.');
                }
            }
            
            updateActiveLayout(layoutType) {
                // Remove active class from all cards
                Object.values(this.layoutCards).forEach(card => {
                    if (card) {
                        card.classList.remove('active');
                        card.setAttribute('aria-selected', 'false');
                    }
                });
                
                // Add active class to selected card
                const activeCard = this.layoutCards[layoutType];
                if (activeCard) {
                    activeCard.classList.add('active');
                    activeCard.setAttribute('aria-selected', 'true');
                }
                
                // Update preview text positioning based on layout
                this.updatePreviewTextPosition(layoutType);
            }
            
            updatePreviewTextPosition(layoutType) {
                const layout1Text = document.querySelector('.preview-text-layout1');
                const layout2Text = document.querySelector('.preview-text-layout2');
                
                if (layout1Text && layout2Text) {
                    // Get current text positioning from state
                    const currentPosition1 = getAppState('text.positioning.layout1') || 'top-right';
                    const currentPosition2 = getAppState('text.positioning.layout2') || 'top-right';
                    
                    // Update layout 1 text position
                    layout1Text.className = 'preview-text preview-text-layout1';
                    layout1Text.classList.add(`position-${currentPosition1}`);
                    
                    // Update layout 2 text position  
                    layout2Text.className = 'preview-text preview-text-layout2';
                    layout2Text.classList.add(`position-${currentPosition2}`);
                }
            }
            
            showSelectionFeedback(layoutType) {
                const card = this.layoutCards[layoutType];
                if (!card) return;
                
                // Add temporary animation class
                card.classList.add('selection-feedback');
                
                // Remove animation class after animation completes
                setTimeout(() => {
                    card.classList.remove('selection-feedback');
                }, 300);
            }
            
            showError(message) {
                // Create or update error message element
                let errorElement = document.querySelector('.layout-selection-error');
                if (!errorElement) {
                    errorElement = document.createElement('div');
                    errorElement.className = 'layout-selection-error error';
                    const layoutSelection = document.querySelector('.layout-selection');
                    if (layoutSelection && layoutSelection.parentNode) {
                        layoutSelection.parentNode.insertBefore(errorElement, layoutSelection);
                    }
                }
                
                errorElement.textContent = message;
                errorElement.style.display = 'block';
                
                // Auto-hide error after 5 seconds
                setTimeout(() => {
                    if (errorElement) {
                        errorElement.style.display = 'none';
                    }
                }, 5000);
            }
            
            getCurrentLayout() {
                return this.currentLayout;
            }
            
            // Method to programmatically select layout (for external use)
            setLayout(layoutType) {
                this.selectLayout(layoutType);
            }
            
            // Method to refresh layout selector (useful after state changes)
            refresh() {
                const currentLayout = getAppState('layout.type');
                if (currentLayout !== this.currentLayout) {
                    this.currentLayout = currentLayout;
                    this.updateActiveLayout(currentLayout);
                }
                
                // Update preview text content
                this.updatePreviewTextContent();
            }
            
            // Update preview text content in layout cards
            updatePreviewTextContent() {
                const textFields = getAppState('text.fields');
                if (!textFields) return;
                
                const layout1Text = document.querySelector('.preview-text-layout1');
                const layout2Text = document.querySelector('.preview-text-layout2');
                
                if (layout1Text) {
                    layout1Text.innerHTML = `
                        <div>${textFields.fullName}</div>
                        <div>${textFields.nickname}</div>
                        <div>${textFields.positionEn}</div>
                        <div>${textFields.positionJp}</div>
                    `;
                }
                
                if (layout2Text) {
                    layout2Text.innerHTML = `
                        <div>${textFields.fullName}</div>
                        <div>${textFields.nickname}</div>
                        <div>${textFields.positionEn}</div>
                        <div>${textFields.positionJp}</div>
                    `;
                }
            }
        }
        
        // Text Input Handler Class
        class TextInputHandler {
            constructor() {
                this.form = null;
                this.inputs = {};
                this.debounceTimers = {};
                this.debounceDelay = 300; // 300ms debounce for performance
                
                this.init();
            }
            
            init() {
                this.form = document.getElementById('text-form');
                if (!this.form) {
                    console.error('Text form not found');
                    return;
                }
                
                // Get all text input elements
                this.inputs = {
                    fullName: document.getElementById('fullName'),
                    nickname: document.getElementById('nickname'),
                    positionEn: document.getElementById('positionEn'),
                    positionJp: document.getElementById('positionJp')
                };
                
                // Verify all inputs exist
                for (const [key, input] of Object.entries(this.inputs)) {
                    if (!input) {
                        console.error(`Text input not found: ${key}`);
                        return;
                    }
                }
                
                this.attachEventListeners();
                this.syncInputsWithState();
                
                console.log('Text input handler initialized');
            }
            
            attachEventListeners() {
                // Add event listeners for each input
                Object.entries(this.inputs).forEach(([fieldName, input]) => {
                    // Input event for real-time updates (with debouncing)
                    input.addEventListener('input', (e) => {
                        this.handleInputChange(fieldName, e.target.value);
                    });
                    
                    // Change event for final validation
                    input.addEventListener('change', (e) => {
                        this.handleInputChange(fieldName, e.target.value, { immediate: true });
                    });
                    
                    // Blur event for validation feedback
                    input.addEventListener('blur', (e) => {
                        this.validateInput(fieldName, e.target.value);
                    });
                    
                    // Focus event to clear any error states
                    input.addEventListener('focus', (e) => {
                        this.clearInputError(fieldName);
                    });
                });
                
                // Form submission prevention (since this is a single-page app)
                this.form.addEventListener('submit', (e) => {
                    e.preventDefault();
                    console.log('Form submission prevented - using real-time updates');
                });
            }
            
            handleInputChange(fieldName, value, options = {}) {
                try {
                    // Sanitize input
                    const sanitizedValue = this.sanitizeInput(value);
                    
                    // Update the input value if sanitization changed it
                    if (sanitizedValue !== value) {
                        this.inputs[fieldName].value = sanitizedValue;
                        value = sanitizedValue;
                    }
                    
                    // Debounce updates unless immediate is requested
                    if (options.immediate) {
                        this.updateStateField(fieldName, value);
                    } else {
                        this.debounceUpdate(fieldName, value);
                    }
                    
                } catch (error) {
                    console.error('Error handling input change:', error);
                    this.showInputError(fieldName, error.message);
                }
            }
            
            debounceUpdate(fieldName, value) {
                // Clear existing timer
                if (this.debounceTimers[fieldName]) {
                    clearTimeout(this.debounceTimers[fieldName]);
                }
                
                // Set new timer
                this.debounceTimers[fieldName] = setTimeout(() => {
                    this.updateStateField(fieldName, value);
                    delete this.debounceTimers[fieldName];
                }, this.debounceDelay);
            }
            
            updateStateField(fieldName, value) {
                try {
                    const statePath = `text.fields.${fieldName}`;
                    updateAppState(statePath, value);
                    
                    // Clear any error state
                    this.clearInputError(fieldName);
                    
                    console.log(`Updated ${fieldName}:`, value);
                    
                } catch (error) {
                    console.error(`Failed to update ${fieldName}:`, error);
                    this.showInputError(fieldName, error.message);
                }
            }
            
            sanitizeInput(value) {
                if (typeof value !== 'string') {
                    return '';
                }
                
                // Remove potentially harmful characters and excessive whitespace
                return value
                    .replace(/[<>]/g, '') // Remove angle brackets to prevent HTML injection
                    .replace(/\s+/g, ' ') // Replace multiple spaces with single space
                    .trim(); // Remove leading/trailing whitespace
            }
            
            validateInput(fieldName, value) {
                try {
                    const statePath = `text.fields.${fieldName}`;
                    validateStateValue(statePath, value);
                    
                    // Additional field-specific validation
                    if (fieldName === 'fullName' && value.length === 0) {
                        throw new Error('Full name is required');
                    }
                    
                    if (fieldName === 'nickname' && value.length === 0) {
                        throw new Error('Nickname is required');
                    }
                    
                    if (fieldName === 'positionEn' && value.length === 0) {
                        throw new Error('English position is required');
                    }
                    
                    if (fieldName === 'positionJp' && value.length === 0) {
                        throw new Error('Japanese position is required');
                    }
                    
                    this.clearInputError(fieldName);
                    return true;
                    
                } catch (error) {
                    this.showInputError(fieldName, error.message);
                    return false;
                }
            }
            
            showInputError(fieldName, message) {
                const input = this.inputs[fieldName];
                if (!input) return;
                
                // Add error class
                input.classList.add('error');
                
                // Create or update error message
                let errorElement = document.getElementById(`${fieldName}-error`);
                if (!errorElement) {
                    errorElement = document.createElement('div');
                    errorElement.id = `${fieldName}-error`;
                    errorElement.className = 'form-error';
                    input.parentNode.appendChild(errorElement);
                }
                
                errorElement.textContent = message;
                errorElement.style.display = 'block';
            }
            
            clearInputError(fieldName) {
                const input = this.inputs[fieldName];
                if (!input) return;
                
                // Remove error class
                input.classList.remove('error');
                
                // Hide error message
                const errorElement = document.getElementById(`${fieldName}-error`);
                if (errorElement) {
                    errorElement.style.display = 'none';
                }
            }
            
            syncInputsWithState() {
                // Sync input values with current state
                const textFields = getAppState('text.fields');
                if (!textFields) return;
                
                Object.entries(this.inputs).forEach(([fieldName, input]) => {
                    if (textFields[fieldName] !== undefined) {
                        input.value = textFields[fieldName];
                    }
                });
                
                console.log('Text inputs synced with state');
            }
            
            // Public method to update inputs from external state changes
            updateFromState() {
                this.syncInputsWithState();
            }
            
            // Public method to validate all inputs
            validateAll() {
                let allValid = true;
                
                Object.entries(this.inputs).forEach(([fieldName, input]) => {
                    const isValid = this.validateInput(fieldName, input.value);
                    if (!isValid) {
                        allValid = false;
                    }
                });
                
                return allValid;
            }
            
            // Public method to get current form data
            getFormData() {
                const data = {};
                Object.entries(this.inputs).forEach(([fieldName, input]) => {
                    data[fieldName] = input.value;
                });
                return data;
            }
        }
        
        // Global layout selector instance
        let layoutSelector = null;
        
        // Global text input handler instance
        let textInputHandler = null;
        
        // Global text position handler instance
        let textPositionHandler = null;
        
        // Initialize application
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DDAM Meeting Background Generator initialized');
            console.log('Google Fonts loaded:', document.fonts.ready);
            console.log('HTML2Canvas available:', typeof html2canvas !== 'undefined');
            
            // Load saved state from localStorage
            loadStateFromStorage();
            
            // Debug: Check initial state
            console.log('Initial app state:', getAppState());
            console.log('Initial selected logo:', getAppState('assets.selectedLogo'));
            
            // Test logo loading
            const testLogo = 'logo/no-bg-logo-1.png';
            console.log('Testing logo load:', testLogo);
            loadImage(testLogo).then(img => {
                console.log('Test logo load result:', img ? 'SUCCESS' : 'FAILED');
                if (img) {
                    console.log('Test logo dimensions:', img.width, 'x', img.height);
                }
            });
            
            // Set up state change event listeners
            stateEvents.on('stateChange', function(data) {
                console.log('State changed:', data.path, 'from', data.oldValue, 'to', data.newValue);
                // Trigger preview update when state changes (will be implemented in future tasks)
                updatePreview();
            });
            
            stateEvents.on('stateReset', function(data) {
                console.log('State reset at:', new Date(data.timestamp));
                updatePreview();
            });
            
            stateEvents.on('stateLoaded', function(data) {
                console.log('State loaded from storage at:', new Date(data.timestamp));
                updatePreview();
            });
            
            stateEvents.on('batchStateUpdate', function(data) {
                console.log('Batch state update completed:', data.results.length, 'updates');
                if (data.errors.length > 0) {
                    console.warn('Batch update errors:', data.errors);
                }
            });
            
            // Listen for text field changes to update layout previews
            stateEvents.on('stateChange', function(data) {
                if (data.path.startsWith('text.fields.')) {
                    updateLayoutPreviewText();
                }
            });
            
            // Initialize canvas renderer
            canvasRenderer = new CanvasRenderer();
            
            // Verify font loading and update preview
            document.fonts.ready.then(function() {
                console.log('All fonts loaded successfully');
                updatePreview(); // Redraw with proper fonts
            });
            
            // Initialize layout selector
            layoutSelector = new LayoutSelector();
            
            // Initialize text input handler
            textInputHandler = new TextInputHandler();
            
            // Initialize font manager
            fontManager = new FontManager();
            
            // Initialize asset manager
            assetManager = new AssetManager();
            
            // Initialize text position handler
            textPositionHandler = new TextPositionHandler();
            
            // Initialize preview update manager
            previewUpdateManager = new PreviewUpdateManager();
            
            // Initialize logo scale control
            const logoScaleInput = document.getElementById('logoScale');
            const logoScaleValue = document.getElementById('logoScale-value');
            
            if (logoScaleInput && logoScaleValue) {
                logoScaleInput.addEventListener('input', (e) => {
                    const scale = parseFloat(e.target.value);
                    const percentage = Math.round(scale * 100);
                    logoScaleValue.textContent = percentage + '%';
                    
                    console.log('Logo scale changed to:', scale, '(' + percentage + '%)');
                    
                    // Update state (use updateAppState to trigger events)
                    updateAppState('assets.logoScale', scale);
                });
                
                // Initialize display value
                const currentScale = getAppState('assets.logoScale') || 1.0;
                logoScaleInput.value = currentScale;
                logoScaleValue.textContent = Math.round(currentScale * 100) + '%';
            }
            
            // Initialize overlay controls
            const overlayOpacityInput = document.getElementById('overlay-opacity');
            const overlayOpacityValue = document.getElementById('overlay-opacity-value');
            const overlaySizeInput = document.getElementById('overlay-size');
            const overlaySizeValue = document.getElementById('overlay-size-value');
            
            if (overlayOpacityInput && overlayOpacityValue) {
                overlayOpacityInput.addEventListener('input', (e) => {
                    const opacity = parseInt(e.target.value);
                    overlayOpacityValue.textContent = opacity + '%';
                    
                    console.log('Overlay opacity changed to:', opacity + '%');
                    
                    // Update state (use updateAppState to trigger events)
                    updateAppState('layout.overlay.opacity', opacity);
                });
                
                // Initialize display value
                const currentOpacity = getAppState('layout.overlay.opacity') || 80;
                overlayOpacityInput.value = currentOpacity;
                overlayOpacityValue.textContent = currentOpacity + '%';
            }
            
            if (overlaySizeInput && overlaySizeValue) {
                overlaySizeInput.addEventListener('input', (e) => {
                    const size = parseInt(e.target.value);
                    overlaySizeValue.textContent = size + '%';
                    
                    console.log('Overlay size changed to:', size + '%');
                    
                    // Update state (use updateAppState to trigger events)
                    updateAppState('layout.overlay.size', size);
                });
                
                // Initialize display value
                const currentSize = getAppState('layout.overlay.size') || 40;
                overlaySizeInput.value = currentSize;
                overlaySizeValue.textContent = currentSize + '%';
            }
            
            // Expose layout selector for external access
            window.ddamLayoutSelector = layoutSelector;
            
            // Expose text input handler for external access
            window.ddamTextInputHandler = textInputHandler;
            
            // Expose font manager for external access
            window.ddamFontManager = fontManager;
            
            // Expose asset manager for external access
            window.ddamAssetManager = assetManager;
            
            // Expose canvas renderer for external access
            window.ddamCanvasRenderer = canvasRenderer;
            
            // Expose text position handler for external access
            window.ddamTextPositionHandler = textPositionHandler;
            
            // Expose preview update manager for external access
            window.ddamPreviewUpdateManager = previewUpdateManager;
            
            // Initialize export manager
            exportManager = new ExportManager();
            
            // Initialize export controls
            initializeExportControls();
            
            // Expose export manager for external access
            window.ddamExportManager = exportManager;
            
            // Expose debug functions
            window.debugCanvas = debugCanvas;
            window.debugExport = debugExport;
            
            // Expose state management for debugging
            window.debugState = debugState;
            
            console.log('State management system initialized');
            console.log('Available state functions:', Object.keys(window.ddamState));
            console.log('Layout selector initialized');
            console.log('Export manager initialized');
            
            // Force an initial render after everything is loaded
            setTimeout(() => {
                console.log('Forcing initial preview render...');
                updatePreview();
            }, 1000);
        });
        
        // Function to update layout preview text in real-time
        function updateLayoutPreviewText() {
            const textFields = getAppState('text.fields');
            if (!textFields) return;
            
            const layout1Text = document.querySelector('.preview-text-layout1');
            const layout2Text = document.querySelector('.preview-text-layout2');
            
            const textContent = `
                <div>${textFields.fullName}</div>
                <div>${textFields.nickname}</div>
                <div>${textFields.positionEn}</div>
                <div>${textFields.positionJp}</div>
            `;
            
            if (layout1Text) {
                layout1Text.innerHTML = textContent;
            }
            
            if (layout2Text) {
                layout2Text.innerHTML = textContent;
            }
        }
        
        // Font Management System
        class FontManager {
            constructor() {
                this.loadedFonts = new Set();
                this.fontLoadPromises = new Map();
                this.initializeFontControls();
            }
            
            initializeFontControls() {
                const japaneseFontSelect = document.getElementById('japaneseFont');
                const englishFontSelect = document.getElementById('englishFont');
                const fontSizeSlider = document.getElementById('fontSize');
                const colorToggleButtons = document.querySelectorAll('.color-toggle-btn');
                
                if (japaneseFontSelect) {
                    japaneseFontSelect.addEventListener('change', (e) => {
                        this.handleJapaneseFontChange(e.target.value);
                    });
                }
                
                if (englishFontSelect) {
                    englishFontSelect.addEventListener('change', (e) => {
                        this.handleEnglishFontChange(e.target.value);
                    });
                }
                
                if (fontSizeSlider) {
                    fontSizeSlider.addEventListener('input', (e) => {
                        this.handleFontSizeChange(parseInt(e.target.value));
                    });
                }
                
                colorToggleButtons.forEach(button => {
                    button.addEventListener('click', (e) => {
                        const color = e.currentTarget.dataset.color;
                        this.handleTextColorChange(color);
                    });
                });
                
                // Load initial fonts
                this.loadFont(appState.text.typography.japaneseFont);
                this.loadFont(appState.text.typography.englishFont);
                
                // Initialize UI with current state
                this.updateFontSizeDisplay();
                this.updateColorToggleDisplay();
                
                // Listen for state changes to update typography in real-time
                stateEvents.on('stateChange', (data) => {
                    if (data.path.startsWith('text.typography')) {
                        this.handleTypographyStateChange(data);
                    }
                });
            }
            
            async loadFont(fontFamily) {
                if (this.loadedFonts.has(fontFamily)) {
                    return Promise.resolve();
                }
                
                if (this.fontLoadPromises.has(fontFamily)) {
                    return this.fontLoadPromises.get(fontFamily);
                }
                
                const loadPromise = this.verifyFontLoading(fontFamily);
                this.fontLoadPromises.set(fontFamily, loadPromise);
                
                try {
                    await loadPromise;
                    this.loadedFonts.add(fontFamily);
                    console.log(`Font loaded successfully: ${fontFamily}`);
                    return true;
                } catch (error) {
                    console.warn(`Failed to load font: ${fontFamily}`, error);
                    this.fontLoadPromises.delete(fontFamily);
                    return false;
                }
            }
            
            async verifyFontLoading(fontFamily) {
                // System fonts that don't need loading verification
                const systemFonts = ['Hiragino Sans', 'Yu Gothic', 'Meiryo', 'Arial', 'Times New Roman'];
                
                if (systemFonts.includes(fontFamily)) {
                    // System fonts are assumed to be available
                    return Promise.resolve();
                }
                
                // Check if font is already available
                if (document.fonts.check(`16px "${fontFamily}"`)) {
                    return Promise.resolve();
                }
                
                // Try to load the font (for Google Fonts)
                try {
                    await document.fonts.load(`16px "${fontFamily}"`);
                    
                    // Verify the font was actually loaded
                    if (document.fonts.check(`16px "${fontFamily}"`)) {
                        return Promise.resolve();
                    } else {
                        throw new Error(`Font verification failed: ${fontFamily}`);
                    }
                } catch (error) {
                    // Fallback: wait for fonts.ready and check again
                    await document.fonts.ready;
                    
                    if (document.fonts.check(`16px "${fontFamily}"`)) {
                        return Promise.resolve();
                    } else {
                        // For system fonts, we'll assume they're available even if check fails
                        if (systemFonts.includes(fontFamily)) {
                            console.warn(`System font may not be available: ${fontFamily}, but proceeding anyway`);
                            return Promise.resolve();
                        }
                        throw new Error(`Font not available: ${fontFamily}`);
                    }
                }
            }
            
            async handleJapaneseFontChange(fontFamily) {
                try {
                    // Validate font selection
                    updateAppState('text.typography.japaneseFont', fontFamily);
                    
                    // Load the font
                    await this.loadFont(fontFamily);
                    
                    // Update preview
                    updatePreview();
                    
                    console.log(`Japanese font changed to: ${fontFamily}`);
                } catch (error) {
                    console.error('Error changing Japanese font:', error);
                    this.showFontError('Failed to load Japanese font. Please try another option.');
                }
            }
            
            async handleEnglishFontChange(fontFamily) {
                try {
                    // Validate font selection
                    updateAppState('text.typography.englishFont', fontFamily);
                    
                    // Load the font
                    await this.loadFont(fontFamily);
                    
                    // Update preview
                    updatePreview();
                    
                    console.log(`English font changed to: ${fontFamily}`);
                } catch (error) {
                    console.error('Error changing English font:', error);
                    this.showFontError('Failed to load English font. Please try another option.');
                }
            }
            
            showFontError(message) {
                // Create or update error message
                let errorElement = document.getElementById('font-error');
                if (!errorElement) {
                    errorElement = document.createElement('div');
                    errorElement.id = 'font-error';
                    errorElement.className = 'error';
                    
                    const typographySection = document.querySelector('.control-section:has(#japaneseFont)');
                    if (typographySection) {
                        typographySection.insertBefore(errorElement, typographySection.firstChild.nextSibling);
                    }
                }
                
                errorElement.textContent = message;
                errorElement.style.display = 'block';
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    if (errorElement) {
                        errorElement.style.display = 'none';
                    }
                }, 5000);
            }
            
            getFontLoadStatus(fontFamily) {
                return this.loadedFonts.has(fontFamily);
            }
            
            handleFontSizeChange(fontSize) {
                try {
                    // Validate font size range
                    if (fontSize < 12 || fontSize > 24) {
                        throw new Error('Font size must be between 12px and 24px');
                    }
                    
                    // Update application state
                    updateAppState('text.typography.fontSize', fontSize);
                    
                    // Update display
                    this.updateFontSizeDisplay();
                    
                    // Update preview
                    updatePreview();
                    
                    console.log(`Font size changed to: ${fontSize}px`);
                } catch (error) {
                    console.error('Error changing font size:', error);
                    this.showFontError('Invalid font size. Please select a value between 12px and 24px.');
                }
            }
            
            handleTextColorChange(color) {
                try {
                    // Validate color selection
                    const validColors = ['white', 'black'];
                    if (!validColors.includes(color)) {
                        throw new Error(`Invalid text color: ${color}. Must be 'white' or 'black'.`);
                    }
                    
                    // Update application state
                    updateAppState('text.typography.textColor', color);
                    
                    // Update display
                    this.updateColorToggleDisplay();
                    
                    // Update preview
                    updatePreview();
                    
                    console.log(`Text color changed to: ${color}`);
                } catch (error) {
                    console.error('Error changing text color:', error);
                    this.showFontError('Failed to change text color. Please try again.');
                }
            }
            
            updateFontSizeDisplay() {
                const fontSizeSlider = document.getElementById('fontSize');
                const fontSizeValue = document.getElementById('fontSize-value');
                const currentSize = getAppState('text.typography.fontSize');
                
                if (fontSizeSlider && currentSize) {
                    fontSizeSlider.value = currentSize;
                }
                
                if (fontSizeValue && currentSize) {
                    fontSizeValue.textContent = `${currentSize}px`;
                }
            }
            
            updateColorToggleDisplay() {
                const colorButtons = document.querySelectorAll('.color-toggle-btn');
                const currentColor = getAppState('text.typography.textColor');
                
                colorButtons.forEach(button => {
                    const buttonColor = button.dataset.color;
                    const isActive = buttonColor === currentColor;
                    
                    button.classList.toggle('active', isActive);
                    button.setAttribute('aria-checked', isActive.toString());
                });
            }
            
            handleTypographyStateChange(data) {
                const { path, newValue } = data;
                console.log(`Typography state changed: ${path} = ${newValue}`);
                
                switch (path) {
                    case 'text.typography.fontSize':
                        this.updateFontSizeDisplay();
                        break;
                    case 'text.typography.textColor':
                        this.updateColorToggleDisplay();
                        break;
                    case 'text.typography.japaneseFont':
                        // Update Japanese font dropdown if changed externally
                        const japaneseFontSelect = document.getElementById('japaneseFont');
                        if (japaneseFontSelect && japaneseFontSelect.value !== newValue) {
                            japaneseFontSelect.value = newValue;
                        }
                        break;
                    case 'text.typography.englishFont':
                        // Update English font dropdown if changed externally
                        const englishFontSelect = document.getElementById('englishFont');
                        if (englishFontSelect && englishFontSelect.value !== newValue) {
                            englishFontSelect.value = newValue;
                        }
                        break;
                }
                
                // Update layout preview text with new typography
                this.updateLayoutPreviewTypography();
            }
            
            updateLayoutPreviewTypography() {
                const typography = getAppState('text.typography');
                if (!typography) return;
                
                const layout1Text = document.querySelector('.preview-text-layout1');
                const layout2Text = document.querySelector('.preview-text-layout2');
                
                const fontSize = Math.max(8, typography.fontSize * 0.5); // Scale down for preview
                const color = typography.textColor === 'white' ? '#ffffff' : '#000000';
                
                [layout1Text, layout2Text].forEach(element => {
                    if (element) {
                        element.style.fontSize = `${fontSize}px`;
                        element.style.color = color;
                        
                        // Apply font families to appropriate text elements
                        const children = element.children;
                        for (let i = 0; i < children.length; i++) {
                            const child = children[i];
                            if (i === 0 || i === 2) {
                                // Full name and English position
                                child.style.fontFamily = typography.englishFont;
                            } else {
                                // Nickname and Japanese position
                                child.style.fontFamily = typography.japaneseFont;
                            }
                        }
                    }
                });
            }
            
            getAllLoadedFonts() {
                return Array.from(this.loadedFonts);
            }
        }
        
        // Initialize font manager
        let fontManager;
        
        // Text Position Handler Class
        class TextPositionHandler {
            constructor() {
                this.layout1Positions = null;
                this.layout2Positions = null;
                this.currentLayout = 'layout1';
                
                this.init();
            }
            
            init() {
                // Get position control elements
                this.layout1Positions = document.getElementById('layout1-positions');
                this.layout2Positions = document.getElementById('layout2-positions');
                
                if (!this.layout1Positions || !this.layout2Positions) {
                    console.error('Position control elements not found');
                    return;
                }
                
                // Set up event listeners
                this.setupEventListeners();
                
                // Set initial state based on app state
                this.updatePositionControls();
                
                console.log('Text position handler initialized');
            }
            
            setupEventListeners() {
                // Layout 1 position controls
                const layout1Radios = document.querySelectorAll('input[name="layout1-position"]');
                layout1Radios.forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        if (e.target.checked) {
                            this.selectPosition('layout1', e.target.value);
                        }
                    });
                });
                
                // Layout 1 position option labels (for better UX)
                const layout1Options = document.querySelectorAll('#layout1-positions .position-option');
                layout1Options.forEach(option => {
                    option.addEventListener('click', (e) => {
                        const radio = option.querySelector('input[type="radio"]');
                        if (radio && !radio.checked) {
                            radio.checked = true;
                            this.selectPosition('layout1', radio.value);
                        }
                    });
                    
                    // Keyboard support
                    option.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            const radio = option.querySelector('input[type="radio"]');
                            if (radio) {
                                radio.checked = true;
                                this.selectPosition('layout1', radio.value);
                            }
                        }
                    });
                });
                
                // Layout 2 position controls
                const layout2Radios = document.querySelectorAll('input[name="layout2-position"]');
                layout2Radios.forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        if (e.target.checked) {
                            this.selectPosition('layout2', e.target.value);
                        }
                    });
                });
                
                // Layout 2 position option labels (for better UX)
                const layout2Options = document.querySelectorAll('#layout2-positions .position-option');
                layout2Options.forEach(option => {
                    option.addEventListener('click', (e) => {
                        const radio = option.querySelector('input[type="radio"]');
                        if (radio && !radio.checked) {
                            radio.checked = true;
                            this.selectPosition('layout2', radio.value);
                        }
                    });
                    
                    // Keyboard support
                    option.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            const radio = option.querySelector('input[type="radio"]');
                            if (radio) {
                                radio.checked = true;
                                this.selectPosition('layout2', radio.value);
                            }
                        }
                    });
                });
                
                // Listen for layout changes to show/hide appropriate position controls
                stateEvents.on('stateChange:layout.type', (data) => {
                    this.currentLayout = data.newValue;
                    this.updateVisiblePositionControls(data.newValue);
                });
                
                // Listen for position changes from external sources
                stateEvents.on('stateChange:text.positioning.layout1', (data) => {
                    this.updatePositionSelection('layout1', data.newValue);
                });
                
                stateEvents.on('stateChange:text.positioning.layout2', (data) => {
                    this.updatePositionSelection('layout2', data.newValue);
                });
            }
            
            selectPosition(layout, position) {
                try {
                    // Validate position for the layout
                    const validPositions = this.getValidPositions(layout);
                    if (!validPositions.includes(position)) {
                        throw new Error(`Invalid position "${position}" for ${layout}`);
                    }
                    
                    console.log(`Selecting position for ${layout}:`, position);
                    
                    // Update application state
                    updateAppState(`text.positioning.${layout}`, position);
                    
                    // Update visual selection
                    this.updatePositionSelection(layout, position);
                    
                    console.log(`Position selected for ${layout}:`, position);
                    console.log('Current state after position change:', getAppState(`text.positioning.${layout}`));
                    
                } catch (error) {
                    console.error('Failed to select position:', error);
                    this.showPositionError(layout, 'Failed to select position. Please try again.');
                }
            }
            
            updatePositionSelection(layout, selectedPosition) {
                const options = document.querySelectorAll(`#${layout}-positions .position-option`);
                const radios = document.querySelectorAll(`input[name="${layout}-position"]`);
                
                // Update radio buttons
                radios.forEach(radio => {
                    radio.checked = radio.value === selectedPosition;
                });
                
                // Update visual selection
                options.forEach(option => {
                    const radio = option.querySelector('input[type="radio"]');
                    const isSelected = radio && radio.value === selectedPosition;
                    option.classList.toggle('active', isSelected);
                });
            }
            
            updateVisiblePositionControls(layoutType) {
                // Hide all position control sections
                this.layout1Positions.classList.remove('active');
                this.layout2Positions.classList.remove('active');
                
                // Show the appropriate section
                if (layoutType === 'layout1') {
                    this.layout1Positions.classList.add('active');
                } else if (layoutType === 'layout2') {
                    this.layout2Positions.classList.add('active');
                }
            }
            
            updatePositionControls() {
                // Get current state
                const currentLayout = getAppState('layout.type') || 'layout1';
                const layout1Position = getAppState('text.positioning.layout1') || 'top-right';
                const layout2Position = getAppState('text.positioning.layout2') || 'top-right';
                
                // Update current layout
                this.currentLayout = currentLayout;
                
                // Update visible controls
                this.updateVisiblePositionControls(currentLayout);
                
                // Update selections
                this.updatePositionSelection('layout1', layout1Position);
                this.updatePositionSelection('layout2', layout2Position);
            }
            
            getValidPositions(layout) {
                switch (layout) {
                    case 'layout1':
                        return ['top-right', 'middle-right', 'bottom-right'];
                    case 'layout2':
                        return ['top-right', 'middle-right', 'bottom-right', 'bottom-left'];
                    default:
                        return [];
                }
            }
            
            showPositionError(layout, message) {
                // Create or update error message element
                let errorElement = document.querySelector(`#${layout}-positions .position-error`);
                if (!errorElement) {
                    errorElement = document.createElement('div');
                    errorElement.className = 'position-error error';
                    const positionSection = document.getElementById(`${layout}-positions`);
                    if (positionSection) {
                        positionSection.appendChild(errorElement);
                    }
                }
                
                errorElement.textContent = message;
                errorElement.style.display = 'block';
                
                // Auto-hide error after 5 seconds
                setTimeout(() => {
                    if (errorElement) {
                        errorElement.style.display = 'none';
                    }
                }, 5000);
            }
            
            // Method to get current position for a layout
            getCurrentPosition(layout) {
                return getAppState(`text.positioning.${layout}`);
            }
            
            // Method to programmatically set position (for external use)
            setPosition(layout, position) {
                this.selectPosition(layout, position);
            }
            
            // Method to refresh position controls (useful after state changes)
            refresh() {
                this.updatePositionControls();
            }
            
            // Method to get position coordinates for canvas rendering
            getPositionCoordinates(layout, position, containerWidth, containerHeight, textWidth, textHeight) {
                const padding = 20; // Reduced padding for closer alignment to corners
                let x, y;
                
                switch (position) {
                    case 'top-right':
                        x = containerWidth - textWidth - padding;
                        y = padding;
                        break;
                    case 'middle':
                        x = (containerWidth - textWidth) / 2;
                        y = (containerHeight - textHeight) / 2;
                        break;
                    case 'middle-right':
                        x = containerWidth - textWidth - padding;
                        y = (containerHeight - textHeight) / 2;
                        break;
                    case 'bottom-left':
                        x = padding;
                        y = containerHeight - textHeight - padding;
                        break;
                    case 'bottom-right':
                        x = containerWidth - textWidth - padding;
                        y = containerHeight - textHeight - padding;
                        break;
                    default:
                        x = padding;
                        y = padding;
                }
                
                // Layout-specific adjustments
                if (layout === 'layout1') {
                    // Adjust for overlay area in Layout 1 - keep text closer to right edge
                    if (position === 'top-right' || position === 'middle-right' || position === 'bottom-right') {
                        // Ensure text is within the overlay area but closer to the right edge
                        x = Math.min(x, containerWidth - padding); // Much closer to right edge
                        x = Math.max(x, containerWidth * 0.65); // Keep within overlay but allow closer positioning
                    }
                }
                
                return { x, y };
            }
        }
        
        // Asset Management System
        class AssetManager {
            constructor() {
                this.logoCache = new Map();
                this.backgroundCache = new Map();
                this.currentTab = 'logos';
                this.logoList = [
                    'logo/logo-1.png',
                    'logo/logo-2.png',
                    'logo/logo-3.png',
                    'logo/no-bg-logo-1.png',
                    'logo/no-bg-logo-2.png',
                    'logo/no-bg-logo-3.png'
                ];
                this.backgroundList = [
                    'background-img/12.png',
                    'background-img/13.png',
                    'background-img/14.png',
                    'background-img/15.png',
                    'background-img/16.png',
                    'background-img/17.png',
                    'background-img/18.png',
                    'background-img/19.png',
                    'background-img/20.png',
                    'background-img/21.png'
                ];
                
                this.init();
            }
            
            init() {
                this.setupTabNavigation();
                this.setupUploadArea();
                this.loadLogos();
                
                // Listen for asset state changes
                stateEvents.on('stateChange:assets.selectedLogo', (data) => {
                    this.updateLogoSelection(data.newValue);
                });
                
                stateEvents.on('stateChange:assets.selectedBackground', (data) => {
                    this.updateBackgroundSelection(data.newValue);
                });
                
                console.log('Asset manager initialized');
            }
            
            setupTabNavigation() {
                const tabs = document.querySelectorAll('.asset-tab');
                const panels = document.querySelectorAll('.asset-panel');
                
                tabs.forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        const tabName = e.target.dataset.tab;
                        this.switchTab(tabName);
                    });
                });
            }
            
            switchTab(tabName) {
                const tabs = document.querySelectorAll('.asset-tab');
                const panels = document.querySelectorAll('.asset-panel');
                
                // Update tab active states
                tabs.forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.tab === tabName);
                });
                
                // Show/hide panels
                panels.forEach(panel => {
                    panel.style.display = panel.id === `${tabName}-panel` ? 'block' : 'none';
                });
                
                this.currentTab = tabName;
                
                // Load content for the selected tab
                switch (tabName) {
                    case 'logos':
                        this.loadLogos();
                        break;
                    case 'backgrounds':
                        this.loadBackgrounds();
                        break;
                    case 'upload':
                        // Upload panel is already set up
                        break;
                }
                
                console.log(`Switched to ${tabName} tab`);
            }
            
            async loadLogos() {
                const loadingElement = document.getElementById('logos-loading');
                const galleryElement = document.getElementById('logos-gallery');
                const errorElement = document.getElementById('logos-error');
                
                try {
                    // Show loading state
                    loadingElement.style.display = 'flex';
                    galleryElement.style.display = 'none';
                    errorElement.style.display = 'none';
                    
                    // Clear existing gallery
                    galleryElement.innerHTML = '';
                    
                    // Load each logo
                    const logoPromises = this.logoList.map(logoPath => this.loadLogoItem(logoPath));
                    const logoResults = await Promise.allSettled(logoPromises);
                    
                    // Process results
                    const successfulLogos = [];
                    logoResults.forEach((result, index) => {
                        if (result.status === 'fulfilled') {
                            successfulLogos.push(result.value);
                        } else {
                            console.warn(`Failed to load logo: ${this.logoList[index]}`, result.reason);
                        }
                    });
                    
                    if (successfulLogos.length === 0) {
                        throw new Error('No logos could be loaded');
                    }
                    
                    // Populate gallery
                    successfulLogos.forEach(logoElement => {
                        galleryElement.appendChild(logoElement);
                    });
                    
                    // Update selection state
                    const selectedLogo = getAppState('assets.selectedLogo');
                    console.log('Current selected logo from state:', selectedLogo);
                    
                    if (selectedLogo) {
                        this.updateLogoSelection(selectedLogo);
                        console.log('Updated logo selection to:', selectedLogo);
                    } else {
                        // If no logo is selected, select the first one (default)
                        const defaultLogo = 'logo/no-bg-logo-1.png';
                        console.log('No logo selected, setting default:', defaultLogo);
                        updateAppState('assets.selectedLogo', defaultLogo);
                        this.updateLogoSelection(defaultLogo);
                    }
                    
                    // Show gallery
                    loadingElement.style.display = 'none';
                    galleryElement.style.display = 'grid';
                    
                    console.log(`Loaded ${successfulLogos.length} logos successfully`);
                    
                    // Trigger preview update to ensure logo appears
                    updatePreview();
                    
                } catch (error) {
                    console.error('Failed to load logos:', error);
                    loadingElement.style.display = 'none';
                    errorElement.style.display = 'block';
                    errorElement.textContent = 'Failed to load logos. Please refresh the page.';
                }
            }
            
            async loadLogoItem(logoPath) {
                return new Promise((resolve, reject) => {
                    // Check cache first
                    if (this.logoCache.has(logoPath)) {
                        const cachedElement = this.logoCache.get(logoPath).cloneNode(true);
                        this.attachLogoEventListeners(cachedElement, logoPath);
                        resolve(cachedElement);
                        return;
                    }
                    
                    // Create logo item element
                    const logoItem = document.createElement('div');
                    logoItem.className = 'asset-item logo-item';
                    logoItem.dataset.logoPath = logoPath;
                    logoItem.setAttribute('tabindex', '0');
                    logoItem.setAttribute('role', 'button');
                    logoItem.setAttribute('aria-label', `Select logo ${logoPath}`);
                    
                    // Create thumbnail image
                    const thumbnail = document.createElement('img');
                    thumbnail.className = 'asset-thumbnail logo-thumbnail';
                    thumbnail.alt = `Logo ${logoPath}`;
                    
                    // Create selector indicator
                    const selector = document.createElement('div');
                    selector.className = 'asset-selector';
                    selector.innerHTML = '<div class="asset-selector-icon">✓</div>';
                    
                    // Handle image load
                    thumbnail.onload = () => {
                        logoItem.appendChild(thumbnail);
                        logoItem.appendChild(selector);
                        
                        // Cache the element
                        this.logoCache.set(logoPath, logoItem.cloneNode(true));
                        
                        // Attach event listeners
                        this.attachLogoEventListeners(logoItem, logoPath);
                        
                        resolve(logoItem);
                    };
                    
                    // Handle image error
                    thumbnail.onerror = () => {
                        reject(new Error(`Failed to load logo image: ${logoPath}`));
                    };
                    
                    // Set image source
                    thumbnail.src = logoPath;
                });
            }
            
            attachLogoEventListeners(logoItem, logoPath) {
                // Click handler
                logoItem.addEventListener('click', () => {
                    this.selectLogo(logoPath);
                });
                
                // Keyboard handler
                logoItem.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.selectLogo(logoPath);
                    }
                });
            }
            
            selectLogo(logoPath) {
                try {
                    // Update application state
                    updateAppState('assets.selectedLogo', logoPath);
                    
                    // Update preview
                    updatePreview();
                    
                    console.log(`Logo selected: ${logoPath}`);
                    
                } catch (error) {
                    console.error('Failed to select logo:', error);
                    this.showAssetError('logos', 'Failed to select logo. Please try again.');
                }
            }
            
            updateLogoSelection(selectedLogoPath) {
                const logoItems = document.querySelectorAll('.logo-item');
                
                logoItems.forEach(item => {
                    const isSelected = item.dataset.logoPath === selectedLogoPath;
                    item.classList.toggle('active', isSelected);
                    item.setAttribute('aria-selected', isSelected.toString());
                });
            }
            
            async loadBackgrounds() {
                const loadingElement = document.getElementById('backgrounds-loading');
                const galleryElement = document.getElementById('backgrounds-gallery');
                const errorElement = document.getElementById('backgrounds-error');
                
                try {
                    // Show loading state
                    loadingElement.style.display = 'flex';
                    galleryElement.style.display = 'none';
                    errorElement.style.display = 'none';
                    
                    // Clear existing gallery
                    galleryElement.innerHTML = '';
                    
                    // Load each background
                    const backgroundPromises = this.backgroundList.map(bgPath => this.loadBackgroundItem(bgPath));
                    const backgroundResults = await Promise.allSettled(backgroundPromises);
                    
                    // Process results
                    const successfulBackgrounds = [];
                    backgroundResults.forEach((result, index) => {
                        if (result.status === 'fulfilled') {
                            successfulBackgrounds.push(result.value);
                        } else {
                            console.warn(`Failed to load background: ${this.backgroundList[index]}`, result.reason);
                        }
                    });
                    
                    if (successfulBackgrounds.length === 0) {
                        throw new Error('No backgrounds could be loaded');
                    }
                    
                    // Populate gallery
                    successfulBackgrounds.forEach(backgroundElement => {
                        galleryElement.appendChild(backgroundElement);
                    });
                    
                    // Update selection state
                    const selectedBackground = getAppState('assets.selectedBackground');
                    if (selectedBackground) {
                        this.updateBackgroundSelection(selectedBackground);
                    }
                    
                    // Show gallery
                    loadingElement.style.display = 'none';
                    galleryElement.style.display = 'grid';
                    
                    console.log(`Loaded ${successfulBackgrounds.length} backgrounds successfully`);
                    
                } catch (error) {
                    console.error('Failed to load backgrounds:', error);
                    loadingElement.style.display = 'none';
                    errorElement.style.display = 'block';
                    errorElement.textContent = 'Failed to load backgrounds. Please refresh the page.';
                }
            }
            
            async loadBackgroundItem(backgroundPath) {
                return new Promise((resolve, reject) => {
                    // Check cache first
                    if (this.backgroundCache.has(backgroundPath)) {
                        const cachedElement = this.backgroundCache.get(backgroundPath).cloneNode(true);
                        this.attachBackgroundEventListeners(cachedElement, backgroundPath);
                        resolve(cachedElement);
                        return;
                    }
                    
                    // Create background item element
                    const backgroundItem = document.createElement('div');
                    backgroundItem.className = 'asset-item background-item';
                    backgroundItem.dataset.backgroundPath = backgroundPath;
                    backgroundItem.setAttribute('tabindex', '0');
                    backgroundItem.setAttribute('role', 'button');
                    backgroundItem.setAttribute('aria-label', `Select background ${backgroundPath}`);
                    
                    // Create thumbnail image
                    const thumbnail = document.createElement('img');
                    thumbnail.className = 'asset-thumbnail background-thumbnail';
                    thumbnail.alt = `Background ${backgroundPath}`;
                    
                    // Create selector indicator
                    const selector = document.createElement('div');
                    selector.className = 'asset-selector';
                    selector.innerHTML = '<div class="asset-selector-icon">✓</div>';
                    
                    // Handle image load
                    thumbnail.onload = () => {
                        backgroundItem.appendChild(thumbnail);
                        backgroundItem.appendChild(selector);
                        
                        // Cache the element
                        this.backgroundCache.set(backgroundPath, backgroundItem.cloneNode(true));
                        
                        // Attach event listeners
                        this.attachBackgroundEventListeners(backgroundItem, backgroundPath);
                        
                        resolve(backgroundItem);
                    };
                    
                    // Handle image error
                    thumbnail.onerror = () => {
                        reject(new Error(`Failed to load background image: ${backgroundPath}`));
                    };
                    
                    // Set image source
                    thumbnail.src = backgroundPath;
                });
            }
            
            attachBackgroundEventListeners(backgroundItem, backgroundPath) {
                // Click handler
                backgroundItem.addEventListener('click', () => {
                    this.selectBackground(backgroundPath);
                });
                
                // Keyboard handler
                backgroundItem.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.selectBackground(backgroundPath);
                    }
                });
            }
            
            selectBackground(backgroundPath) {
                try {
                    // Update application state
                    updateAppState('assets.selectedBackground', backgroundPath);
                    
                    // Clear custom background if selecting a preset
                    if (getAppState('assets.customBackground')) {
                        updateAppState('assets.customBackground', null);
                    }
                    
                    // Update preview
                    updatePreview();
                    
                    console.log(`Background selected: ${backgroundPath}`);
                    
                } catch (error) {
                    console.error('Failed to select background:', error);
                    this.showAssetError('backgrounds', 'Failed to select background. Please try again.');
                }
            }
            
            updateBackgroundSelection(selectedBackgroundPath) {
                const backgroundItems = document.querySelectorAll('.background-item');
                
                backgroundItems.forEach(item => {
                    const isSelected = item.dataset.backgroundPath === selectedBackgroundPath;
                    item.classList.toggle('active', isSelected);
                    item.setAttribute('aria-selected', isSelected.toString());
                });
            }
            
            setupUploadArea() {
                const uploadArea = document.getElementById('upload-area');
                const uploadInput = document.getElementById('upload-input');
                const uploadError = document.getElementById('upload-error');
                
                if (!uploadArea || !uploadInput) {
                    console.error('Upload elements not found');
                    return;
                }
                
                // Click to upload
                uploadArea.addEventListener('click', () => {
                    uploadInput.click();
                });
                
                // File input change
                uploadInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.handleFileUpload(file);
                    }
                });
                
                // Drag and drop
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                
                uploadArea.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.handleFileUpload(files[0]);
                    }
                });
            }
            
            async handleFileUpload(file) {
                const uploadError = document.getElementById('upload-error');
                
                try {
                    // Validate file
                    this.validateUploadedFile(file);
                    
                    // Process image
                    const processedImage = await this.processUploadedImage(file);
                    
                    // Update application state
                    updateAppState('assets.customBackground', processedImage);
                    updateAppState('assets.selectedBackground', null); // Clear preset selection
                    
                    // Update preview
                    updatePreview();
                    
                    // Hide error
                    uploadError.style.display = 'none';
                    
                    // Show success feedback
                    this.showUploadSuccess();
                    
                    console.log('File uploaded successfully:', file.name);
                    
                } catch (error) {
                    console.error('File upload failed:', error);
                    this.showAssetError('upload', error.message);
                }
            }
            
            validateUploadedFile(file) {
                const validTypes = ['image/jpeg', 'image/png', 'image/webp'];
                const maxSize = 10 * 1024 * 1024; // 10MB
                
                if (!validTypes.includes(file.type)) {
                    throw new Error('Please upload a valid image file (JPEG, PNG, or WebP)');
                }
                
                if (file.size > maxSize) {
                    throw new Error('File size must be less than 10MB');
                }
                
                return true;
            }
            
            async processUploadedImage(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {
                        const img = new Image();
                        
                        img.onload = () => {
                            try {
                                // Create canvas for processing
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                
                                // Set target dimensions (16:9 aspect ratio)
                                const targetWidth = 1920;
                                const targetHeight = 1080;
                                
                                canvas.width = targetWidth;
                                canvas.height = targetHeight;
                                
                                // Calculate scaling to maintain aspect ratio
                                const imgAspect = img.width / img.height;
                                const targetAspect = targetWidth / targetHeight;
                                
                                let drawWidth, drawHeight, drawX, drawY;
                                
                                if (imgAspect > targetAspect) {
                                    // Image is wider than target - fit by height
                                    drawHeight = targetHeight;
                                    drawWidth = drawHeight * imgAspect;
                                    drawX = (targetWidth - drawWidth) / 2;
                                    drawY = 0;
                                } else {
                                    // Image is taller than target - fit by width
                                    drawWidth = targetWidth;
                                    drawHeight = drawWidth / imgAspect;
                                    drawX = 0;
                                    drawY = (targetHeight - drawHeight) / 2;
                                }
                                
                                // Fill background with black
                                ctx.fillStyle = '#000000';
                                ctx.fillRect(0, 0, targetWidth, targetHeight);
                                
                                // Draw image
                                ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                                
                                // Convert to data URL
                                const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
                                
                                resolve({
                                    dataUrl: dataUrl,
                                    originalName: file.name,
                                    processedWidth: targetWidth,
                                    processedHeight: targetHeight
                                });
                                
                            } catch (error) {
                                reject(new Error('Failed to process image: ' + error.message));
                            }
                        };
                        
                        img.onerror = () => {
                            reject(new Error('Failed to load uploaded image'));
                        };
                        
                        img.src = e.target.result;
                    };
                    
                    reader.onerror = () => {
                        reject(new Error('Failed to read uploaded file'));
                    };
                    
                    reader.readAsDataURL(file);
                });
            }
            
            showUploadSuccess() {
                const uploadArea = document.getElementById('upload-area');
                if (!uploadArea) return;
                
                // Temporarily show success state
                const originalContent = uploadArea.innerHTML;
                uploadArea.innerHTML = `
                    <div class="upload-icon">✅</div>
                    <div class="upload-text">Upload successful!</div>
                    <div class="upload-hint">Your custom background has been applied</div>
                `;
                
                // Restore original content after 3 seconds
                setTimeout(() => {
                    uploadArea.innerHTML = originalContent;
                }, 3000);
            }
            
            showAssetError(section, message) {
                const errorElement = document.getElementById(`${section}-error`);
                if (!errorElement) return;
                
                errorElement.textContent = message;
                errorElement.style.display = 'block';
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    errorElement.style.display = 'none';
                }, 5000);
            }
            
            // Public methods for external access
            getSelectedLogo() {
                return getAppState('assets.selectedLogo');
            }
            
            getSelectedBackground() {
                return getAppState('assets.selectedBackground');
            }
            
            getCustomBackground() {
                return getAppState('assets.customBackground');
            }
            
            refreshAssets() {
                switch (this.currentTab) {
                    case 'logos':
                        this.loadLogos();
                        break;
                    case 'backgrounds':
                        this.loadBackgrounds();
                        break;
                }
            }
        }
        
        // Initialize asset manager
        let assetManager;
        
        // Canvas Rendering System
        class CanvasRenderer {
            constructor() {
                this.canvas = document.getElementById('preview-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.outputWidth = 1920;
                this.outputHeight = 1080;
                this.aspectRatio = 16 / 9;
                
                this.init();
            }
            
            init() {
                if (!this.canvas || !this.ctx) {
                    console.error('Canvas or context not found');
                    return;
                }
                
                // Set canvas dimensions for 1920x1080 output
                this.canvas.width = this.outputWidth;
                this.canvas.height = this.outputHeight;
                
                // Set up responsive scaling
                this.setupResponsiveScaling();
                
                // Initialize coordinate system
                this.setupCoordinateSystem();
                
                console.log('Canvas renderer initialized with dimensions:', this.outputWidth, 'x', this.outputHeight);
                
                // Test canvas drawing capability
                this.testCanvasDrawing();
            }
            
            setupResponsiveScaling() {
                // The canvas will be scaled via CSS to fit the container
                // while maintaining the 16:9 aspect ratio
                const container = this.canvas.parentElement;
                if (container) {
                    // CSS already handles responsive scaling via aspect-ratio and max-width
                    console.log('Responsive scaling configured via CSS');
                }
            }
            
            setupCoordinateSystem() {
                // Set up coordinate system for 1920x1080 output
                // Origin (0,0) is top-left corner
                // X increases to the right, Y increases downward
                this.ctx.textBaseline = 'top';
                this.ctx.textAlign = 'left';
                
                // Enable high-quality rendering
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
                
                console.log('Coordinate system configured for 1920x1080 output');
            }
            
            testCanvasDrawing() {
                // Test if canvas can draw
                this.ctx.fillStyle = '#ff0000';
                this.ctx.fillRect(10, 10, 100, 100);
                console.log('Canvas test drawing completed - red square at (10,10)');
                
                // Clear the test drawing
                setTimeout(() => {
                    this.ctx.clearRect(10, 10, 100, 100);
                    console.log('Canvas test drawing cleared');
                }, 1000);
            }
            
            // Basic drawing utilities
            clear() {
                this.ctx.clearRect(0, 0, this.outputWidth, this.outputHeight);
                console.log('Canvas cleared - dimensions:', this.outputWidth, 'x', this.outputHeight);
            }
            
            drawBackground(color = '#f8f9fa') {
                this.ctx.fillStyle = color;
                this.ctx.fillRect(0, 0, this.outputWidth, this.outputHeight);
                console.log('Background drawn with color:', color, 'at dimensions:', this.outputWidth, 'x', this.outputHeight);
            }
            
            drawImage(image, x, y, width, height) {
                if (image && image.complete) {
                    this.ctx.drawImage(image, x, y, width, height);
                }
            }
            
            drawText(text, x, y, options = {}) {
                const {
                    font = '24px Roboto',
                    color = '#000000',
                    align = 'left',
                    baseline = 'top',
                    maxWidth = null,
                    lineHeight = 1.2
                } = options;
                
                this.ctx.save();
                this.ctx.font = font;
                this.ctx.fillStyle = color;
                this.ctx.textAlign = align;
                this.ctx.textBaseline = baseline;
                
                if (maxWidth) {
                    this.ctx.fillText(text, x, y, maxWidth);
                } else {
                    this.ctx.fillText(text, x, y);
                }
                
                this.ctx.restore();
            }
            
            drawRoundedRect(x, y, width, height, radius, options = {}) {
                const {
                    fillStyle = null,
                    strokeStyle = null,
                    lineWidth = 1
                } = options;
                
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.roundRect(x, y, width, height, radius);
                
                if (fillStyle) {
                    this.ctx.fillStyle = fillStyle;
                    this.ctx.fill();
                }
                
                if (strokeStyle) {
                    this.ctx.strokeStyle = strokeStyle;
                    this.ctx.lineWidth = lineWidth;
                    this.ctx.stroke();
                }
                
                this.ctx.restore();
            }
            
            drawOverlay(x, y, width, height, color, opacity = 0.8) {
                this.ctx.save();
                this.ctx.globalAlpha = opacity;
                this.ctx.fillStyle = color;
                this.ctx.fillRect(x, y, width, height);
                this.ctx.restore();
            }
            
            // Utility methods for coordinate calculations
            getTextWidth(text, font) {
                this.ctx.save();
                this.ctx.font = font;
                const width = this.ctx.measureText(text).width;
                this.ctx.restore();
                return width;
            }
            
            getTextHeight(font) {
                this.ctx.save();
                this.ctx.font = font;
                const metrics = this.ctx.measureText('Mg');
                const height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                this.ctx.restore();
                return height || parseInt(font.match(/\d+/)[0]); // Fallback to font size
            }
            
            // Position calculation utilities
            calculateTextPosition(position, containerWidth, containerHeight, textWidth, textHeight, padding = 20) {
                let x, y;
                
                switch (position) {
                    case 'top-right':
                        x = containerWidth - textWidth - padding;
                        y = padding;
                        break;
                    case 'middle':
                        x = (containerWidth - textWidth) / 2;
                        y = (containerHeight - textHeight) / 2;
                        break;
                    case 'middle-right':
                        x = containerWidth - textWidth - padding;
                        y = (containerHeight - textHeight) / 2;
                        break;
                    case 'bottom-left':
                        x = padding;
                        y = containerHeight - textHeight - padding;
                        break;
                    case 'bottom-right':
                        x = containerWidth - textWidth - padding;
                        y = containerHeight - textHeight - padding;
                        break;
                    default:
                        x = padding;
                        y = padding;
                }
                
                return { x, y };
            }
            
            // Layout 1 rendering function
            renderLayout1(backgroundImage = null, logoImage = null) {
                console.log('Starting renderLayout1 with:', { backgroundImage: !!backgroundImage, logoImage: !!logoImage });
                this.clear();
                
                // Draw background image or default background
                if (backgroundImage && backgroundImage.complete) {
                    console.log('Drawing background image');
                    this.drawImage(backgroundImage, 0, 0, this.outputWidth, this.outputHeight);
                } else {
                    console.log('Drawing default gradient background');
                    // Default gradient background
                    const gradient = this.ctx.createLinearGradient(0, 0, this.outputWidth, this.outputHeight);
                    gradient.addColorStop(0, '#667eea');
                    gradient.addColorStop(1, '#764ba2');
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.outputWidth, this.outputHeight);
                    console.log('Gradient background drawn');
                }
                
                // Draw rounded black frame
                const frameMargin = 20;
                const frameRadius = 20;
                this.drawRoundedRect(
                    frameMargin, 
                    frameMargin, 
                    this.outputWidth - (frameMargin * 2), 
                    this.outputHeight - (frameMargin * 2), 
                    frameRadius,
                    {
                        strokeStyle: 'rgba(0, 0, 0, 0.8)',
                        lineWidth: 4
                    }
                );
                
                // Draw transparent black overlay on right side (dynamic size and opacity)
                const overlaySize = getAppState('layout.overlay.size') || 40; // Percentage of width
                const overlayOpacity = getAppState('layout.overlay.opacity') || 80; // Percentage opacity
                
                const overlayWidthPercent = overlaySize / 100; // Convert to decimal
                const overlayOpacityDecimal = overlayOpacity / 100; // Convert to decimal
                
                const overlayStartX = this.outputWidth * (1 - overlayWidthPercent); // Start position
                const overlayWidth = this.outputWidth * overlayWidthPercent; // Width of overlay
                
                this.drawOverlay(
                    overlayStartX,
                    frameMargin,
                    overlayWidth - frameMargin,
                    this.outputHeight - (frameMargin * 2),
                    `rgba(0, 0, 0, ${overlayOpacityDecimal})`,
                    overlayOpacityDecimal
                );
                
                // Position logo in top-left corner (larger and more visible)
                console.log('Layout1 - Logo rendering:', {
                    logoImage: logoImage,
                    hasLogo: !!logoImage,
                    isComplete: logoImage ? logoImage.complete : false
                });
                
                if (logoImage && logoImage.complete) {
                    // Get logo size from state (with default)
                    const logoScale = getAppState('assets.logoScale') || 1.0;
                    const baseLogoWidth = 400; // Base width for 500×300 aspect ratio
                    const baseLogoHeight = 240; // Base height for 500×300 aspect ratio
                    
                    const logoWidth = baseLogoWidth * logoScale;
                    const logoHeight = baseLogoHeight * logoScale;
                    const logoMargin = 40; // Reduced from 80 to move closer to corner
                    
                    console.log('Drawing logo image at:', logoMargin, logoMargin, logoWidth, logoHeight);
                    console.log('Logo scale applied:', logoScale, 'Final size:', logoWidth, 'x', logoHeight);
                    this.drawImage(logoImage, logoMargin, logoMargin, logoWidth, logoHeight);
                } else {
                    // Draw placeholder logo (larger)
                    console.log('Drawing placeholder logo - no valid logo image');
                    this.drawText('DDAM LOGO', 40, 80, {
                        font: 'bold 64px Roboto',
                        color: 'white'
                    });
                }
                
                // Add copyright text in bottom-left position
                const copyrightText = '©2025 DDAM LLC';
                this.drawText(copyrightText, 40, this.outputHeight - 60, {
                    font: '28px Roboto', // Increased font size for better visibility
                    color: 'rgba(255, 255, 255, 0.8)'
                });
                
                // Implement flexible text positioning
                this.renderLayout1Text();
                
                console.log('renderLayout1 completed successfully');
            }
            
            renderLayout1Text() {
                const textFields = getAppState('text.fields');
                const typography = getAppState('text.typography');
                const position = getAppState('text.positioning.layout1') || 'top-right';
                
                console.log('Layout1 - Rendering text with position:', position);
                
                if (!textFields || !typography) return;
                
                // Scale up font sizes for better visibility (multiply by 3 for 1920x1080)
                const baseFontSize = typography.fontSize * 3;
                const textColor = typography.textColor === 'white' ? '#ffffff' : '#000000';
                const englishFont = typography.englishFont;
                const japaneseFont = typography.japaneseFont;
                
                // Prepare text lines with larger fonts
                const lines = [
                    { text: textFields.fullName, font: `bold ${baseFontSize}px ${englishFont}` },
                    { text: textFields.nickname, font: `${baseFontSize}px ${japaneseFont}` },
                    { text: textFields.positionEn, font: `${Math.round(baseFontSize * 0.8)}px ${englishFont}` },
                    { text: textFields.positionJp, font: `${Math.round(baseFontSize * 0.8)}px ${japaneseFont}` }
                ];
                
                // Calculate text block dimensions
                let maxWidth = 0;
                let totalHeight = 0;
                const lineHeight = baseFontSize * 1.3;
                
                lines.forEach(line => {
                    const width = this.getTextWidth(line.text, line.font);
                    maxWidth = Math.max(maxWidth, width);
                    totalHeight += lineHeight;
                });
                
                // Calculate position for Layout 1 with proper alignment
                let textPosition;
                const padding = 60;
                
                console.log('Layout1 - Calculating position for:', position);
                
                switch (position) {
                    case 'top-right':
                        textPosition = {
                            x: this.outputWidth - padding,
                            y: padding + 100, // Closer to top, below logo area
                            align: 'right'
                        };
                        break;
                    case 'middle-right':
                        textPosition = {
                            x: this.outputWidth - padding,
                            y: (this.outputHeight - totalHeight) / 2,
                            align: 'right'
                        };
                        break;
                    case 'bottom-right':
                        textPosition = {
                            x: this.outputWidth - padding,
                            y: this.outputHeight - totalHeight - padding - 100, // Above copyright
                            align: 'right'
                        };
                        break;
                    default:
                        textPosition = {
                            x: this.outputWidth - padding,
                            y: padding + 280,
                            align: 'right'
                        };
                }
                
                // Draw text lines with proper alignment
                let currentY = textPosition.y;
                lines.forEach(line => {
                    this.drawText(line.text, textPosition.x, currentY, {
                        font: line.font,
                        color: textColor,
                        align: textPosition.align
                    });
                    currentY += lineHeight;
                });
            }
            
            // Layout 2 rendering function
            renderLayout2(backgroundImage = null, logoImage = null) {
                this.clear();
                
                // Draw background image or default background
                if (backgroundImage && backgroundImage.complete) {
                    this.drawImage(backgroundImage, 0, 0, this.outputWidth, this.outputHeight);
                } else {
                    // Default gradient background
                    const gradient = this.ctx.createLinearGradient(0, 0, this.outputWidth, this.outputHeight);
                    gradient.addColorStop(0, '#667eea');
                    gradient.addColorStop(1, '#764ba2');
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.outputWidth, this.outputHeight);
                }
                
                // Position logo in top-left corner (larger and more visible)
                if (logoImage && logoImage.complete) {
                    // Get logo size from state (with default)
                    const logoScale = getAppState('assets.logoScale') || 1.0;
                    const baseLogoWidth = 400; // Base width for 500×300 aspect ratio
                    const baseLogoHeight = 240; // Base height for 500×300 aspect ratio
                    
                    const logoWidth = baseLogoWidth * logoScale;
                    const logoHeight = baseLogoHeight * logoScale;
                    const logoMargin = 40; // Reduced from 80 to move closer to corner
                    
                    console.log('Layout2 - Logo scale applied:', logoScale, 'Final size:', logoWidth, 'x', logoHeight);
                    this.drawImage(logoImage, logoMargin, logoMargin, logoWidth, logoHeight);
                } else {
                    // Draw placeholder logo (larger)
                    this.drawText('DDAM LOGO', 40, 80, {
                        font: 'bold 64px Roboto',
                        color: 'white'
                    });
                }
                
                // Add copyright text in bottom-left position
                const copyrightText = '©2025 DDAM LLC';
                this.drawText(copyrightText, 40, this.outputHeight - 60, {
                    font: '28px Roboto', // Increased font size for better visibility
                    color: 'rgba(255, 255, 255, 0.8)'
                });
                
                // Implement text positioning options
                this.renderLayout2Text();
            }
            
            renderLayout2Text() {
                const textFields = getAppState('text.fields');
                const typography = getAppState('text.typography');
                const position = getAppState('text.positioning.layout2') || 'top-right';
                
                console.log('Layout2 - Rendering text with position:', position);
                
                if (!textFields || !typography) return;
                
                // Scale up font sizes for better visibility (multiply by 3 for 1920x1080)
                const baseFontSize = typography.fontSize * 3;
                const textColor = typography.textColor === 'white' ? '#ffffff' : '#000000';
                const englishFont = typography.englishFont;
                const japaneseFont = typography.japaneseFont;
                
                // Prepare text lines with larger fonts
                const lines = [
                    { text: textFields.fullName, font: `bold ${baseFontSize}px ${englishFont}` },
                    { text: textFields.nickname, font: `${baseFontSize}px ${japaneseFont}` },
                    { text: textFields.positionEn, font: `${Math.round(baseFontSize * 0.8)}px ${englishFont}` },
                    { text: textFields.positionJp, font: `${Math.round(baseFontSize * 0.8)}px ${japaneseFont}` }
                ];
                
                // Calculate text block dimensions
                let maxWidth = 0;
                let totalHeight = 0;
                const lineHeight = baseFontSize * 1.3;
                
                lines.forEach(line => {
                    const width = this.getTextWidth(line.text, line.font);
                    maxWidth = Math.max(maxWidth, width);
                    totalHeight += lineHeight;
                });
                
                // Calculate position for Layout 2 positioning options
                let textPosition;
                const padding = 60;
                
                console.log('Layout2 - Calculating position for:', position);
                
                switch (position) {
                    case 'top-right':
                        textPosition = {
                            x: this.outputWidth - padding,
                            y: padding + 100, // Closer to top, below logo area
                            align: 'right'
                        };
                        break;
                    case 'top-left':
                        textPosition = {
                            x: padding,
                            y: padding + 100, // Closer to top, below logo area
                            align: 'left'
                        };
                        break;
                    case 'middle':
                        textPosition = {
                            x: this.outputWidth / 2,
                            y: (this.outputHeight - totalHeight) / 2,
                            align: 'center'
                        };
                        break;
                    case 'bottom-left':
                        textPosition = {
                            x: padding,
                            y: this.outputHeight - totalHeight - padding - 100, // Above copyright
                            align: 'left'
                        };
                        break;
                    case 'bottom-right':
                        textPosition = {
                            x: this.outputWidth - padding,
                            y: this.outputHeight - totalHeight - padding - 100, // Above copyright
                            align: 'right'
                        };
                        break;
                    default:
                        textPosition = {
                            x: this.outputWidth - padding,
                            y: padding + 280,
                            align: 'right'
                        };
                }
                
                // Draw text lines with proper alignment
                let currentY = textPosition.y;
                lines.forEach(line => {
                    this.drawText(line.text, textPosition.x, currentY, {
                        font: line.font,
                        color: textColor,
                        align: textPosition.align
                    });
                    currentY += lineHeight;
                });
            }
            
            // Render placeholder content
            renderPlaceholder() {
                this.clear();
                this.drawBackground('#f8f9fa');
                
                // Draw placeholder text
                this.drawText('Preview Loading...', this.outputWidth / 2, this.outputHeight / 2 - 60, {
                    font: '48px Roboto',
                    color: '#6c757d',
                    align: 'center',
                    baseline: 'middle'
                });
                
                this.drawText('Canvas rendering system ready', this.outputWidth / 2, this.outputHeight / 2, {
                    font: '24px Roboto',
                    color: '#6c757d',
                    align: 'center',
                    baseline: 'middle'
                });
                
                // Show current state info
                const currentLayout = getAppState('layout.type');
                const currentName = getAppState('text.fields.fullName');
                
                this.drawText(`Selected Layout: ${currentLayout === 'layout1' ? 'Layout 1' : 'Layout 2'}`, this.outputWidth / 2, this.outputHeight / 2 + 60, {
                    font: '20px Roboto',
                    color: '#667eea',
                    align: 'center',
                    baseline: 'middle'
                });
                
                this.drawText(`User: ${currentName}`, this.outputWidth / 2, this.outputHeight / 2 + 90, {
                    font: '20px Roboto',
                    color: '#6c757d',
                    align: 'center',
                    baseline: 'middle'
                });
            }
        }
        
        // Global canvas renderer instance
        let canvasRenderer = null;
        
        // Asset loading utilities
        const assetCache = new Map();
        
        function loadImage(src) {
            return new Promise((resolve, reject) => {
                if (assetCache.has(src)) {
                    console.log(`Using cached image: ${src}`);
                    resolve(assetCache.get(src));
                    return;
                }
                
                console.log(`Loading image: ${src}`);
                const img = new Image();
                
                // Don't set crossOrigin for local files to avoid CORS issues
                if (!src.startsWith('http')) {
                    // Local file - don't set crossOrigin
                } else {
                    img.crossOrigin = 'anonymous';
                }
                
                img.onload = () => {
                    console.log(`Successfully loaded image: ${src}`, {
                        width: img.width,
                        height: img.height,
                        complete: img.complete
                    });
                    assetCache.set(src, img);
                    resolve(img);
                };
                img.onerror = (error) => {
                    console.error(`Failed to load image: ${src}`, error);
                    resolve(null);
                };
                img.src = src;
            });
        }
        
        // CORS-safe image loading for export
        function loadImageForExport(src) {
            return new Promise((resolve, reject) => {
                if (!src) {
                    console.log('loadImageForExport: No source provided');
                    resolve(null);
                    return;
                }
                
                console.log(`loadImageForExport: Starting load for ${src}`);
                
                // For local files, we can load them directly
                if (!src.startsWith('http')) {
                    const img = new Image();
                    
                    img.onload = () => {
                        console.log(`loadImageForExport: Image loaded successfully ${src} (${img.width}x${img.height})`);
                        
                        // Convert to data URL to avoid CORS issues
                        try {
                            const canvas = document.createElement('canvas');
                            canvas.width = img.width;
                            canvas.height = img.height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0);
                            
                            const dataURL = canvas.toDataURL('image/png');
                            console.log(`loadImageForExport: Converted to data URL, length: ${dataURL.length}`);
                            
                            const exportImg = new Image();
                            exportImg.onload = () => {
                                console.log(`loadImageForExport: Export image ready ${src} (${exportImg.width}x${exportImg.height})`);
                                resolve(exportImg);
                            };
                            exportImg.onerror = (error) => {
                                console.error(`loadImageForExport: Failed to create export image for ${src}:`, error);
                                resolve(null);
                            };
                            exportImg.src = dataURL;
                        } catch (error) {
                            console.error(`loadImageForExport: Failed to convert image to data URL ${src}:`, error);
                            resolve(null);
                        }
                    };
                    
                    img.onerror = (error) => {
                        console.error(`loadImageForExport: Failed to load image ${src}:`, error);
                        resolve(null);
                    };
                    
                    img.src = src;
                } else {
                    // For external URLs, try with CORS
                    console.log(`loadImageForExport: Loading external image ${src}`);
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        console.log(`loadImageForExport: External image loaded ${src}`);
                        try {
                            // Test if we can read the image data
                            const canvas = document.createElement('canvas');
                            canvas.width = img.width;
                            canvas.height = img.height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0);
                            
                            const dataURL = canvas.toDataURL('image/png');
                            const exportImg = new Image();
                            exportImg.onload = () => {
                                console.log(`loadImageForExport: External export image ready ${src}`);
                                resolve(exportImg);
                            };
                            exportImg.src = dataURL;
                        } catch (error) {
                            console.error(`loadImageForExport: CORS issue with external image ${src}:`, error);
                            resolve(null);
                        }
                    };
                    
                    img.onerror = (error) => {
                        console.error(`loadImageForExport: Failed to load external image ${src}:`, error);
                        resolve(null);
                    };
                    
                    img.src = src;
                }
            });
        }
        
        // Real-time Preview Update System
        class PreviewUpdateManager {
            constructor() {
                this.debounceTimer = null;
                this.debounceDelay = 150; // 150ms for smooth performance
                this.isUpdating = false;
                this.pendingUpdate = false;
                
                this.init();
            }
            
            init() {
                // Listen for all state changes that affect preview
                stateEvents.on('stateChange', (data) => {
                    this.handleStateChange(data);
                });
                
                // Add event listeners for all form controls
                this.attachFormListeners();
                
                console.log('Preview update manager initialized');
            }
            
            handleStateChange(data) {
                const { path } = data;
                
                // Check if this state change affects the preview
                const previewAffectingPaths = [
                    'layout.type',
                    'text.fields.',
                    'text.typography.',
                    'text.positioning.',
                    'assets.'
                ];
                
                const shouldUpdate = previewAffectingPaths.some(prefix => path.startsWith(prefix));
                
                if (shouldUpdate) {
                    this.debouncedUpdate();
                }
            }
            
            attachFormListeners() {
                // Layout selection listeners (already handled by LayoutSelector)
                // Text input listeners (already handled by TextInputHandler)
                // Typography listeners (already handled by FontManager)
                
                // Add additional listeners for immediate updates on certain controls
                const immediateUpdateControls = [
                    'japaneseFont',
                    'englishFont',
                    'fontSize',
                    'textColor-white',
                    'textColor-black',
                    'logoScale'
                ];
                
                immediateUpdateControls.forEach(controlId => {
                    const element = document.getElementById(controlId);
                    if (element) {
                        const eventType = element.type === 'range' ? 'input' : 'change';
                        element.addEventListener(eventType, () => {
                            this.debouncedUpdate();
                        });
                    }
                });
                
                // Add listeners for color toggle buttons
                document.querySelectorAll('.color-toggle-btn').forEach(button => {
                    button.addEventListener('click', () => {
                        this.debouncedUpdate();
                    });
                });
                
                // Add listeners for layout cards
                document.querySelectorAll('.layout-card').forEach(card => {
                    card.addEventListener('click', () => {
                        // Layout changes should update immediately for better UX
                        this.immediateUpdate();
                    });
                });
            }
            
            debouncedUpdate() {
                // Clear existing timer
                if (this.debounceTimer) {
                    clearTimeout(this.debounceTimer);
                }
                
                // Set new timer
                this.debounceTimer = setTimeout(() => {
                    this.performUpdate();
                    this.debounceTimer = null;
                }, this.debounceDelay);
            }
            
            immediateUpdate() {
                // Clear any pending debounced update
                if (this.debounceTimer) {
                    clearTimeout(this.debounceTimer);
                    this.debounceTimer = null;
                }
                
                this.performUpdate();
            }
            
            performUpdate() {
                if (this.isUpdating) {
                    this.pendingUpdate = true;
                    return;
                }
                
                this.isUpdating = true;
                
                try {
                    // Add smooth transition effect
                    this.addTransitionEffect();
                    
                    // Perform the actual update
                    updatePreview();
                    
                    // Optimize for mobile devices
                    this.optimizeForMobile();
                    
                } catch (error) {
                    console.error('Error updating preview:', error);
                } finally {
                    this.isUpdating = false;
                    
                    // Handle any pending update
                    if (this.pendingUpdate) {
                        this.pendingUpdate = false;
                        setTimeout(() => this.performUpdate(), 50);
                    }
                }
            }
            
            addTransitionEffect() {
                // Add a subtle fade effect during updates
                const canvas = document.getElementById('preview-canvas');
                if (canvas) {
                    canvas.style.transition = 'opacity 0.1s ease-in-out';
                    canvas.style.opacity = '0.95';
                    
                    setTimeout(() => {
                        canvas.style.opacity = '1';
                    }, 100);
                }
            }
            
            optimizeForMobile() {
                // Reduce update frequency on mobile devices for better performance
                if (window.innerWidth <= 768) {
                    this.debounceDelay = Math.max(200, this.debounceDelay);
                } else {
                    this.debounceDelay = 150;
                }
            }
            
            // Public method to force immediate update
            forceUpdate() {
                this.immediateUpdate();
            }
        }
        
        // Global preview update manager instance
        let previewUpdateManager = null;
        
        // Updated preview function
        async function updatePreview() {
            if (!canvasRenderer) {
                console.warn('Canvas renderer not initialized');
                return;
            }
            
            console.log('Updating preview...');
            
            const currentLayout = getAppState('layout.type');
            
            // Get current assets
            const selectedBackground = getAppState('assets.selectedBackground');
            const selectedLogo = getAppState('assets.selectedLogo');
            const customBackground = getAppState('assets.customBackground');
            
            console.log('Current assets:', {
                selectedBackground,
                selectedLogo,
                customBackground,
                currentLayout
            });
            
            // Load assets
            let backgroundImage = null;
            let logoImage = null;
            
            try {
                // Load background image
                if (customBackground) {
                    console.log('Loading custom background...');
                    backgroundImage = await loadImage(customBackground);
                } else if (selectedBackground) {
                    console.log('Loading selected background...');
                    backgroundImage = await loadImage(selectedBackground);
                }
                
                // Load logo image
                if (selectedLogo) {
                    console.log('Loading selected logo...');
                    logoImage = await loadImage(selectedLogo);
                    console.log('Logo loaded:', logoImage ? 'success' : 'failed');
                }
                
                // Render based on selected layout
                console.log('Rendering layout:', currentLayout, 'with assets:', {
                    hasBackground: !!backgroundImage,
                    hasLogo: !!logoImage
                });
                
                if (currentLayout === 'layout1') {
                    canvasRenderer.renderLayout1(backgroundImage, logoImage);
                } else if (currentLayout === 'layout2') {
                    canvasRenderer.renderLayout2(backgroundImage, logoImage);
                } else {
                    canvasRenderer.renderPlaceholder();
                }
                
            } catch (error) {
                console.error('Error loading assets for preview:', error);
                // Fallback to rendering without assets
                if (currentLayout === 'layout1') {
                    canvasRenderer.renderLayout1(null, null);
                } else if (currentLayout === 'layout2') {
                    canvasRenderer.renderLayout2(null, null);
                } else {
                    canvasRenderer.renderPlaceholder();
                }
            }
        }
        
        // Export System Implementation
        class ExportManager {
            constructor() {
                this.isExporting = false;
                this.exportConfig = {
                    allowTaint: true,
                    useCORS: true,
                    scale: 1,
                    width: 1920,
                    height: 1080,
                    backgroundColor: null,
                    logging: false,
                    removeContainer: false
                };
                
                this.init();
            }
            
            init() {
                // Verify HTML2Canvas is available
                if (typeof html2canvas === 'undefined') {
                    console.error('HTML2Canvas library not loaded');
                    this.showError('Export functionality unavailable - HTML2Canvas library not loaded');
                    return;
                }
                
                console.log('Export manager initialized with HTML2Canvas version:', html2canvas.version || 'unknown');
            }
            
            async exportToPNG() {
                if (this.isExporting) {
                    console.warn('Export already in progress');
                    return null;
                }
                
                this.isExporting = true;
                this.showExportProgress('Preparing export...');
                
                try {
                    // Create a completely new export canvas and render everything fresh
                    const exportCanvas = document.createElement('canvas');
                    exportCanvas.width = 1920;
                    exportCanvas.height = 1080;
                    const exportCtx = exportCanvas.getContext('2d');
                    
                    this.showExportProgress('Loading assets for export...');
                    
                    // Get current state
                    const currentLayout = getAppState('layout.type');
                    const selectedBackground = getAppState('assets.selectedBackground');
                    const selectedLogo = getAppState('assets.selectedLogo');
                    const customBackground = getAppState('assets.customBackground');
                    
                    console.log('Export state:', {
                        layout: currentLayout,
                        selectedBackground: selectedBackground,
                        selectedLogo: selectedLogo,
                        customBackground: customBackground
                    });
                    
                    // Load images as data URLs to avoid CORS taint
                    let backgroundDataURL = null;
                    let logoDataURL = null;
                    
                    // Load background
                    if (customBackground) {
                        console.log('Loading custom background for export');
                        backgroundDataURL = await this.loadImageAsDataURL(customBackground);
                    } else if (selectedBackground) {
                        console.log('Loading selected background for export:', selectedBackground);
                        backgroundDataURL = await this.loadImageAsDataURL(selectedBackground);
                    }
                    
                    // Load logo
                    if (selectedLogo) {
                        console.log('Loading selected logo for export:', selectedLogo);
                        logoDataURL = await this.loadImageAsDataURL(selectedLogo);
                    } else {
                        // Use default logo
                        logoDataURL = await this.loadImageAsDataURL('logo/no-bg-logo-1.png');
                    }
                    
                    this.showExportProgress('Rendering export...');
                    
                    // Render with the loaded data URLs
                    if (currentLayout === 'layout1') {
                        await this.renderLayout1ExportWithAssets(exportCtx, exportCanvas.width, exportCanvas.height, backgroundDataURL, logoDataURL);
                    } else if (currentLayout === 'layout2') {
                        await this.renderLayout2ExportWithAssets(exportCtx, exportCanvas.width, exportCanvas.height, backgroundDataURL, logoDataURL);
                    } else {
                        await this.renderLayout1ExportWithAssets(exportCtx, exportCanvas.width, exportCanvas.height, backgroundDataURL, logoDataURL);
                    }
                    
                    // Convert export canvas to blob
                    const quality = getAppState('export.quality') || 1.0;
                    
                    console.log('Converting export canvas to blob with quality:', quality);
                    
                    return new Promise((resolve, reject) => {
                        try {
                            exportCanvas.toBlob((blob) => {
                                if (blob) {
                                    console.log('Export blob generated successfully:', {
                                        size: blob.size,
                                        type: blob.type,
                                        dimensions: `${exportCanvas.width}x${exportCanvas.height}`,
                                        sizeKB: Math.round(blob.size / 1024)
                                    });
                                    
                                    resolve(blob);
                                } else {
                                    console.error('Export canvas.toBlob returned null');
                                    reject(new Error('Failed to generate PNG blob from export canvas'));
                                }
                            }, 'image/png', quality);
                        } catch (error) {
                            console.error('Error in export canvas.toBlob:', error);
                            reject(error);
                        }
                    });
                    
                } catch (error) {
                    console.error('Export failed:', error);
                    this.showError(`Export failed: ${error.message}`);
                    throw error;
                } finally {
                    this.isExporting = false;
                    this.hideExportProgress();
                }
            }
            
            async loadImageAsDataURL(imagePath) {
                return new Promise((resolve) => {
                    try {
                        console.log('Loading image as data URL:', imagePath);
                        
                        // If it's already a data URL, return it
                        if (imagePath.startsWith('data:')) {
                            console.log('Image is already a data URL');
                            const img = new Image();
                            img.onload = () => resolve(img);
                            img.onerror = () => resolve(null);
                            img.src = imagePath;
                            return;
                        }
                        
                        // Load the image first
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        
                        img.onload = () => {
                            try {
                                console.log('Image loaded, converting to data URL');
                                
                                // Create a canvas to convert the image
                                const canvas = document.createElement('canvas');
                                canvas.width = img.width;
                                canvas.height = img.height;
                                const ctx = canvas.getContext('2d');
                                
                                // Draw the image to the canvas
                                ctx.drawImage(img, 0, 0);
                                
                                // Convert to data URL
                                const dataURL = canvas.toDataURL('image/png');
                                
                                // Create a new image from the data URL
                                const dataImg = new Image();
                                dataImg.onload = () => {
                                    console.log('Data URL image created successfully');
                                    resolve(dataImg);
                                };
                                dataImg.onerror = () => {
                                    console.error('Failed to create data URL image');
                                    resolve(null);
                                };
                                dataImg.src = dataURL;
                                
                            } catch (error) {
                                console.error('Error converting image to data URL:', error);
                                resolve(null);
                            }
                        };
                        
                        img.onerror = () => {
                            console.error('Failed to load image:', imagePath);
                            resolve(null);
                        };
                        
                        img.src = imagePath;
                        
                    } catch (error) {
                        console.error('Error in loadImageAsDataURL:', error);
                        resolve(null);
                    }
                });
            }

            async renderLayout1ExportWithAssets(ctx, width, height, backgroundDataURL, logoDataURL) {
                console.log('Rendering Layout 1 for export with assets');
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Draw background
                if (backgroundDataURL) {
                    console.log('Drawing background image from data URL');
                    ctx.drawImage(backgroundDataURL, 0, 0, width, height);
                } else {
                    console.log('Drawing gradient background');
                    const gradient = ctx.createLinearGradient(0, 0, width, height);
                    gradient.addColorStop(0, '#667eea');
                    gradient.addColorStop(1, '#764ba2');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, width, height);
                }
                
                // Draw frame
                const frameMargin = 20;
                const frameRadius = 20;
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.roundRect(frameMargin, frameMargin, width - (frameMargin * 2), height - (frameMargin * 2), frameRadius);
                ctx.stroke();
                
                // Draw overlay with dynamic settings
                const overlaySize = getAppState('layout.overlay.size') || 40; // Percentage of width
                const overlayOpacity = getAppState('layout.overlay.opacity') || 80; // Percentage opacity
                
                const overlayWidthPercent = overlaySize / 100; // Convert to decimal
                const overlayOpacityDecimal = overlayOpacity / 100; // Convert to decimal
                
                const overlayStartX = width * (1 - overlayWidthPercent); // Start position
                const overlayWidth = width * overlayWidthPercent; // Width of overlay
                
                ctx.fillStyle = `rgba(0, 0, 0, ${overlayOpacityDecimal})`;
                ctx.fillRect(overlayStartX, frameMargin, overlayWidth - frameMargin, height - (frameMargin * 2));
                
                // Draw logo
                if (logoDataURL) {
                    console.log('Drawing logo image from data URL');
                    const logoScale = getAppState('assets.logoScale') || 1.0;
                    const baseLogoWidth = 400;
                    const baseLogoHeight = 240;
                    const logoWidth = baseLogoWidth * logoScale;
                    const logoHeight = baseLogoHeight * logoScale;
                    const logoMargin = 40;
                    
                    ctx.drawImage(logoDataURL, logoMargin, logoMargin, logoWidth, logoHeight);
                } else {
                    console.log('Drawing text-based logo');
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 64px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText('DDAM', 40, 120);
                    ctx.font = '32px Arial';
                    ctx.fillText('Digital Design & Marketing', 40, 160);
                }
                
                // Draw copyright
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '28px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('©2025 DDAM LLC', 40, height - 40);
                
                // Draw user text
                this.drawUserText(ctx, width, height, 'layout1');
                
                console.log('Layout 1 export render complete');
            }

            async renderLayout2ExportWithAssets(ctx, width, height, backgroundDataURL, logoDataURL) {
                console.log('Rendering Layout 2 for export with assets');
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Draw background
                if (backgroundDataURL) {
                    console.log('Drawing background image from data URL');
                    ctx.drawImage(backgroundDataURL, 0, 0, width, height);
                } else {
                    console.log('Drawing gradient background');
                    const gradient = ctx.createLinearGradient(0, 0, width, height);
                    gradient.addColorStop(0, '#667eea');
                    gradient.addColorStop(1, '#764ba2');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, width, height);
                }
                
                // Draw logo
                if (logoDataURL) {
                    console.log('Drawing logo image from data URL');
                    const logoScale = getAppState('assets.logoScale') || 1.0;
                    const baseLogoWidth = 400;
                    const baseLogoHeight = 240;
                    const logoWidth = baseLogoWidth * logoScale;
                    const logoHeight = baseLogoHeight * logoScale;
                    const logoMargin = 40;
                    
                    ctx.drawImage(logoDataURL, logoMargin, logoMargin, logoWidth, logoHeight);
                } else {
                    console.log('Drawing text-based logo');
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 64px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText('DDAM', 40, 120);
                    ctx.font = '32px Arial';
                    ctx.fillText('Digital Design & Marketing', 40, 160);
                }
                
                // Draw copyright
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '28px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('©2025 DDAM LLC', 40, height - 40);
                
                // Draw user text
                this.drawUserText(ctx, width, height, 'layout2');
                
                console.log('Layout 2 export render complete');
            }

            async renderLayout1ExportClean(ctx, width, height) {
                console.log('Rendering Layout 1 for export (CORS-free)');
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Always draw gradient background to avoid CORS issues
                console.log('Drawing gradient background');
                const gradient = ctx.createLinearGradient(0, 0, width, height);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                
                // Draw frame
                const frameMargin = 20;
                const frameRadius = 20;
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.roundRect(frameMargin, frameMargin, width - (frameMargin * 2), height - (frameMargin * 2), frameRadius);
                ctx.stroke();
                
                // Draw overlay with dynamic settings
                const overlaySize = getAppState('layout.overlay.size') || 40; // Percentage of width
                const overlayOpacity = getAppState('layout.overlay.opacity') || 80; // Percentage opacity
                
                const overlayWidthPercent = overlaySize / 100; // Convert to decimal
                const overlayOpacityDecimal = overlayOpacity / 100; // Convert to decimal
                
                const overlayStartX = width * (1 - overlayWidthPercent); // Start position
                const overlayWidth = width * overlayWidthPercent; // Width of overlay
                
                ctx.fillStyle = `rgba(0, 0, 0, ${overlayOpacityDecimal})`;
                ctx.fillRect(overlayStartX, frameMargin, overlayWidth - frameMargin, height - (frameMargin * 2));
                
                // Draw text-based logo to avoid CORS issues
                console.log('Drawing text-based logo');
                ctx.fillStyle = 'white';
                ctx.font = 'bold 64px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('DDAM', 40, 120);
                ctx.font = '32px Arial';
                ctx.fillText('Digital Design & Marketing', 40, 160);
                
                // Draw copyright
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '28px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('©2025 DDAM LLC', 40, height - 40);
                
                // Draw user text
                this.drawUserText(ctx, width, height, 'layout1');
                
                console.log('Layout 1 export render complete');
            }

            async renderLayout1Export(ctx, width, height, backgroundImage, logoImage) {
                console.log('Rendering Layout 1 for export');
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Draw background
                if (backgroundImage && backgroundImage.complete) {
                    console.log('Drawing background image');
                    ctx.drawImage(backgroundImage, 0, 0, width, height);
                } else {
                    console.log('Drawing gradient background');
                    const gradient = ctx.createLinearGradient(0, 0, width, height);
                    gradient.addColorStop(0, '#667eea');
                    gradient.addColorStop(1, '#764ba2');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, width, height);
                }
                
                // Draw frame
                const frameMargin = 20;
                const frameRadius = 20;
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.roundRect(frameMargin, frameMargin, width - (frameMargin * 2), height - (frameMargin * 2), frameRadius);
                ctx.stroke();
                
                // Draw overlay with dynamic settings
                const overlaySize = getAppState('layout.overlay.size') || 40; // Percentage of width
                const overlayOpacity = getAppState('layout.overlay.opacity') || 80; // Percentage opacity
                
                const overlayWidthPercent = overlaySize / 100; // Convert to decimal
                const overlayOpacityDecimal = overlayOpacity / 100; // Convert to decimal
                
                const overlayStartX = width * (1 - overlayWidthPercent); // Start position
                const overlayWidth = width * overlayWidthPercent; // Width of overlay
                
                ctx.fillStyle = `rgba(0, 0, 0, ${overlayOpacityDecimal})`;
                ctx.fillRect(overlayStartX, frameMargin, overlayWidth - frameMargin, height - (frameMargin * 2));
                
                // Draw logo
                if (logoImage && logoImage.complete) {
                    console.log('Drawing logo image');
                    const logoScale = getAppState('assets.logoScale') || 1.0;
                    const baseLogoWidth = 400;
                    const baseLogoHeight = 240;
                    const logoWidth = baseLogoWidth * logoScale;
                    const logoHeight = baseLogoHeight * logoScale;
                    const logoMargin = 40;
                    
                    ctx.drawImage(logoImage, logoMargin, logoMargin, logoWidth, logoHeight);
                } else {
                    console.log('Drawing placeholder logo');
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 64px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText('DDAM LOGO', 40, 120);
                }
                
                // Draw copyright
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '28px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('©2025 DDAM LLC', 40, height - 40);
                
                // Draw user text
                this.drawUserText(ctx, width, height, 'layout1');
                
                console.log('Layout 1 export render complete');
            }
            


            async renderLayout2Export(ctx, width, height, backgroundImage, logoImage) {
                console.log('Rendering Layout 2 for export');
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Draw background
                if (backgroundImage && backgroundImage.complete) {
                    console.log('Drawing background image');
                    ctx.drawImage(backgroundImage, 0, 0, width, height);
                } else {
                    console.log('Drawing gradient background');
                    const gradient = ctx.createLinearGradient(0, 0, width, height);
                    gradient.addColorStop(0, '#667eea');
                    gradient.addColorStop(1, '#764ba2');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, width, height);
                }
                
                // Draw logo
                if (logoImage && logoImage.complete) {
                    console.log('Drawing logo image');
                    const logoScale = getAppState('assets.logoScale') || 1.0;
                    const baseLogoWidth = 400;
                    const baseLogoHeight = 240;
                    const logoWidth = baseLogoWidth * logoScale;
                    const logoHeight = baseLogoHeight * logoScale;
                    const logoMargin = 40;
                    
                    ctx.drawImage(logoImage, logoMargin, logoMargin, logoWidth, logoHeight);
                } else {
                    console.log('Drawing placeholder logo');
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 64px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText('DDAM LOGO', 40, 120);
                }
                
                // Draw copyright
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '28px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('©2025 DDAM LLC', 40, height - 40);
                
                // Draw user text
                this.drawUserText(ctx, width, height, 'layout2');
                
                console.log('Layout 2 export render complete');
            }
            
            drawUserText(ctx, width, height, layout) {
                const textFields = getAppState('text.fields');
                const typography = getAppState('text.typography');
                const position = getAppState(`text.positioning.${layout}`) || 'top-right';
                
                if (!textFields || !typography) return;
                
                const baseFontSize = typography.fontSize * 3;
                const textColor = typography.textColor === 'white' ? '#ffffff' : '#000000';
                
                const lines = [
                    { text: textFields.fullName, font: `bold ${baseFontSize}px Arial` },
                    { text: textFields.nickname, font: `${baseFontSize}px Arial` },
                    { text: textFields.positionEn, font: `${Math.round(baseFontSize * 0.8)}px Arial` },
                    { text: textFields.positionJp, font: `${Math.round(baseFontSize * 0.8)}px Arial` }
                ];
                
                // Calculate position
                let textX, textAlign;
                const textY = 180;
                const lineHeight = baseFontSize * 1.3;
                
                switch (position) {
                    case 'top-right':
                        textX = width - 60;
                        textAlign = 'right';
                        break;
                    case 'middle':
                        textX = width / 2;
                        textAlign = 'center';
                        break;
                    case 'bottom-left':
                        textX = 60;
                        textAlign = 'left';
                        break;
                    default:
                        textX = width - 60;
                        textAlign = 'right';
                }
                
                // Draw text lines
                ctx.fillStyle = textColor;
                ctx.textAlign = textAlign;
                
                let currentY = textY;
                lines.forEach(line => {
                    ctx.font = line.font;
                    ctx.fillText(line.text, textX, currentY);
                    currentY += lineHeight;
                });
            }
            
            async convertToDataURL(img) {
                return new Promise((resolve) => {
                    try {
                        if (!img || !img.complete) {
                            console.log('convertToDataURL: Invalid or incomplete image');
                            resolve(null);
                            return;
                        }
                        
                        console.log('convertToDataURL: Converting image to data URL');
                        
                        // Create a temporary canvas to convert the image
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = img.width;
                        tempCanvas.height = img.height;
                        const tempCtx = tempCanvas.getContext('2d');
                        
                        // Draw the image to the temporary canvas
                        tempCtx.drawImage(img, 0, 0);
                        
                        // Convert to data URL
                        const dataURL = tempCanvas.toDataURL('image/png');
                        
                        // Create a new image from the data URL
                        const cleanImg = new Image();
                        cleanImg.onload = () => {
                            console.log('convertToDataURL: Clean image created successfully');
                            resolve(cleanImg);
                        };
                        cleanImg.onerror = () => {
                            console.error('convertToDataURL: Failed to create clean image');
                            resolve(null);
                        };
                        cleanImg.src = dataURL;
                        
                    } catch (error) {
                        console.error('convertToDataURL: Error during conversion:', error);
                        resolve(null);
                    }
                });
            }
            
            async convertImageForExport(img) {
                return new Promise((resolve) => {
                    try {
                        if (!img || !img.complete) {
                            console.log('convertImageForExport: Invalid or incomplete image');
                            resolve(null);
                            return;
                        }
                        
                        console.log('convertImageForExport: Converting image', img.width, 'x', img.height);
                        
                        // Create a canvas to convert the image
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        
                        // Draw the image to the canvas
                        ctx.drawImage(img, 0, 0);
                        
                        // Convert to data URL
                        const dataURL = canvas.toDataURL('image/png');
                        
                        // Create a new image from the data URL
                        const exportImg = new Image();
                        exportImg.onload = () => {
                            console.log('convertImageForExport: Conversion successful');
                            resolve(exportImg);
                        };
                        exportImg.onerror = () => {
                            console.error('convertImageForExport: Failed to create export image');
                            resolve(null);
                        };
                        exportImg.src = dataURL;
                        
                    } catch (error) {
                        console.error('convertImageForExport: Error during conversion:', error);
                        resolve(null);
                    }
                });
            }
            
            async renderCleanExport(ctx, width, height) {
                console.log('Rendering export with CORS-safe images...');
                
                const currentLayout = getAppState('layout.type');
                const textFields = getAppState('text.fields');
                const typography = getAppState('text.typography');
                
                // Get current assets
                const selectedBackground = getAppState('assets.selectedBackground');
                const selectedLogo = getAppState('assets.selectedLogo');
                const customBackground = getAppState('assets.customBackground');
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Load images for export (CORS-safe)
                let backgroundImage = null;
                let logoImage = null;
                
                console.log('Export assets to load:', {
                    selectedLogo: selectedLogo,
                    selectedBackground: selectedBackground,
                    customBackground: customBackground
                });
                
                try {
                    // Use the existing loadImage function and then convert for export
                    if (customBackground) {
                        console.log('Loading custom background for export:', customBackground);
                        const bgImg = await loadImage(customBackground);
                        if (bgImg) {
                            backgroundImage = await this.convertImageForExport(bgImg);
                        }
                        console.log('Custom background loaded:', !!backgroundImage);
                    } else if (selectedBackground) {
                        console.log('Loading selected background for export:', selectedBackground);
                        const bgImg = await loadImage(selectedBackground);
                        if (bgImg) {
                            backgroundImage = await this.convertImageForExport(bgImg);
                        }
                        console.log('Selected background loaded:', !!backgroundImage);
                    }
                    
                    // Load logo image
                    if (selectedLogo) {
                        console.log('Loading logo for export:', selectedLogo);
                        const logoImg = await loadImage(selectedLogo);
                        if (logoImg) {
                            logoImage = await this.convertImageForExport(logoImg);
                        }
                        console.log('Logo loaded:', !!logoImage);
                        if (logoImage) {
                            console.log('Logo dimensions:', logoImage.width, 'x', logoImage.height);
                        }
                    }
                } catch (error) {
                    console.error('Error loading images for export:', error);
                }
                
                console.log('Final loaded assets:', {
                    hasBackground: !!backgroundImage,
                    hasLogo: !!logoImage
                });
                
                // Draw background
                if (backgroundImage && backgroundImage.complete) {
                    console.log('Drawing background image in export');
                    console.log('Background draw parameters:', {
                        x: 0,
                        y: 0,
                        width: width,
                        height: height,
                        imageSize: `${backgroundImage.width}x${backgroundImage.height}`
                    });
                    ctx.drawImage(backgroundImage, 0, 0, width, height);
                    console.log('Background drawn successfully');
                } else {
                    console.log('Drawing gradient background in export - backgroundImage:', !!backgroundImage, 'complete:', backgroundImage ? backgroundImage.complete : 'N/A');
                    // Fallback gradient background
                    const gradient = ctx.createLinearGradient(0, 0, width, height);
                    gradient.addColorStop(0, '#667eea');
                    gradient.addColorStop(1, '#764ba2');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, width, height);
                }
                
                // Draw layout-specific elements
                if (currentLayout === 'layout1') {
                    // Draw Layout 1 frame
                    const frameMargin = 20;
                    const frameRadius = 20;
                    
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.roundRect(frameMargin, frameMargin, width - (frameMargin * 2), height - (frameMargin * 2), frameRadius);
                    ctx.stroke();
                    
                    // Draw overlay with dynamic settings
                    const overlaySize = getAppState('layout.overlay.size') || 40; // Percentage of width
                    const overlayOpacity = getAppState('layout.overlay.opacity') || 80; // Percentage opacity
                    
                    const overlayWidthPercent = overlaySize / 100; // Convert to decimal
                    const overlayOpacityDecimal = overlayOpacity / 100; // Convert to decimal
                    
                    const overlayStartX = width * (1 - overlayWidthPercent); // Start position
                    const overlayWidth = width * overlayWidthPercent; // Width of overlay
                    
                    ctx.fillStyle = `rgba(0, 0, 0, ${overlayOpacityDecimal})`;
                    ctx.fillRect(overlayStartX, frameMargin, overlayWidth - frameMargin, height - (frameMargin * 2));
                }
                
                // Draw logo
                if (logoImage && logoImage.complete) {
                    console.log('Drawing logo image in export');
                    const logoScale = getAppState('assets.logoScale') || 1.0;
                    const baseLogoWidth = 400;
                    const baseLogoHeight = 240;
                    const logoWidth = baseLogoWidth * logoScale;
                    const logoHeight = baseLogoHeight * logoScale;
                    const logoMargin = 40;
                    
                    console.log('Logo draw parameters:', {
                        x: logoMargin,
                        y: logoMargin,
                        width: logoWidth,
                        height: logoHeight,
                        scale: logoScale,
                        imageSize: `${logoImage.width}x${logoImage.height}`
                    });
                    
                    ctx.drawImage(logoImage, logoMargin, logoMargin, logoWidth, logoHeight);
                    console.log('Logo drawn successfully');
                } else {
                    console.log('Drawing placeholder logo text in export - logoImage:', !!logoImage, 'complete:', logoImage ? logoImage.complete : 'N/A');
                    // Fallback logo text
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 64px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText('DDAM LOGO', 40, 120);
                }
                
                // Draw copyright
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '28px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('©2025 DDAM LLC', 40, height - 40);
                
                // Draw user text
                if (textFields && typography) {
                    const baseFontSize = typography.fontSize * 3;
                    const textColor = typography.textColor === 'white' ? '#ffffff' : '#000000';
                    const position = getAppState(`text.positioning.${currentLayout}`) || 'top-right';
                    
                    const lines = [
                        { text: textFields.fullName, font: `bold ${baseFontSize}px Arial` },
                        { text: textFields.nickname, font: `${baseFontSize}px Arial` },
                        { text: textFields.positionEn, font: `${Math.round(baseFontSize * 0.8)}px Arial` },
                        { text: textFields.positionJp, font: `${Math.round(baseFontSize * 0.8)}px Arial` }
                    ];
                    
                    // Calculate position
                    let textX, textAlign;
                    const textY = 180;
                    const lineHeight = baseFontSize * 1.3;
                    
                    switch (position) {
                        case 'top-right':
                            textX = width - 60;
                            textAlign = 'right';
                            break;
                        case 'middle':
                            textX = width / 2;
                            textAlign = 'center';
                            break;
                        case 'bottom-left':
                            textX = 60;
                            textAlign = 'left';
                            break;
                        default:
                            textX = width - 60;
                            textAlign = 'right';
                    }
                    
                    // Draw text lines
                    ctx.fillStyle = textColor;
                    ctx.textAlign = textAlign;
                    
                    let currentY = textY;
                    lines.forEach(line => {
                        ctx.font = line.font;
                        ctx.fillText(line.text, textX, currentY);
                        currentY += lineHeight;
                    });
                }
                
                console.log('Export render completed with images');
            }
            
            generateFilename() {
                try {
                    const fullName = getAppState('text.fields.fullName') || 'DDAM_Background';
                    const timestamp = new Date().toISOString().slice(0, 10); // YYYY-MM-DD format
                    
                    // Sanitize filename - remove invalid characters
                    const sanitizedName = fullName
                        .replace(/[<>:"/\\|?*]/g, '') // Remove invalid filename characters
                        .replace(/\s+/g, '_') // Replace spaces with underscores
                        .trim();
                    
                    const filename = `${sanitizedName}_DDAM_Background_${timestamp}.png`;
                    
                    // Update state with generated filename
                    updateAppState('export.filename', filename);
                    
                    console.log('Generated filename:', filename);
                    return filename;
                    
                } catch (error) {
                    console.error('Failed to generate filename:', error);
                    return `DDAM_Background_${Date.now()}.png`;
                }
            }
            
            async downloadPNG(blob, filename) {
                try {
                    // Create download link
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    
                    // Trigger download
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    // Clean up object URL
                    setTimeout(() => URL.revokeObjectURL(url), 100);
                    
                    this.showExportSuccess(`Successfully exported: ${filename}`);
                    
                    console.log('Download triggered for:', filename);
                    return true;
                    
                } catch (error) {
                    console.error('Download failed:', error);
                    this.showError(`Download failed: ${error.message}`);
                    return false;
                }
            }
            
            async exportAndDownload() {
                try {
                    // Generate filename
                    const filename = this.generateFilename();
                    
                    // Export to PNG
                    const blob = await this.exportToPNG();
                    if (!blob) {
                        throw new Error('Failed to generate PNG');
                    }
                    
                    // Download the file
                    const success = await this.downloadPNG(blob, filename);
                    
                    return success;
                    
                } catch (error) {
                    console.error('Export and download failed:', error);
                    this.showError(`Export failed: ${error.message}`);
                    return false;
                }
            }
            
            showExportProgress(message) {
                // Create or update progress indicator
                let progressElement = document.getElementById('export-progress');
                if (!progressElement) {
                    progressElement = document.createElement('div');
                    progressElement.id = 'export-progress';
                    progressElement.className = 'export-progress';
                    progressElement.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: rgba(0, 0, 0, 0.8);
                        color: white;
                        padding: 1rem 2rem;
                        border-radius: 8px;
                        z-index: 10000;
                        font-size: 1rem;
                        text-align: center;
                        backdrop-filter: blur(4px);
                    `;
                    document.body.appendChild(progressElement);
                }
                
                progressElement.innerHTML = `
                    <div style="margin-bottom: 0.5rem;">
                        <div style="display: inline-block; width: 20px; height: 20px; border: 2px solid #ffffff; border-top: 2px solid transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                    </div>
                    <div>${message}</div>
                `;
                
                // Add CSS animation if not already present
                if (!document.getElementById('export-spinner-style')) {
                    const style = document.createElement('style');
                    style.id = 'export-spinner-style';
                    style.textContent = `
                        @keyframes spin {
                            0% { transform: rotate(0deg); }
                            100% { transform: rotate(360deg); }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                progressElement.style.display = 'block';
            }
            
            hideExportProgress() {
                const progressElement = document.getElementById('export-progress');
                if (progressElement) {
                    progressElement.style.display = 'none';
                }
            }
            
            showExportSuccess(message) {
                this.showNotification(message, 'success');
            }
            
            showError(message) {
                this.showNotification(message, 'error');
            }
            
            showNotification(message, type = 'info') {
                // Create notification element
                const notification = document.createElement('div');
                notification.className = `export-notification export-notification-${type}`;
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 1rem 1.5rem;
                    border-radius: 8px;
                    z-index: 10001;
                    font-size: 0.9rem;
                    max-width: 400px;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                    animation: slideInRight 0.3s ease-out;
                `;
                
                // Set colors based on type
                if (type === 'success') {
                    notification.style.background = '#d4edda';
                    notification.style.color = '#155724';
                    notification.style.border = '1px solid #c3e6cb';
                } else if (type === 'error') {
                    notification.style.background = '#f8d7da';
                    notification.style.color = '#721c24';
                    notification.style.border = '1px solid #f5c6cb';
                } else {
                    notification.style.background = '#d1ecf1';
                    notification.style.color = '#0c5460';
                    notification.style.border = '1px solid #bee5eb';
                }
                
                notification.textContent = message;
                
                // Add CSS animation if not already present
                if (!document.getElementById('notification-animation-style')) {
                    const style = document.createElement('style');
                    style.id = 'notification-animation-style';
                    style.textContent = `
                        @keyframes slideInRight {
                            from {
                                transform: translateX(100%);
                                opacity: 0;
                            }
                            to {
                                transform: translateX(0);
                                opacity: 1;
                            }
                        }
                        @keyframes slideOutRight {
                            from {
                                transform: translateX(0);
                                opacity: 1;
                            }
                            to {
                                transform: translateX(100%);
                                opacity: 0;
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                document.body.appendChild(notification);
                
                // Auto-remove after 5 seconds
                setTimeout(() => {
                    notification.style.animation = 'slideOutRight 0.3s ease-in';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }, 5000);
            }
            
            // Public method to check if export is in progress
            isExportInProgress() {
                return this.isExporting;
            }
            
            // Public method to update export configuration
            updateConfig(newConfig) {
                this.exportConfig = { ...this.exportConfig, ...newConfig };
                console.log('Export config updated:', this.exportConfig);
            }
        }
        
        // Global export manager instance
        let exportManager = null;
        
        // Updated export function for backward compatibility
        async function exportBackground() {
            if (!exportManager) {
                console.error('Export manager not initialized');
                return false;
            }
            
            return await exportManager.exportAndDownload();
        }
        
        // Debug function to test canvas content
        function debugCanvas() {
            const canvas = document.getElementById('preview-canvas');
            if (!canvas) {
                console.error('Canvas not found');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            
            console.log('Canvas Debug Info:', {
                element: canvas,
                width: canvas.width,
                height: canvas.height,
                offsetWidth: canvas.offsetWidth,
                offsetHeight: canvas.offsetHeight,
                context: ctx,
                canvasRenderer: canvasRenderer,
                appState: getAppState()
            });
            
            // Test drawing something simple (avoid getImageData due to CORS taint)
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(100, 100, 200, 200);
            console.log('Drew red test rectangle at (100,100) 200x200');
            
            return {
                canvas: canvas,
                canvasRenderer: canvasRenderer
            };
        }
        
        // Debug function to force render and export
        async function debugExport() {
            console.log('=== DEBUG EXPORT START ===');
            
            // Force update preview
            console.log('Forcing preview update...');
            await updatePreview();
            
            // Wait a bit
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Check canvas content
            const debugInfo = debugCanvas();
            
            if (!debugInfo.hasContent) {
                console.log('Canvas is empty, forcing manual render...');
                if (canvasRenderer) {
                    canvasRenderer.renderLayout1(null, null);
                }
            }
            
            // Try export
            console.log('Attempting export...');
            const result = await exportBackground();
            
            console.log('=== DEBUG EXPORT END ===');
            return result;
        }
        
        // Initialize export controls
        function initializeExportControls() {
            // Get export control elements
            const exportBtn = document.getElementById('export-btn');
            const exportBtnText = document.getElementById('export-btn-text');
            const exportFilename = document.getElementById('export-filename');
            const exportQuality = document.getElementById('export-quality');
            const exportQualityValue = document.getElementById('export-quality-value');
            const exportInfo = document.getElementById('export-info');
            
            if (!exportBtn || !exportFilename || !exportQuality || !exportQualityValue) {
                console.error('Export control elements not found');
                return;
            }
            
            // Initialize filename display
            function updateFilenameDisplay() {
                if (exportManager) {
                    const filename = exportManager.generateFilename();
                    exportFilename.value = filename;
                }
            }
            
            // Initialize quality display
            function updateQualityDisplay() {
                const quality = parseFloat(exportQuality.value);
                const percentage = Math.round(quality * 100);
                exportQualityValue.textContent = percentage + '%';
                
                // Update state
                updateAppState('export.quality', quality);
            }
            
            // Set up event listeners
            exportBtn.addEventListener('click', async () => {
                if (exportManager && !exportManager.isExportInProgress()) {
                    // Update button state
                    exportBtn.disabled = true;
                    exportBtnText.textContent = 'Exporting...';
                    
                    try {
                        const success = await exportManager.exportAndDownload();
                        
                        if (success) {
                            exportBtnText.textContent = 'Export Successful!';
                            exportInfo.textContent = 'Download started • Check your downloads folder';
                            exportInfo.className = exportInfo.className.replace(/\b(success|error)\b/g, '') + ' success';
                            
                            // Reset button after 3 seconds
                            setTimeout(() => {
                                exportBtnText.textContent = 'Export Background (1920×1080)';
                                exportInfo.textContent = 'High-quality PNG format • Ready for video conferencing';
                                exportInfo.className = exportInfo.className.replace(/\b(success|error)\b/g, '');
                            }, 3000);
                        } else {
                            exportBtnText.textContent = 'Export Failed';
                            exportInfo.textContent = 'Export failed • Please try again';
                            exportInfo.className = exportInfo.className.replace(/\b(success|error)\b/g, '') + ' error';
                            
                            // Reset button after 3 seconds
                            setTimeout(() => {
                                exportBtnText.textContent = 'Export Background (1920×1080)';
                                exportInfo.textContent = 'High-quality PNG format • Ready for video conferencing';
                                exportInfo.className = exportInfo.className.replace(/\b(success|error)\b/g, '');
                            }, 3000);
                        }
                    } catch (error) {
                        console.error('Export error:', error);
                        exportBtnText.textContent = 'Export Failed';
                        exportInfo.textContent = 'Export failed • Please try again';
                        exportInfo.className = exportInfo.className.replace(/\b(success|error)\b/g, '') + ' error';
                        
                        // Reset button after 3 seconds
                        setTimeout(() => {
                            exportBtnText.textContent = 'Export Background (1920×1080)';
                            exportInfo.textContent = 'High-quality PNG format • Ready for video conferencing';
                            exportInfo.className = exportInfo.className.replace(/\b(success|error)\b/g, '');
                        }, 3000);
                    } finally {
                        exportBtn.disabled = false;
                    }
                }
            });
            
            exportQuality.addEventListener('input', updateQualityDisplay);
            
            // Listen for text field changes to update filename
            stateEvents.on('stateChange:text.fields.fullName', updateFilenameDisplay);
            
            // Initialize displays
            updateFilenameDisplay();
            updateQualityDisplay();
            
            console.log('Export controls initialized');
        }
    </script>
</body>
</html>