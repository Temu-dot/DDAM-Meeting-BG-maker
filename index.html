<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DDAM Meeting Background Generator</title>

    <!-- Google Fonts API Links -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&family=Roboto:wght@400;500;700&family=Open+Sans:wght@400;600&family=Lato:wght@400;700&family=Montserrat:wght@400;600&family=Aoboshi+One&family=Kaisei+Decol:wght@400;500;700&display=swap"
      rel="stylesheet"
    />

    <!-- HTML2Canvas CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
      /* CSS Reset and Base Styles */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      /* CSS Custom Properties for Theming */
      :root {
        /* Light Theme Colors */
        --bg-primary: #f5f5f5;
        --bg-secondary: #ffffff;
        --bg-tertiary: #f8f9fa;
        --text-primary: #333333;
        --text-secondary: #495057;
        --text-muted: #6c757d;
        --border-color: #e9ecef;
        --border-color-focus: #667eea;
        --shadow-light: rgba(0, 0, 0, 0.1);
        --shadow-medium: rgba(0, 0, 0, 0.15);
        --accent-primary: #667eea;
        --accent-secondary: #764ba2;
        --success-bg: #d4edda;
        --success-text: #155724;
        --error-bg: #f8d7da;
        --error-text: #721c24;
        --warning-bg: #fff3cd;
        --warning-text: #856404;
      }

      /* Dark Theme Colors */
      [data-theme="dark"] {
        --bg-primary: #1a1a1a;
        --bg-secondary: #2d2d2d;
        --bg-tertiary: #3a3a3a;
        --text-primary: #ffffff;
        --text-secondary: #e0e0e0;
        --text-muted: #b0b0b0;
        --border-color: #404040;
        --border-color-focus: #667eea;
        --shadow-light: rgba(0, 0, 0, 0.3);
        --shadow-medium: rgba(0, 0, 0, 0.4);
        --accent-primary: #667eea;
        --accent-secondary: #764ba2;
        --success-bg: #1e4620;
        --success-text: #4caf50;
        --error-bg: #4a1e1e;
        --error-text: #f44336;
        --warning-bg: #4a3c1e;
        --warning-text: #ff9800;
      }

      body {
        font-family: "Roboto", sans-serif;
        line-height: 1.6;
        color: var(--text-primary);
        background-color: var(--bg-primary);
        transition: background-color 0.3s ease, color 0.3s ease;
      }

      /* Mobile-First Responsive Layout */
      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 1rem;
      }

      .header {
        position: relative;
        text-align: center;
        margin-bottom: 2rem;
        padding: 1rem;
        background: linear-gradient(
          135deg,
          var(--accent-primary) 0%,
          var(--accent-secondary) 100%
        );
        color: white;
        border-radius: 8px;
      }

      .header h1 {
        font-size: 1.5rem;
        margin-bottom: 0.5rem;
      }

      .header p {
        font-size: 0.9rem;
        opacity: 0.9;
      }

      /* Theme Toggle Button */
      .theme-toggle {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
        color: white;
        font-size: 1.2rem;
      }

      .theme-toggle:hover {
        background: rgba(255, 255, 255, 0.3);
        border-color: rgba(255, 255, 255, 0.5);
        transform: scale(1.05);
      }

      .theme-toggle:focus {
        outline: none;
        box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3);
      }

      .theme-toggle:active {
        transform: scale(0.95);
      }

      /* Theme toggle icon animation */
      .theme-toggle .icon {
        transition: transform 0.3s ease;
      }

      .theme-toggle:hover .icon {
        transform: rotate(15deg);
      }

      /* Main Layout Grid */
      .main-layout {
        display: grid;
        grid-template-columns: 1fr;
        gap: 1.5rem;
      }

      /* Control Panel */
      .control-panel {
        background: var(--bg-secondary);
        border-radius: 8px;
        padding: 1.5rem;
        box-shadow: 0 2px 10px var(--shadow-light);
        transition: background-color 0.3s ease, box-shadow 0.3s ease;
      }

      .control-section {
        margin-bottom: 1.5rem;
      }

      .control-section:last-child {
        margin-bottom: 0;
      }

      .section-title {
        font-size: 1.1rem;
        font-weight: 600;
        margin-bottom: 1rem;
        color: var(--text-primary);
        border-bottom: 2px solid var(--border-color);
        padding-bottom: 0.5rem;
        transition: color 0.3s ease, border-color 0.3s ease;
      }

      /* Preview Panel */
      .preview-panel {
        background: var(--bg-secondary);
        border-radius: 8px;
        padding: 1.5rem;
        box-shadow: 0 2px 10px var(--shadow-light);
        transition: background-color 0.3s ease, box-shadow 0.3s ease;
      }

      .preview-container {
        width: 100%;
        max-width: 100%;
        aspect-ratio: 16/9;
        border: 2px solid #e9ecef;
        border-radius: 8px;
        overflow: hidden;
        position: relative;
      }

      #preview-canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      /* Form Controls */
      .form-group {
        margin-bottom: 1rem;
      }

      .form-label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: 500;
        color: var(--text-secondary);
        transition: color 0.3s ease;
      }

      .form-input {
        width: 100%;
        padding: 0.75rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 1rem;
        background-color: var(--bg-secondary);
        color: var(--text-primary);
        transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out,
          background-color 0.3s ease, color 0.3s ease;
      }

      .form-input:focus {
        outline: none;
        border-color: var(--border-color-focus);
        box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
      }

      .form-select {
        width: 100%;
        padding: 0.75rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 1rem;
        background-color: var(--bg-secondary);
        color: var(--text-primary);
        cursor: pointer;
        transition: border-color 0.15s ease-in-out, background-color 0.3s ease,
          color 0.3s ease;
      }

      .form-help {
        display: block;
        margin-top: 0.25rem;
        font-size: 0.875rem;
        color: var(--text-muted);
        line-height: 1.4;
        transition: color 0.3s ease;
      }

      .text-form {
        width: 100%;
      }

      .form-input:invalid {
        border-color: #dc3545;
      }

      .form-input:invalid:focus {
        border-color: #dc3545;
        box-shadow: 0 0 0 0.2rem rgba(220, 53, 69, 0.25);
      }

      .form-input.error {
        border-color: #dc3545;
      }

      .form-input.error:focus {
        border-color: #dc3545;
        box-shadow: 0 0 0 0.2rem rgba(220, 53, 69, 0.25);
      }

      .form-error {
        display: none;
        margin-top: 0.25rem;
        font-size: 0.875rem;
        color: #dc3545;
        line-height: 1.4;
      }

      /* Button Styles */
      .btn {
        display: inline-block;
        padding: 0.75rem 1.5rem;
        font-size: 1rem;
        font-weight: 500;
        text-align: center;
        text-decoration: none;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.15s ease-in-out;
      }

      .btn-primary {
        background-color: var(--accent-primary);
        color: white;
      }

      .btn-primary:hover {
        background-color: #5a6fd8;
      }

      .btn-secondary {
        background-color: var(--text-muted);
        color: white;
      }

      .btn-secondary:hover {
        background-color: #5a6268;
      }

      /* Utility Classes */
      .text-center {
        text-align: center;
      }

      .mb-1 {
        margin-bottom: 0.5rem;
      }
      .mb-2 {
        margin-bottom: 1rem;
      }
      .mb-3 {
        margin-bottom: 1.5rem;
      }

      .mt-1 {
        margin-top: 0.5rem;
      }
      .mt-2 {
        margin-top: 1rem;
      }
      .mt-3 {
        margin-top: 1.5rem;
      }

      /* Mobile-specific optimizations */
      @media (max-width: 767px) {
        .container {
          padding: 0.75rem;
        }

        .header {
          margin-bottom: 1.5rem;
          padding: 0.75rem;
        }

        .header h1 {
          font-size: 1.25rem;
        }

        .header p {
          font-size: 0.85rem;
        }

        /* Collapsible control sections for mobile */
        .control-section {
          border: 1px solid var(--border-color);
          border-radius: 8px;
          margin-bottom: 1rem;
          overflow: hidden;
        }

        .section-title {
          background: var(--bg-tertiary);
          margin-bottom: 0;
          padding: 1rem;
          cursor: pointer;
          position: relative;
          user-select: none;
          border-bottom: 1px solid var(--border-color);
          transition: background-color 0.15s ease;
        }

        .section-title:hover {
          background: var(--border-color);
        }

        .section-title::after {
          content: "▼";
          position: absolute;
          right: 1rem;
          top: 50%;
          transform: translateY(-50%);
          transition: transform 0.3s ease;
          font-size: 0.8rem;
          color: var(--text-muted);
        }

        .control-section.collapsed .section-title::after {
          transform: translateY(-50%) rotate(-90deg);
        }

        .section-content {
          padding: 1rem;
          transition: max-height 0.3s ease, opacity 0.3s ease;
          max-height: 1000px;
          opacity: 1;
        }

        .control-section.collapsed .section-content {
          max-height: 0;
          opacity: 0;
          padding-top: 0;
          padding-bottom: 0;
          overflow: hidden;
        }

        /* Mobile form optimizations */
        .form-input,
        .form-select {
          font-size: 16px; /* Prevents zoom on iOS */
          padding: 0.875rem;
        }

        .form-label {
          font-size: 0.95rem;
          font-weight: 600;
        }

        .form-help {
          font-size: 0.8rem;
        }

        /* Mobile button optimizations */
        .btn {
          padding: 1rem 1.5rem;
          font-size: 1rem;
          min-height: 48px; /* Touch target size */
        }

        /* Mobile layout selection */
        .layout-selection {
          gap: 1rem;
        }

        .layout-card {
          min-height: 200px;
        }

        .layout-preview {
          height: 100px;
        }

        /* Mobile asset gallery */
        .asset-gallery {
          grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
          gap: 0.5rem;
        }

        .logo-gallery {
          grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        }

        .background-gallery {
          grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        }

        /* Mobile position controls */
        .position-option {
          padding: 0.75rem;
        }

        .position-title {
          font-size: 0.9rem;
        }

        .position-description {
          font-size: 0.8rem;
        }

        /* Mobile preview panel */
        .preview-panel {
          order: -1; /* Show preview first on mobile */
          margin-bottom: 1rem;
        }

        .preview-container {
          border-radius: 6px;
        }

        /* Mobile typography controls */
        .color-toggle-group {
          flex-direction: column;
          gap: 0.5rem;
        }

        .color-toggle-btn {
          justify-content: flex-start;
          padding: 0.875rem 1rem;
        }

        /* Mobile upload area */
        .upload-area {
          padding: 1.5rem 1rem;
        }

        .upload-icon {
          font-size: 1.5rem;
        }

        .upload-text {
          font-size: 0.85rem;
        }

        .upload-hint {
          font-size: 0.75rem;
        }

        /* Mobile asset tabs */
        .asset-tab {
          padding: 0.75rem 0.5rem;
          font-size: 0.85rem;
        }

        /* Mobile export controls */
        #export-btn {
          width: 100%;
          margin-top: 1rem;
        }

        /* Mobile sticky header */
        .header {
          position: sticky;
          top: 0;
          z-index: 100;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
      }

      /* Tablet Styles */
      @media (min-width: 768px) {
        .container {
          padding: 2rem;
        }

        .header h1 {
          font-size: 2rem;
        }

        .header p {
          font-size: 1rem;
        }

        .main-layout {
          grid-template-columns: 1fr 1fr;
          gap: 2rem;
        }

        .control-panel,
        .preview-panel {
          padding: 2rem;
        }

        /* Reset mobile collapsible sections for tablet+ */
        .control-section {
          border: none;
          margin-bottom: 1.5rem;
        }

        .section-title {
          background: transparent;
          cursor: default;
          padding: 0 0 0.5rem 0;
          border-bottom: 2px solid #e9ecef;
        }

        .section-title::after {
          display: none;
        }

        .section-content {
          padding: 0;
          margin-top: 1rem;
          max-height: none;
          opacity: 1;
        }

        .control-section.collapsed .section-content {
          max-height: none;
          opacity: 1;
          padding: 0;
          margin-top: 1rem;
          overflow: visible;
        }

        /* Reset mobile preview order */
        .preview-panel {
          order: 0;
          margin-bottom: 0;
        }
      }

      /* Desktop Styles */
      @media (min-width: 1024px) {
        .main-layout {
          grid-template-columns: 400px 1fr;
        }

        .header h1 {
          font-size: 2.5rem;
        }

        /* Sticky Preview Panel */
        .preview-panel {
          position: sticky;
          top: 1rem;
          height: fit-content;
          max-height: calc(100vh - 2rem);
          overflow-y: auto;
        }
      }

      /* Loading and Error States */
      .loading {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 200px;
        color: var(--text-muted);
        transition: color 0.3s ease;
      }

      .error {
        background-color: var(--error-bg);
        color: var(--error-text);
        padding: 1rem;
        border-radius: 4px;
        margin-bottom: 1rem;
        transition: background-color 0.3s ease, color 0.3s ease;
      }

      .success {
        background-color: var(--success-bg);
        color: var(--success-text);
        padding: 1rem;
        border-radius: 4px;
        margin-bottom: 1rem;
        transition: background-color 0.3s ease, color 0.3s ease;
      }

      /* Layout Selection Styles */
      .layout-selection {
        display: grid;
        grid-template-columns: 1fr;
        gap: 1rem;
      }

      .layout-card {
        border: 2px solid var(--border-color);
        border-radius: 8px;
        background: var(--bg-secondary);
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }

      .layout-card:hover {
        border-color: var(--accent-primary);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
        transform: translateY(-2px);
      }

      .layout-card.active {
        border-color: var(--accent-primary);
        box-shadow: 0 4px 16px rgba(102, 126, 234, 0.25);
        background: var(--bg-tertiary);
      }

      .layout-preview {
        height: 120px;
        position: relative;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        overflow: hidden;
      }

      .layout-preview-content {
        position: relative;
        width: 100%;
        height: 100%;
        background-size: cover;
        background-position: center;
      }

      .layout1-preview {
        position: relative;
      }

      .layout1-preview .preview-frame {
        position: absolute;
        top: 8px;
        left: 8px;
        right: 8px;
        bottom: 8px;
        border: 2px solid rgba(0, 0, 0, 0.8);
        border-radius: 8px;
      }

      .layout1-preview .preview-overlay {
        position: absolute;
        top: 8px;
        right: 8px;
        bottom: 8px;
        width: 40%;
        background: rgba(0, 0, 0, 0.6);
        border-radius: 0 6px 6px 0;
      }

      .layout2-preview {
        position: relative;
      }

      .preview-logo {
        position: absolute;
        top: 8px;
        left: 12px;
        font-size: 10px;
        font-weight: bold;
        color: white;
        background: rgba(255, 255, 255, 0.2);
        padding: 2px 6px;
        border-radius: 3px;
        backdrop-filter: blur(4px);
      }

      .preview-text {
        position: absolute;
        font-size: 8px;
        color: white;
        line-height: 1.2;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      }

      .preview-text-layout1 {
        top: 12px;
        right: 12px;
        text-align: right;
      }

      .preview-text-layout2 {
        top: 50%;
        right: 12px;
        transform: translateY(-50%);
        text-align: right;
      }

      .preview-copyright {
        position: absolute;
        bottom: 8px;
        left: 12px;
        font-size: 6px;
        color: white;
        opacity: 0.8;
      }

      .layout-info {
        padding: 1rem;
      }

      .layout-title {
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 0.5rem;
        transition: color 0.3s ease;
      }

      .layout-description {
        font-size: 0.9rem;
        color: var(--text-muted);
        margin-bottom: 0.75rem;
        line-height: 1.4;
        transition: color 0.3s ease;
      }

      .layout-features {
        display: flex;
        flex-wrap: wrap;
        gap: 0.25rem;
      }

      .feature-tag {
        font-size: 0.75rem;
        background: var(--border-color);
        color: var(--text-secondary);
        padding: 0.25rem 0.5rem;
        border-radius: 12px;
        font-weight: 500;
        transition: background-color 0.3s ease, color 0.3s ease;
      }

      .layout-card.active .feature-tag {
        background: var(--accent-primary);
        color: white;
      }

      .layout-selector {
        position: absolute;
        top: 8px;
        right: 8px;
        width: 24px;
        height: 24px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: all 0.3s ease;
        backdrop-filter: blur(4px);
      }

      .layout-card.active .layout-selector {
        opacity: 1;
        background: #667eea;
      }

      .selector-icon {
        font-size: 12px;
        font-weight: bold;
        color: #667eea;
      }

      .layout-card.active .selector-icon {
        color: white;
      }

      /* Tablet Layout Selection Styles */
      @media (min-width: 768px) {
        .layout-selection {
          grid-template-columns: 1fr 1fr;
          gap: 1.5rem;
        }

        .layout-preview {
          height: 140px;
        }

        .preview-text {
          font-size: 9px;
        }

        .preview-logo {
          font-size: 11px;
        }

        .preview-copyright {
          font-size: 7px;
        }
      }

      /* Desktop Layout Selection Styles */
      @media (min-width: 1024px) {
        .layout-selection {
          grid-template-columns: 1fr;
          gap: 1rem;
        }

        .layout-preview {
          height: 100px;
        }

        .preview-text {
          font-size: 8px;
        }

        .layout-title {
          font-size: 1rem;
        }

        .layout-description {
          font-size: 0.85rem;
        }
      }

      /* Selection Feedback Animation */
      .layout-card.selection-feedback {
        transform: scale(1.02);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
      }

      /* Text Position Classes for Preview */
      .preview-text.position-top-right {
        top: 12px;
        right: 12px;
        text-align: right;
      }

      .preview-text.position-middle {
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
      }

      .preview-text.position-bottom-left {
        bottom: 20px;
        left: 12px;
        text-align: left;
      }

      .preview-text.position-bottom-right {
        bottom: 20px;
        right: 12px;
        text-align: right;
      }

      /* Layout Selection Error Styles */
      .layout-selection-error {
        margin-bottom: 1rem;
        display: none;
      }

      /* Accessibility Improvements */
      .layout-card:focus {
        outline: 2px solid #667eea;
        outline-offset: 2px;
      }

      .layout-card[aria-selected="true"] {
        border-color: #667eea;
      }

      /* High Contrast Mode Support */
      @media (prefers-contrast: high) {
        .layout-card {
          border-width: 3px;
        }

        .layout-card.active {
          border-color: #000;
        }

        .feature-tag {
          border: 1px solid #495057;
        }
      }

      /* Reduced Motion Support */
      @media (prefers-reduced-motion: reduce) {
        .layout-card {
          transition: none;
        }

        .layout-card.selection-feedback {
          transform: none;
        }

        .layout-selector {
          transition: none;
        }
      }

      /* Font Family Definitions for System Fonts */
      .font-hiragino-sans {
        font-family: "Hiragino Sans", "ヒラギノ角ゴシック",
          "Hiragino Kaku Gothic ProN", "ヒラギノ角ゴ ProN W3", "メイリオ",
          Meiryo, sans-serif;
      }

      .font-yu-gothic {
        font-family: "Yu Gothic", "游ゴシック", "YuGothic", "游ゴシック体",
          "ヒラギノ角ゴ Pro W3", "メイリオ", Meiryo, sans-serif;
      }

      .font-meiryo {
        font-family: Meiryo, "メイリオ", "Hiragino Kaku Gothic ProN",
          "ヒラギノ角ゴ ProN W3", sans-serif;
      }

      /* Typography Control Styles */
      .font-preview {
        margin-top: 0.5rem;
        padding: 0.75rem;
        background-color: var(--bg-tertiary);
        border-radius: 4px;
        border: 1px solid var(--border-color);
        transition: background-color 0.3s ease, border-color 0.3s ease;
      }

      .font-preview-text {
        font-size: 16px;
        line-height: 1.4;
        color: var(--text-secondary);
        transition: color 0.3s ease;
      }

      .font-loading {
        display: inline-block;
        margin-left: 0.5rem;
        font-size: 0.875rem;
        color: #6c757d;
      }

      .font-error {
        margin-bottom: 1rem;
        display: none;
      }

      /* Range Slider Styles */
      .form-range {
        width: 100%;
        height: 6px;
        background: var(--border-color);
        border-radius: 3px;
        outline: none;
        -webkit-appearance: none;
        appearance: none;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      .form-range::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        background: var(--accent-primary);
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.15s ease-in-out;
      }

      .form-range::-webkit-slider-thumb:hover {
        background: #5a6fd8;
        transform: scale(1.1);
      }

      .form-range::-moz-range-thumb {
        width: 20px;
        height: 20px;
        background: var(--accent-primary);
        border-radius: 50%;
        cursor: pointer;
        border: none;
        transition: all 0.15s ease-in-out;
      }

      .form-range::-moz-range-thumb:hover {
        background: #5a6fd8;
        transform: scale(1.1);
      }

      .form-range:focus::-webkit-slider-thumb {
        box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
      }

      .form-range:focus::-moz-range-thumb {
        box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
      }

      /* Color Toggle Button Styles */
      .color-toggle-group {
        display: flex;
        gap: 0.5rem;
        margin-top: 0.5rem;
      }

      .color-toggle-btn {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.75rem 1rem;
        border: 2px solid var(--border-color);
        border-radius: 6px;
        background: var(--bg-secondary);
        color: var(--text-secondary);
        font-size: 0.9rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s ease-in-out;
        flex: 1;
        justify-content: center;
      }

      .color-toggle-btn:hover {
        border-color: var(--accent-primary);
        background: var(--bg-tertiary);
      }

      .color-toggle-btn.active {
        border-color: var(--accent-primary);
        background: var(--accent-primary);
        color: white;
      }

      .color-toggle-btn:focus {
        outline: none;
        box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
      }

      .color-preview {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        border: 2px solid #dee2e6;
        display: inline-block;
      }

      .color-preview-white {
        background: white;
      }

      .color-preview-black {
        background: #212529;
      }

      .color-toggle-btn.active .color-preview {
        border-color: rgba(255, 255, 255, 0.5);
      }

      /* Mobile Responsive Adjustments for Typography Controls */
      @media (max-width: 767px) {
        .color-toggle-group {
          flex-direction: column;
        }

        .color-toggle-btn {
          justify-content: flex-start;
        }
      }

      /* Asset Management Styles */
      .asset-gallery {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        gap: 0.75rem;
        margin-top: 1rem;
      }

      .asset-item {
        position: relative;
        aspect-ratio: 1;
        border: 2px solid var(--border-color);
        border-radius: 8px;
        background: var(--bg-secondary);
        cursor: pointer;
        transition: all 0.15s ease-in-out;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .asset-item:hover {
        border-color: var(--accent-primary);
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.15);
        transform: translateY(-1px);
      }

      .asset-item.active {
        border-color: var(--accent-primary);
        box-shadow: 0 2px 12px rgba(102, 126, 234, 0.25);
        background: var(--bg-tertiary);
      }

      .asset-item:focus {
        outline: none;
        box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
      }

      .asset-thumbnail {
        width: 100%;
        height: 100%;
        object-fit: contain;
        padding: 4px;
      }

      .asset-selector {
        position: absolute;
        top: 4px;
        right: 4px;
        width: 18px;
        height: 18px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: all 0.15s ease-in-out;
        backdrop-filter: blur(4px);
      }

      .asset-item.active .asset-selector {
        opacity: 1;
        background: #667eea;
      }

      .asset-selector-icon {
        font-size: 10px;
        font-weight: bold;
        color: #667eea;
      }

      .asset-item.active .asset-selector-icon {
        color: white;
      }

      .asset-loading {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 120px;
        color: #6c757d;
        font-size: 0.9rem;
      }

      .asset-error {
        background-color: #f8d7da;
        color: #721c24;
        padding: 1rem;
        border-radius: 4px;
        margin-top: 1rem;
        font-size: 0.9rem;
      }

      .asset-empty {
        text-align: center;
        padding: 2rem 1rem;
        color: #6c757d;
        font-size: 0.9rem;
        border: 2px dashed #e9ecef;
        border-radius: 8px;
        margin-top: 1rem;
      }

      /* Logo Gallery Specific Styles */
      .logo-gallery {
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      }

      .logo-item {
        background: #f8f9fa;
      }

      .logo-thumbnail {
        padding: 8px;
      }

      .no-logo-item {
        background: var(--bg-tertiary);
        border: 2px dashed var(--border-color);
      }

      .no-logo-item:hover {
        border-color: var(--accent-primary);
        background: var(--bg-tertiary);
      }

      .no-logo-item.active {
        border-color: var(--accent-primary);
        background: var(--bg-tertiary);
        border-style: solid;
      }

      .no-logo-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        padding: 8px;
      }

      .no-logo-icon {
        font-size: 24px;
        margin-bottom: 4px;
        opacity: 0.7;
      }

      .no-logo-text {
        font-size: 10px;
        font-weight: 500;
        color: var(--text-muted);
        text-align: center;
        line-height: 1.2;
        transition: color 0.3s ease;
      }

      .no-logo-item.active .no-logo-text {
        color: var(--accent-primary);
      }

      /* Mobile responsive adjustments for no-logo option */
      @media (max-width: 767px) {
        .no-logo-icon {
          font-size: 20px;
          margin-bottom: 2px;
        }

        .no-logo-text {
          font-size: 9px;
        }
      }

      /* Background Gallery Specific Styles */
      .background-gallery {
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      }

      .background-item {
        aspect-ratio: 16/9;
      }

      .background-thumbnail {
        padding: 2px;
      }

      /* Custom Upload Styles */
      .upload-area {
        border: 2px dashed var(--border-color);
        border-radius: 8px;
        padding: 2rem 1rem;
        text-align: center;
        margin-top: 1rem;
        transition: all 0.15s ease-in-out;
        cursor: pointer;
        background: var(--bg-tertiary);
      }

      .upload-area:hover {
        border-color: var(--accent-primary);
        background: var(--bg-tertiary);
      }

      .upload-area.dragover {
        border-color: var(--accent-primary);
        background: var(--bg-tertiary);
        transform: scale(1.02);
      }

      .upload-icon {
        font-size: 2rem;
        color: var(--text-muted);
        margin-bottom: 0.5rem;
        transition: color 0.3s ease;
      }

      .upload-text {
        color: var(--text-secondary);
        font-size: 0.9rem;
        margin-bottom: 0.5rem;
        transition: color 0.3s ease;
      }

      .upload-hint {
        color: var(--text-muted);
        font-size: 0.8rem;
        transition: color 0.3s ease;
      }

      .upload-input {
        display: none;
      }

      /* Asset Section Tabs */
      .asset-tabs {
        display: flex;
        border-bottom: 2px solid var(--border-color);
        margin-bottom: 1rem;
        transition: border-color 0.3s ease;
      }

      .asset-tab {
        flex: 1;
        padding: 0.75rem 1rem;
        background: none;
        border: none;
        border-bottom: 2px solid transparent;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 500;
        color: var(--text-muted);
        transition: all 0.15s ease-in-out;
      }

      .asset-tab:hover {
        color: var(--text-secondary);
        background: var(--bg-tertiary);
      }

      .asset-tab.active {
        color: var(--accent-primary);
        border-bottom-color: var(--accent-primary);
        background: var(--bg-tertiary);
      }

      .asset-tab:focus {
        outline: none;
        box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
      }

      /* Tablet Asset Gallery Styles */
      @media (min-width: 768px) {
        .asset-gallery {
          grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
          gap: 1rem;
        }

        .logo-gallery {
          grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        }

        .background-gallery {
          grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        }
      }

      /* Desktop Asset Gallery Styles */
      @media (min-width: 1024px) {
        .asset-gallery {
          grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        }

        .logo-gallery {
          grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        }

        .background-gallery {
          grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        }
      }

      /* High Contrast Mode Support for Assets */
      @media (prefers-contrast: high) {
        .asset-item {
          border-width: 3px;
        }

        .asset-item.active {
          border-color: #000;
        }
      }

      /* Reduced Motion Support for Assets */
      @media (prefers-reduced-motion: reduce) {
        .asset-item {
          transition: none;
        }

        .upload-area.dragover {
          transform: none;
        }
      }

      /* Export Control Styles */
      .range-value {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 0.5rem;
        font-size: 0.9rem;
        color: var(--text-secondary);
        transition: color 0.3s ease;
      }

      #export-quality-value {
        font-weight: 600;
        color: var(--accent-primary);
      }

      #export-btn {
        position: relative;
        overflow: hidden;
      }

      #export-btn:disabled {
        background-color: #6c757d;
        cursor: not-allowed;
        opacity: 0.6;
      }

      #export-btn:disabled:hover {
        background-color: #6c757d;
      }

      .export-progress-bar {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        background: rgba(255, 255, 255, 0.2);
        transition: width 0.3s ease;
        width: 0%;
      }

      #export-info {
        transition: color 0.3s ease;
      }

      #export-info.success {
        color: #28a745 !important;
      }

      #export-info.error {
        color: #dc3545 !important;
      }

      /* Text Position Control Styles */
      .position-control-group {
        display: grid;
        grid-template-columns: 1fr;
        gap: 0.75rem;
        margin-top: 1rem;
      }

      .position-option {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 1rem;
        border: 2px solid #e9ecef;
        border-radius: 8px;
        background: white;
        cursor: pointer;
        transition: all 0.15s ease-in-out;
        position: relative;
      }

      .position-option:hover {
        border-color: #667eea;
        background: #f8f9ff;
      }

      .position-option.active {
        border-color: #667eea;
        background: #667eea;
        color: white;
      }

      .position-option:focus-within {
        outline: none;
        box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
      }

      .position-radio {
        width: 18px;
        height: 18px;
        border: 2px solid #ced4da;
        border-radius: 50%;
        background: white;
        position: relative;
        flex-shrink: 0;
        transition: all 0.15s ease-in-out;
      }

      .position-option.active .position-radio {
        border-color: white;
        background: white;
      }

      .position-radio::after {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        width: 8px;
        height: 8px;
        background: #667eea;
        border-radius: 50%;
        transition: transform 0.15s ease-in-out;
      }

      .position-option.active .position-radio::after {
        transform: translate(-50%, -50%) scale(1);
        background: #667eea;
      }

      .position-info {
        flex: 1;
      }

      .position-title {
        font-weight: 600;
        font-size: 0.95rem;
        margin-bottom: 0.25rem;
        color: #2c3e50;
      }

      .position-option.active .position-title {
        color: white;
      }

      .position-description {
        font-size: 0.85rem;
        color: #6c757d;
        line-height: 1.3;
      }

      .position-option.active .position-description {
        color: rgba(255, 255, 255, 0.9);
      }

      .position-preview {
        width: 60px;
        height: 34px;
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border-radius: 4px;
        position: relative;
        overflow: hidden;
        flex-shrink: 0;
        border: 1px solid #dee2e6;
      }

      .position-option.active .position-preview {
        background: linear-gradient(135deg, #ffffff 0%, #f8f9ff 100%);
        border-color: rgba(255, 255, 255, 0.3);
      }

      .position-preview-dot {
        position: absolute;
        width: 6px;
        height: 6px;
        background: #667eea;
        border-radius: 50%;
        transition: all 0.15s ease-in-out;
      }

      .position-option.active .position-preview-dot {
        background: #667eea;
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.5);
      }

      /* Position-specific dot placements */
      .position-preview-dot.top-right {
        top: 6px;
        right: 6px;
      }

      .position-preview-dot.middle {
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }

      .position-preview-dot.middle-right {
        top: 50%;
        right: 6px;
        transform: translateY(-50%);
      }

      .position-preview-dot.bottom-left {
        bottom: 6px;
        left: 6px;
      }

      .position-preview-dot.bottom-right {
        bottom: 6px;
        right: 6px;
      }

      /* Layout-specific position control visibility */
      .position-control-section {
        display: none;
      }

      .position-control-section.active {
        display: block;
      }

      /* Hidden radio inputs for accessibility */
      .position-input {
        position: absolute;
        opacity: 0;
        pointer-events: none;
      }

      /* Tablet Position Control Styles */
      @media (min-width: 768px) {
        .position-control-group {
          grid-template-columns: 1fr;
          gap: 0.5rem;
        }

        .position-option {
          padding: 0.875rem;
        }

        .position-preview {
          width: 70px;
          height: 40px;
        }
      }

      /* Desktop Position Control Styles */
      @media (min-width: 1024px) {
        .position-control-group {
          gap: 0.5rem;
        }

        .position-option {
          padding: 0.75rem;
        }

        .position-title {
          font-size: 0.9rem;
        }

        .position-description {
          font-size: 0.8rem;
        }

        .position-preview {
          width: 60px;
          height: 34px;
        }
      }

      /* High Contrast Mode Support for Position Controls */
      @media (prefers-contrast: high) {
        .position-option {
          border-width: 3px;
        }

        .position-option.active {
          border-color: #000;
        }

        .position-radio {
          border-width: 3px;
        }
      }

      /* Reduced Motion Support for Position Controls */
      @media (prefers-reduced-motion: reduce) {
        .position-option {
          transition: none;
        }

        .position-radio::after {
          transition: none;
        }

        .position-preview-dot {
          transition: none;
        }
      }

      /* Mobile-specific touch improvements */
      @media (max-width: 767px) {
        /* Improve touch targets */
        .layout-card,
        .asset-item,
        .position-option,
        .color-toggle-btn {
          min-height: 48px;
          min-width: 48px;
        }

        /* Add visual feedback for touch */
        .mobile-optimized .layout-card:active,
        .mobile-optimized .asset-item:active,
        .mobile-optimized .position-option:active,
        .mobile-optimized .color-toggle-btn:active,
        .mobile-optimized .btn:active {
          transform: scale(0.98);
          transition: transform 0.1s ease;
        }

        /* Improve scrolling on mobile */
        .control-panel {
          -webkit-overflow-scrolling: touch;
          overscroll-behavior: contain;
        }

        /* Mobile-specific focus styles */
        .mobile-optimized *:focus {
          outline: 2px solid #667eea;
          outline-offset: 2px;
        }

        /* Improve mobile form interactions */
        .mobile-optimized .form-input:focus,
        .mobile-optimized .form-select:focus {
          border-color: #667eea;
          box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
          transform: scale(1.02);
          transition: all 0.15s ease;
        }

        /* Mobile loading states */
        .mobile-optimized .loading {
          font-size: 1.1rem;
          padding: 2rem 1rem;
        }

        /* Mobile error states */
        .mobile-optimized .error {
          font-size: 0.95rem;
          padding: 1rem;
          margin: 0.5rem 0;
        }

        /* Mobile success states */
        .mobile-optimized .success {
          font-size: 0.95rem;
          padding: 1rem;
          margin: 0.5rem 0;
        }

        /* Improve mobile canvas interaction */
        .mobile-optimized .preview-container {
          touch-action: pan-y;
          user-select: none;
        }

        /* Mobile-specific animations */
        .mobile-optimized .section-content {
          transition: max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1),
            opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1),
            padding 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Improve mobile typography */
        .mobile-optimized .section-title {
          font-size: 1rem;
          line-height: 1.4;
        }

        .mobile-optimized .form-label {
          font-size: 0.9rem;
          line-height: 1.3;
        }

        /* Mobile-specific spacing */
        .mobile-optimized .form-group {
          margin-bottom: 1.25rem;
        }

        .mobile-optimized .control-section {
          margin-bottom: 0.75rem;
        }

        /* Mobile notification improvements */
        .export-notification {
          left: 10px !important;
          right: 10px !important;
          max-width: none !important;
          font-size: 0.9rem;
        }

        /* Mobile progress indicator improvements */
        #export-progress {
          left: 10px !important;
          right: 10px !important;
          transform: translateY(-50%) !important;
          max-width: none !important;
        }
      }

      /* Error Handling and User Feedback Styles */
      .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        max-width: 400px;
        padding: 1rem 1.5rem;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 10000;
        font-size: 0.9rem;
        line-height: 1.4;
        transform: translateX(100%);
        transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
        opacity: 0;
        backdrop-filter: blur(8px);
      }

      .notification.show {
        transform: translateX(0);
        opacity: 1;
      }

      .notification.error {
        background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        color: white;
        border-left: 4px solid #a71e2a;
      }

      .notification.success {
        background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        color: white;
        border-left: 4px solid #1e7e34;
      }

      .notification.warning {
        background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%);
        color: #212529;
        border-left: 4px solid #d39e00;
      }

      .notification.info {
        background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
        color: white;
        border-left: 4px solid #117a8b;
      }

      .notification-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 0.5rem;
        font-weight: 600;
      }

      .notification-icon {
        margin-right: 0.5rem;
        font-size: 1.1rem;
      }

      .notification-close {
        background: none;
        border: none;
        color: inherit;
        font-size: 1.2rem;
        cursor: pointer;
        padding: 0;
        margin-left: 1rem;
        opacity: 0.8;
        transition: opacity 0.2s ease;
      }

      .notification-close:hover {
        opacity: 1;
      }

      .notification-body {
        font-size: 0.85rem;
        opacity: 0.95;
      }

      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        backdrop-filter: blur(4px);
      }

      .loading-content {
        background: white;
        padding: 2rem;
        border-radius: 12px;
        text-align: center;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        max-width: 300px;
        width: 90%;
      }

      .loading-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #e9ecef;
        border-top: 4px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 1rem;
      }

      .loading-text {
        color: #495057;
        font-size: 1rem;
        font-weight: 500;
        margin-bottom: 0.5rem;
      }

      .loading-subtext {
        color: #6c757d;
        font-size: 0.85rem;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .error-boundary {
        border: 2px solid #dc3545;
        background: #f8d7da;
        color: #721c24;
        padding: 1rem;
        border-radius: 8px;
        margin: 1rem 0;
      }

      .error-boundary-header {
        font-weight: 600;
        margin-bottom: 0.5rem;
        display: flex;
        align-items: center;
      }

      .error-boundary-icon {
        margin-right: 0.5rem;
        font-size: 1.1rem;
      }

      .error-boundary-message {
        font-size: 0.9rem;
        line-height: 1.4;
        margin-bottom: 0.5rem;
      }

      .error-boundary-actions {
        display: flex;
        gap: 0.5rem;
        margin-top: 1rem;
      }

      .error-retry-btn {
        background: #dc3545;
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        font-size: 0.85rem;
        cursor: pointer;
        transition: background-color 0.2s ease;
      }

      .error-retry-btn:hover {
        background: #c82333;
      }

      .error-dismiss-btn {
        background: transparent;
        color: #721c24;
        border: 1px solid #721c24;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        font-size: 0.85rem;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .error-dismiss-btn:hover {
        background: #721c24;
        color: white;
      }

      .form-field-error {
        border-color: #dc3545 !important;
        box-shadow: 0 0 0 0.2rem rgba(220, 53, 69, 0.25) !important;
      }

      .field-error-message {
        display: block;
        margin-top: 0.25rem;
        font-size: 0.875rem;
        color: #dc3545;
        line-height: 1.4;
      }

      .field-error-icon {
        margin-right: 0.25rem;
      }

      /* Mobile notification adjustments */
      @media (max-width: 767px) {
        .notification {
          top: 10px;
          right: 10px;
          left: 10px;
          max-width: none;
          transform: translateY(-100%);
        }

        .notification.show {
          transform: translateY(0);
        }

        .loading-content {
          padding: 1.5rem;
        }

        .error-boundary-actions {
          flex-direction: column;
        }
      }

      /* Landscape mobile optimizations */
      @media (max-width: 767px) and (orientation: landscape) {
        .header {
          padding: 0.5rem;
          margin-bottom: 1rem;
        }

        .header h1 {
          font-size: 1.1rem;
        }

        .header p {
          font-size: 0.8rem;
        }

        .main-layout {
          grid-template-columns: 1fr 1fr;
          gap: 1rem;
        }

        .preview-panel {
          order: 0;
        }

        .control-section {
          margin-bottom: 0.5rem;
        }

        .section-title {
          padding: 0.75rem;
          font-size: 0.9rem;
        }

        .section-content {
          padding: 0.75rem;
        }
      }

      /* High DPI mobile displays */
      @media (max-width: 767px) and (-webkit-min-device-pixel-ratio: 2) {
        .asset-thumbnail,
        .logo-thumbnail,
        .background-thumbnail {
          image-rendering: -webkit-optimize-contrast;
          image-rendering: crisp-edges;
        }
      }

      /* Dark mode support for mobile */
      @media (max-width: 767px) and (prefers-color-scheme: dark) {
        .mobile-optimized .control-section {
          background: #2d3748;
          border-color: #4a5568;
        }

        .mobile-optimized .section-title {
          background: #1a202c;
          color: #e2e8f0;
          border-color: #4a5568;
        }

        .mobile-optimized .section-title:hover {
          background: #2d3748;
        }

        .mobile-optimized .form-input,
        .mobile-optimized .form-select {
          background: #2d3748;
          border-color: #4a5568;
          color: #e2e8f0;
        }

        .mobile-optimized .form-label {
          color: #e2e8f0;
        }

        .mobile-optimized .form-help {
          color: #a0aec0;
        }
      }

      /* Cross-Browser Compatibility Styles */

      /* Safari-specific fixes */
      .browser-safari * {
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .browser-safari .form-input,
      .browser-safari .form-select {
        -webkit-appearance: none;
        appearance: none;
        border-radius: 4px;
      }

      .browser-safari .form-range {
        -webkit-appearance: none;
        appearance: none;
      }

      .browser-safari .form-range::-webkit-slider-thumb {
        -webkit-appearance: none;
      }

      .browser-safari .preview-container {
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
      }

      /* Firefox-specific fixes */
      .browser-firefox .form-range::-moz-range-track {
        background: #e9ecef;
        height: 6px;
        border-radius: 3px;
        border: none;
      }

      .browser-firefox .form-range::-moz-range-thumb {
        border: none;
        border-radius: 50%;
        background: #667eea;
        width: 20px;
        height: 20px;
        cursor: pointer;
      }

      .browser-firefox .form-range::-moz-focus-outer {
        border: 0;
      }

      .browser-firefox .asset-thumbnail,
      .browser-firefox .logo-thumbnail,
      .browser-firefox .background-thumbnail {
        image-rendering: -moz-crisp-edges;
      }

      /* Edge-specific fixes */
      .browser-edge .form-input,
      .browser-edge .form-select {
        border: 1px solid #ced4da;
      }

      .browser-edge .form-range::-ms-track {
        background: #e9ecef;
        height: 6px;
        border-radius: 3px;
        border: none;
        color: transparent;
      }

      .browser-edge .form-range::-ms-thumb {
        background: #667eea;
        border: none;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        cursor: pointer;
      }

      .browser-edge .form-range::-ms-fill-lower,
      .browser-edge .form-range::-ms-fill-upper {
        background: #e9ecef;
        border-radius: 3px;
      }

      /* Chrome-specific optimizations */
      .browser-chrome .preview-container {
        will-change: transform;
      }

      .browser-chrome .asset-thumbnail,
      .browser-chrome .logo-thumbnail,
      .browser-chrome .background-thumbnail {
        image-rendering: -webkit-optimize-contrast;
      }

      /* Fallback styles for browsers without backdrop-filter support */
      .no-backdrop-filter .notification {
        background: rgba(220, 53, 69, 0.95) !important;
      }

      .no-backdrop-filter .notification.success {
        background: rgba(40, 167, 69, 0.95) !important;
      }

      .no-backdrop-filter .notification.warning {
        background: rgba(255, 193, 7, 0.95) !important;
      }

      .no-backdrop-filter .notification.info {
        background: rgba(23, 162, 184, 0.95) !important;
      }

      .no-backdrop-filter .asset-selector,
      .no-backdrop-filter .layout-selector {
        background: rgba(255, 255, 255, 0.95) !important;
      }

      .no-backdrop-filter .loading-overlay {
        background: rgba(0, 0, 0, 0.8) !important;
      }

      /* Font fallback styles */
      .font-fallback .font-fallback-jp {
        font-family: "Hiragino Sans", "ヒラギノ角ゴシック", "Yu Gothic",
          "游ゴシック", "Meiryo", "メイリオ", sans-serif !important;
      }

      .font-fallback .font-fallback-en {
        font-family: Arial, Helvetica, sans-serif !important;
      }

      /* Canvas not supported styles */
      .no-canvas .preview-container {
        background: #f8f9fa;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #6c757d;
        font-size: 1.1rem;
      }

      .no-canvas .preview-container::before {
        content: "Canvas not supported in your browser";
      }

      /* File API not supported styles */
      .no-file-api .upload-area {
        display: none !important;
      }

      .no-file-api .asset-tab[data-tab="upload"] {
        display: none !important;
      }

      /* HTML2Canvas not available styles */
      .no-html2canvas #export-btn {
        background-color: #6c757d !important;
        cursor: not-allowed !important;
        opacity: 0.6 !important;
      }

      .no-html2canvas #export-btn:hover {
        background-color: #6c757d !important;
      }

      /* Mobile device optimizations */
      .mobile-device * {
        -webkit-tap-highlight-color: transparent;
      }

      .mobile-device .preview-container {
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
      }

      .mobile-device .form-input:focus,
      .mobile-device .form-select:focus {
        /* Prevent zoom on iOS */
        font-size: 16px;
      }

      /* High contrast mode support */
      @media (prefers-contrast: high) {
        .layout-card,
        .asset-item,
        .position-option {
          border-width: 3px;
        }

        .layout-card.active,
        .asset-item.active,
        .position-option.active {
          border-color: #000;
        }

        .feature-tag {
          border: 1px solid #495057;
        }

        .btn {
          border: 2px solid currentColor;
        }
      }

      /* Reduced motion support */
      @media (prefers-reduced-motion: reduce) {
        .layout-card,
        .asset-item,
        .position-option,
        .color-toggle-btn,
        .notification,
        .loading-spinner {
          transition: none !important;
          animation: none !important;
        }

        .layout-card.selection-feedback {
          transform: none !important;
        }

        .upload-area.dragover {
          transform: none !important;
        }
      }

      /* Print styles */
      @media print {
        .control-panel,
        .header,
        .notification,
        .loading-overlay {
          display: none !important;
        }

        .preview-panel {
          width: 100% !important;
          max-width: none !important;
          box-shadow: none !important;
          border: 1px solid #000 !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Header -->
      <header class="header">
        <button
          class="theme-toggle"
          id="theme-toggle"
          aria-label="Toggle dark mode"
        >
          <span class="icon">🌙</span>
        </button>
        <h1>DDAM Meeting Background Generator</h1>
        <p>
          Create personalized virtual meeting backgrounds for Dentsu Data Artist
          Mongol
        </p>
      </header>

      <!-- Main Layout -->
      <main class="main-layout">
        <!-- Control Panel -->
        <aside class="control-panel">
          <div class="control-section">
            <h2 class="section-title">Layout Selection</h2>
            <div class="layout-selection">
              <div class="layout-card" data-layout="layout1" id="layout1-card">
                <div class="layout-preview">
                  <div class="layout-preview-content layout1-preview">
                    <div class="preview-logo">LOGO</div>
                    <div class="preview-frame"></div>
                    <div class="preview-overlay"></div>
                    <div class="preview-text preview-text-layout1">
                      <div>John Smith</div>
                      <div>ジョン</div>
                      <div>Senior Data Analyst</div>
                      <div>シニアデータアナリスト</div>
                    </div>
                    <div class="preview-copyright">
                      ©2025 Dentsu Data Artist Mongol LLC. All Rights Reserved.
                    </div>
                  </div>
                </div>
                <div class="layout-info">
                  <h3 class="layout-title">Layout 1</h3>
                  <p class="layout-description">
                    Rounded frame with overlay and flexible text positioning
                  </p>
                  <div class="layout-features">
                    <span class="feature-tag">Rounded Frame</span>
                    <span class="feature-tag">Right Overlay</span>
                    <span class="feature-tag">3 Text Positions</span>
                  </div>
                </div>
                <div class="layout-selector">
                  <div class="selector-icon">✓</div>
                </div>
              </div>

              <div class="layout-card" data-layout="layout2" id="layout2-card">
                <div class="layout-preview">
                  <div class="layout-preview-content layout2-preview">
                    <div class="preview-logo">LOGO</div>
                    <div class="preview-text preview-text-layout2">
                      <div>John Smith</div>
                      <div>ジョン</div>
                      <div>Senior Data Analyst</div>
                      <div>シニアデータアナリスト</div>
                    </div>
                    <div class="preview-copyright">
                      ©2025 Dentsu Data Artist Mongol LLC. All Rights Reserved.
                    </div>
                  </div>
                </div>
                <div class="layout-info">
                  <h3 class="layout-title">Layout 2</h3>
                  <p class="layout-description">
                    Clean design with flexible text positioning options
                  </p>
                  <div class="layout-features">
                    <span class="feature-tag">Clean Design</span>
                    <span class="feature-tag">No Overlay</span>
                    <span class="feature-tag">3 Text Positions</span>
                  </div>
                </div>
                <div class="layout-selector">
                  <div class="selector-icon">✓</div>
                </div>
              </div>
            </div>
          </div>

          <div class="control-section">
            <h2 class="section-title">Text Information</h2>
            <form id="text-form" class="text-form">
              <div class="form-group">
                <label for="fullName" class="form-label">Full Name</label>
                <input
                  type="text"
                  id="fullName"
                  name="fullName"
                  class="form-input"
                  value="John Smith"
                  placeholder="Enter your full name"
                  maxlength="100"
                  aria-describedby="fullName-help"
                  required
                />
                <small id="fullName-help" class="form-help"
                  >Your full name as it should appear on the background</small
                >
              </div>

              <div class="form-group">
                <label for="nickname" class="form-label"
                  >Nickname (ニックネーム)</label
                >
                <input
                  type="text"
                  id="nickname"
                  name="nickname"
                  class="form-input"
                  value="ジョン"
                  placeholder="Enter your nickname in Japanese"
                  maxlength="50"
                  aria-describedby="nickname-help"
                  required
                />
                <small id="nickname-help" class="form-help"
                  >Your nickname in Japanese characters</small
                >
              </div>

              <div class="form-group">
                <label for="positionEn" class="form-label"
                  >Position (English)</label
                >
                <input
                  type="text"
                  id="positionEn"
                  name="positionEn"
                  class="form-input"
                  value="Senior Data Analyst"
                  placeholder="Enter your position in English"
                  maxlength="100"
                  aria-describedby="positionEn-help"
                  required
                />
                <small id="positionEn-help" class="form-help"
                  >Your job title in English</small
                >
              </div>

              <div class="form-group">
                <label for="positionJp" class="form-label"
                  >Position (Japanese) - DDAMのポジション</label
                >
                <input
                  type="text"
                  id="positionJp"
                  name="positionJp"
                  class="form-input"
                  value="シニアデータアナリスト"
                  placeholder="Enter your position in Japanese"
                  maxlength="100"
                  aria-describedby="positionJp-help"
                  required
                />
                <small id="positionJp-help" class="form-help"
                  >Your job title in Japanese characters</small
                >
              </div>
            </form>
          </div>

          <div class="control-section">
            <h2 class="section-title">Typography</h2>

            <div class="form-group">
              <label for="japaneseFont" class="form-label">Japanese Font</label>
              <select
                id="japaneseFont"
                name="japaneseFont"
                class="form-select"
                aria-describedby="japaneseFont-help"
              >
                <option value="Noto Sans JP" selected>Noto Sans JP</option>
                <option value="Hiragino Sans">Hiragino Sans</option>
                <option value="Yu Gothic">Yu Gothic</option>
                <option value="Meiryo">Meiryo</option>
                <option value="Aoboshi One">Aoboshi One</option>
                <option value="Kaisei Decol">Kaisei Decol</option>
              </select>
              <small id="japaneseFont-help" class="form-help"
                >Font family for Japanese text (nickname and position)</small
              >
            </div>

            <div class="form-group">
              <label for="englishFont" class="form-label">English Font</label>
              <select
                id="englishFont"
                name="englishFont"
                class="form-select"
                aria-describedby="englishFont-help"
              >
                <option value="Roboto" selected>Roboto</option>
                <option value="Open Sans">Open Sans</option>
                <option value="Lato">Lato</option>
                <option value="Montserrat">Montserrat</option>
                <option value="Arial">Arial</option>
                <option value="Times New Roman">Times New Roman</option>
              </select>
              <small id="englishFont-help" class="form-help"
                >Font family for English text (full name and position)</small
              >
            </div>

            <div class="form-group">
              <label for="fontSize" class="form-label"
                >Font Size: <span id="fontSize-value">18px</span></label
              >
              <input
                type="range"
                id="fontSize"
                name="fontSize"
                class="form-range"
                min="12"
                max="24"
                value="18"
                step="1"
                aria-describedby="fontSize-help"
              />
              <small id="fontSize-help" class="form-help"
                >Adjust the size of all text elements (12px - 24px)</small
              >
            </div>

            <div class="form-group">
              <label class="form-label">Text Color</label>
              <div
                class="color-toggle-group"
                role="radiogroup"
                aria-labelledby="textColor-label"
              >
                <button
                  type="button"
                  id="textColor-white"
                  class="color-toggle-btn active"
                  data-color="white"
                  role="radio"
                  aria-checked="true"
                  aria-describedby="textColor-help"
                >
                  <span class="color-preview color-preview-white"></span>
                  White
                </button>
                <button
                  type="button"
                  id="textColor-black"
                  class="color-toggle-btn"
                  data-color="black"
                  role="radio"
                  aria-checked="false"
                  aria-describedby="textColor-help"
                >
                  <span class="color-preview color-preview-black"></span>
                  Black
                </button>
              </div>
              <small id="textColor-help" class="form-help"
                >Choose text color for optimal contrast with your
                background</small
              >
            </div>
          </div>

          <div class="control-section">
            <h2 class="section-title">Text Position</h2>

            <!-- Layout 1 Position Controls -->
            <div class="position-control-section active" id="layout1-positions">
              <div class="form-group">
                <label class="form-label">Position for Layout 1</label>
                <div
                  class="position-control-group"
                  role="radiogroup"
                  aria-labelledby="layout1-position-label"
                >
                  <label class="position-option active" for="layout1-top-right">
                    <input
                      type="radio"
                      id="layout1-top-right"
                      name="layout1-position"
                      value="top-right"
                      class="position-input"
                      checked
                      aria-describedby="layout1-position-help"
                    />
                    <div class="position-radio"></div>
                    <div class="position-info">
                      <div class="position-title">Top Right</div>
                      <div class="position-description">
                        Text appears in the top-right corner over the overlay
                      </div>
                    </div>
                    <div class="position-preview">
                      <div class="position-preview-dot top-right"></div>
                    </div>
                  </label>

                  <label class="position-option" for="layout1-middle-right">
                    <input
                      type="radio"
                      id="layout1-middle-right"
                      name="layout1-position"
                      value="middle-right"
                      class="position-input"
                      aria-describedby="layout1-position-help"
                    />
                    <div class="position-radio"></div>
                    <div class="position-info">
                      <div class="position-title">Middle Right</div>
                      <div class="position-description">
                        Text appears centered vertically on the right side over
                        the overlay
                      </div>
                    </div>
                    <div class="position-preview">
                      <div class="position-preview-dot middle-right"></div>
                    </div>
                  </label>

                  <label class="position-option" for="layout1-bottom-right">
                    <input
                      type="radio"
                      id="layout1-bottom-right"
                      name="layout1-position"
                      value="bottom-right"
                      class="position-input"
                      aria-describedby="layout1-position-help"
                    />
                    <div class="position-radio"></div>
                    <div class="position-info">
                      <div class="position-title">Bottom Right</div>
                      <div class="position-description">
                        Text appears in the bottom-right corner over the overlay
                      </div>
                    </div>
                    <div class="position-preview">
                      <div class="position-preview-dot bottom-right"></div>
                    </div>
                  </label>
                </div>
                <small id="layout1-position-help" class="form-help"
                  >Choose where your text information should appear in Layout
                  1</small
                >
              </div>
            </div>

            <!-- Layout 2 Position Controls -->
            <div class="position-control-section" id="layout2-positions">
              <div class="form-group">
                <label class="form-label">Position for Layout 2</label>
                <div
                  class="position-control-group"
                  role="radiogroup"
                  aria-labelledby="layout2-position-label"
                >
                  <label class="position-option active" for="layout2-top-right">
                    <input
                      type="radio"
                      id="layout2-top-right"
                      name="layout2-position"
                      value="top-right"
                      class="position-input"
                      checked
                      aria-describedby="layout2-position-help"
                    />
                    <div class="position-radio"></div>
                    <div class="position-info">
                      <div class="position-title">Top Right</div>
                      <div class="position-description">
                        Text appears in the top-right corner of the background
                      </div>
                    </div>
                    <div class="position-preview">
                      <div class="position-preview-dot top-right"></div>
                    </div>
                  </label>

                  <label class="position-option" for="layout2-middle-right">
                    <input
                      type="radio"
                      id="layout2-middle-right"
                      name="layout2-position"
                      value="middle-right"
                      class="position-input"
                      aria-describedby="layout2-position-help"
                    />
                    <div class="position-radio"></div>
                    <div class="position-info">
                      <div class="position-title">Middle Right</div>
                      <div class="position-description">
                        Text appears centered vertically on the right side
                      </div>
                    </div>
                    <div class="position-preview">
                      <div class="position-preview-dot middle-right"></div>
                    </div>
                  </label>

                  <label class="position-option" for="layout2-bottom-right">
                    <input
                      type="radio"
                      id="layout2-bottom-right"
                      name="layout2-position"
                      value="bottom-right"
                      class="position-input"
                      aria-describedby="layout2-position-help"
                    />
                    <div class="position-radio"></div>
                    <div class="position-info">
                      <div class="position-title">Bottom Right</div>
                      <div class="position-description">
                        Text appears in the bottom-right corner above copyright
                      </div>
                    </div>
                    <div class="position-preview">
                      <div class="position-preview-dot bottom-right"></div>
                    </div>
                  </label>

                  <label class="position-option" for="layout2-bottom-left">
                    <input
                      type="radio"
                      id="layout2-bottom-left"
                      name="layout2-position"
                      value="bottom-left"
                      class="position-input"
                      aria-describedby="layout2-position-help"
                    />
                    <div class="position-radio"></div>
                    <div class="position-info">
                      <div class="position-title">Bottom Left</div>
                      <div class="position-description">
                        Text appears in the bottom-left corner above copyright
                      </div>
                    </div>
                    <div class="position-preview">
                      <div class="position-preview-dot bottom-left"></div>
                    </div>
                  </label>
                </div>
                <small id="layout2-position-help" class="form-help"
                  >Choose where your text information should appear in Layout
                  2</small
                >
              </div>
            </div>
          </div>

          <div class="control-section">
            <h2 class="section-title">Layout 1 Overlay</h2>

            <div class="form-group">
              <label for="overlay-opacity" class="form-label"
                >Overlay Transparency</label
              >
              <input
                type="range"
                id="overlay-opacity"
                class="form-range"
                min="0"
                max="100"
                value="80"
                step="5"
                aria-describedby="overlay-opacity-help"
              />
              <div class="range-value">
                <span>Transparent</span>
                <span id="overlay-opacity-value">80%</span>
                <span>Opaque</span>
              </div>
              <small id="overlay-opacity-help" class="form-help"
                >Adjust the transparency of the right overlay (Layout 1
                only)</small
              >
            </div>

            <div class="form-group">
              <label for="overlay-size" class="form-label">Overlay Size</label>
              <input
                type="range"
                id="overlay-size"
                class="form-range"
                min="20"
                max="80"
                value="40"
                step="5"
                aria-describedby="overlay-size-help"
              />
              <div class="range-value">
                <span>Small</span>
                <span id="overlay-size-value">40%</span>
                <span>Large</span>
              </div>
              <small id="overlay-size-help" class="form-help"
                >Control how much of the right side is covered by the
                overlay</small
              >
            </div>
          </div>

          <div class="control-section">
            <h2 class="section-title">Assets</h2>

            <!-- Asset Tabs -->
            <div class="asset-tabs">
              <button
                type="button"
                class="asset-tab active"
                data-tab="logos"
                id="logos-tab"
              >
                Logos
              </button>
              <button
                type="button"
                class="asset-tab"
                data-tab="backgrounds"
                id="backgrounds-tab"
              >
                Backgrounds
              </button>
              <button
                type="button"
                class="asset-tab"
                data-tab="upload"
                id="upload-tab"
              >
                Upload
              </button>
            </div>

            <!-- Logo Selection Panel -->
            <div class="asset-panel" id="logos-panel">
              <div class="asset-loading" id="logos-loading">
                Loading logos...
              </div>
              <div
                class="asset-gallery logo-gallery"
                id="logos-gallery"
                style="display: none"
              >
                <!-- Logo items will be populated by JavaScript -->
              </div>
              <div class="asset-error" id="logos-error" style="display: none">
                Failed to load logos. Please refresh the page.
              </div>
            </div>

            <!-- Background Selection Panel -->
            <div
              class="asset-panel"
              id="backgrounds-panel"
              style="display: none"
            >
              <div class="asset-loading" id="backgrounds-loading">
                Loading backgrounds...
              </div>
              <div
                class="asset-gallery background-gallery"
                id="backgrounds-gallery"
                style="display: none"
              >
                <!-- Background items will be populated by JavaScript -->
              </div>
              <div
                class="asset-error"
                id="backgrounds-error"
                style="display: none"
              >
                Failed to load backgrounds. Please refresh the page.
              </div>
            </div>

            <!-- Custom Upload Panel -->
            <div class="asset-panel" id="upload-panel" style="display: none">
              <div class="upload-area" id="upload-area">
                <div class="upload-icon">📁</div>
                <div class="upload-text">Click to upload or drag and drop</div>
                <div class="upload-hint">
                  Supports JPEG, PNG, WebP (max 10MB)
                </div>
                <input
                  type="file"
                  id="upload-input"
                  class="upload-input"
                  accept="image/jpeg,image/png,image/webp"
                />
              </div>
              <div class="asset-error" id="upload-error" style="display: none">
                <!-- Upload error messages will appear here -->
              </div>
            </div>
          </div>

          <div class="control-section">
            <h2 class="section-title">Logo Settings</h2>

            <div class="form-group">
              <label for="logoScale" class="form-label"
                >Logo Size: <span id="logoScale-value">100%</span></label
              >
              <input
                type="range"
                id="logoScale"
                name="logoScale"
                class="form-range"
                min="0.5"
                max="2.0"
                value="1.0"
                step="0.1"
                aria-describedby="logoScale-help"
              />
              <small id="logoScale-help" class="form-help"
                >Adjust the size of the logo (50% - 200%)</small
              >
            </div>
          </div>

          <div class="control-section">
            <h2 class="section-title">Export</h2>

            <div class="form-group">
              <label class="form-label" for="export-filename"
                >Filename Preview</label
              >
              <input
                type="text"
                id="export-filename"
                class="form-input"
                readonly
              />
              <small class="form-help"
                >Filename is automatically generated from your full name</small
              >
            </div>

            <div class="form-group">
              <label class="form-label" for="export-quality"
                >Export Quality</label
              >
              <input
                type="range"
                id="export-quality"
                class="form-range"
                min="0.5"
                max="1.0"
                step="0.1"
                value="1.0"
              />
              <div class="range-value">
                <span>Quality: </span>
                <span id="export-quality-value">100%</span>
              </div>
              <small class="form-help"
                >Higher quality results in larger file sizes</small
              >
            </div>

            <button
              type="button"
              id="export-btn"
              class="btn btn-primary"
              style="width: 100%; margin-top: 1rem"
            >
              <span id="export-btn-text">Export Background (1920×1080)</span>
            </button>

            <div
              id="export-info"
              class="mt-2"
              style="font-size: 0.85rem; color: #6c757d; text-align: center"
            >
              High-quality PNG format • Ready for video conferencing
            </div>
          </div>
        </aside>

        <!-- Preview Panel -->
        <section class="preview-panel">
          <h2 class="section-title">Preview</h2>
          <div class="preview-container">
            <canvas id="preview-canvas" width="1920" height="1080"></canvas>
          </div>
          <div class="text-center mt-2">
            <small class="text-muted"
              >Preview will update in real-time as you make changes</small
            >
          </div>
        </section>
      </main>
    </div>

    <script>
      // Theme Management System
      class ThemeManager {
        constructor() {
          this.currentTheme = this.getStoredTheme() || "light";
          this.themeToggle = null;
          this.init();
        }

        init() {
          // Apply initial theme
          this.applyTheme(this.currentTheme);

          // Wait for DOM to be ready
          if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", () =>
              this.setupToggle()
            );
          } else {
            this.setupToggle();
          }
        }

        setupToggle() {
          this.themeToggle = document.getElementById("theme-toggle");
          if (this.themeToggle) {
            this.updateToggleIcon();
            this.themeToggle.addEventListener("click", () =>
              this.toggleTheme()
            );

            // Add keyboard support
            this.themeToggle.addEventListener("keydown", (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                this.toggleTheme();
              }
            });
          }
        }

        getStoredTheme() {
          try {
            return localStorage.getItem("ddam-theme");
          } catch (error) {
            console.warn("Could not access localStorage for theme preference");
            return null;
          }
        }

        storeTheme(theme) {
          try {
            localStorage.setItem("ddam-theme", theme);
          } catch (error) {
            console.warn("Could not store theme preference in localStorage");
          }
        }

        applyTheme(theme) {
          document.documentElement.setAttribute("data-theme", theme);
          this.currentTheme = theme;
          this.storeTheme(theme);
        }

        toggleTheme() {
          const newTheme = this.currentTheme === "light" ? "dark" : "light";
          this.applyTheme(newTheme);
          this.updateToggleIcon();

          // Add a subtle animation feedback
          if (this.themeToggle) {
            this.themeToggle.style.transform = "scale(0.9)";
            setTimeout(() => {
              this.themeToggle.style.transform = "";
            }, 150);
          }
        }

        updateToggleIcon() {
          if (this.themeToggle) {
            const icon = this.themeToggle.querySelector(".icon");
            if (icon) {
              icon.textContent = this.currentTheme === "light" ? "🌙" : "☀️";
              this.themeToggle.setAttribute(
                "aria-label",
                this.currentTheme === "light"
                  ? "Switch to dark mode"
                  : "Switch to light mode"
              );
            }
          }
        }

        getCurrentTheme() {
          return this.currentTheme;
        }
      }

      // Initialize theme manager
      const themeManager = new ThemeManager();

      // Application State Management System

      // Core Application State
      const appState = {
        layout: {
          type: "layout1",
          dimensions: { width: 1920, height: 1080 },
          overlay: {
            opacity: 80, // 0-100 percentage
            size: 40, // 20-80 percentage of width
          },
        },

        text: {
          fields: {
            fullName: "John Smith",
            nickname: "ジョン",
            positionEn: "Senior Data Analyst",
            positionJp: "シニアデータアナリスト",
          },
          typography: {
            japaneseFont: "Noto Sans JP",
            englishFont: "Roboto",
            fontSize: 18,
            textColor: "white",
          },
          positioning: {
            layout1: "top-right",
            layout2: "top-right",
          },
        },

        assets: {
          selectedLogo: "logo/no-bg-logo-1.png",
          selectedBackground: null,
          customBackground: null,
          logoScale: 1.0,
        },

        export: {
          filename: "",
          quality: 1.0,
        },
      };

      // State Change Event System
      class StateEventEmitter {
        constructor() {
          this.listeners = {};
        }

        on(event, callback) {
          if (!this.listeners[event]) {
            this.listeners[event] = [];
          }
          this.listeners[event].push(callback);
        }

        off(event, callback) {
          if (!this.listeners[event]) return;
          this.listeners[event] = this.listeners[event].filter(
            (cb) => cb !== callback
          );
        }

        emit(event, data) {
          if (!this.listeners[event]) return;
          this.listeners[event].forEach((callback) => {
            try {
              callback(data);
            } catch (error) {
              console.error("Error in state event listener:", error);
            }
          });
        }
      }

      // Global state event emitter
      const stateEvents = new StateEventEmitter();

      // Error Handling and User Feedback System
      class NotificationManager {
        constructor() {
          this.notifications = new Map();
          this.notificationId = 0;
          this.maxNotifications = 5;
          this.defaultDuration = 5000; // 5 seconds
        }

        show(type, title, message, options = {}) {
          try {
            const id = ++this.notificationId;
            const duration =
              options.duration !== undefined
                ? options.duration
                : this.defaultDuration;
            const persistent = options.persistent || false;
            const actions = options.actions || [];

            // Create notification element
            const notification = this.createNotificationElement(
              id,
              type,
              title,
              message,
              actions,
              persistent
            );

            // Add to DOM
            document.body.appendChild(notification);

            // Store reference
            this.notifications.set(id, {
              element: notification,
              type: type,
              persistent: persistent,
              timeout: null,
            });

            // Show with animation
            requestAnimationFrame(() => {
              notification.classList.add("show");
            });

            // Auto-hide if not persistent
            if (!persistent && duration > 0) {
              const timeout = setTimeout(() => {
                this.hide(id);
              }, duration);

              this.notifications.get(id).timeout = timeout;
            }

            // Limit number of notifications
            this.limitNotifications();

            console.log(`Notification shown: ${type} - ${title}`);
            return id;
          } catch (error) {
            console.error("Failed to show notification:", error);
            return null;
          }
        }

        createNotificationElement(
          id,
          type,
          title,
          message,
          actions,
          persistent
        ) {
          const notification = document.createElement("div");
          notification.className = `notification ${type}`;
          notification.dataset.notificationId = id;
          notification.setAttribute("role", "alert");
          notification.setAttribute("aria-live", "polite");

          const iconMap = {
            error: "⚠️",
            success: "✅",
            warning: "⚠️",
            info: "ℹ️",
          };

          const icon = iconMap[type] || "ℹ️";

          notification.innerHTML = `
                  <div class="notification-header">
                      <div>
                          <span class="notification-icon">${icon}</span>
                          ${title}
                      </div>
                      ${
                        !persistent
                          ? '<button class="notification-close" aria-label="Close notification">×</button>'
                          : ""
                      }
                  </div>
                  <div class="notification-body">${message}</div>
                  ${
                    actions.length > 0
                      ? `<div class="notification-actions">${actions
                          .map(
                            (action) =>
                              `<button class="notification-action-btn" data-action="${action.id}">${action.label}</button>`
                          )
                          .join("")}</div>`
                      : ""
                  }
              `;

          // Add event listeners
          const closeBtn = notification.querySelector(".notification-close");
          if (closeBtn) {
            closeBtn.addEventListener("click", () => this.hide(id));
          }

          // Add action listeners
          const actionBtns = notification.querySelectorAll(
            ".notification-action-btn"
          );
          actionBtns.forEach((btn) => {
            btn.addEventListener("click", (e) => {
              const actionId = e.target.dataset.action;
              const action = actions.find((a) => a.id === actionId);
              if (action && action.handler) {
                action.handler();
              }
              if (!action.keepOpen) {
                this.hide(id);
              }
            });
          });

          return notification;
        }

        hide(id) {
          try {
            const notification = this.notifications.get(id);
            if (!notification) return;

            // Clear timeout
            if (notification.timeout) {
              clearTimeout(notification.timeout);
            }

            // Hide with animation
            notification.element.classList.remove("show");

            // Remove from DOM after animation
            setTimeout(() => {
              if (notification.element.parentNode) {
                notification.element.parentNode.removeChild(
                  notification.element
                );
              }
              this.notifications.delete(id);
            }, 300);
          } catch (error) {
            console.error("Failed to hide notification:", error);
          }
        }

        hideAll() {
          try {
            const ids = Array.from(this.notifications.keys());
            ids.forEach((id) => this.hide(id));
          } catch (error) {
            console.error("Failed to hide all notifications:", error);
          }
        }

        limitNotifications() {
          try {
            const notifications = Array.from(this.notifications.entries());
            if (notifications.length > this.maxNotifications) {
              const oldestId = notifications[0][0];
              this.hide(oldestId);
            }
          } catch (error) {
            console.error("Failed to limit notifications:", error);
          }
        }

        // Convenience methods
        error(title, message, options = {}) {
          return this.show("error", title, message, options);
        }

        success(title, message, options = {}) {
          return this.show("success", title, message, options);
        }

        warning(title, message, options = {}) {
          return this.show("warning", title, message, options);
        }

        info(title, message, options = {}) {
          return this.show("info", title, message, options);
        }
      }

      class LoadingManager {
        constructor() {
          this.loadingOverlay = null;
          this.isLoading = false;
          this.loadingQueue = [];
        }

        show(message, subtext = "") {
          try {
            if (this.isLoading) {
              // Update existing loading message
              this.updateMessage(message, subtext);
              return;
            }

            this.isLoading = true;

            // Create loading overlay
            this.loadingOverlay = document.createElement("div");
            this.loadingOverlay.className = "loading-overlay";
            this.loadingOverlay.innerHTML = `
                      <div class="loading-content">
                          <div class="loading-spinner"></div>
                          <div class="loading-text">${message}</div>
                          ${
                            subtext
                              ? `<div class="loading-subtext">${subtext}</div>`
                              : ""
                          }
                      </div>
                  `;

            // Add to DOM
            document.body.appendChild(this.loadingOverlay);

            // Prevent body scroll
            document.body.style.overflow = "hidden";

            console.log("Loading overlay shown:", message);
          } catch (error) {
            console.error("Failed to show loading overlay:", error);
          }
        }

        updateMessage(message, subtext = "") {
          try {
            if (!this.loadingOverlay) return;

            const textElement =
              this.loadingOverlay.querySelector(".loading-text");
            const subtextElement =
              this.loadingOverlay.querySelector(".loading-subtext");

            if (textElement) {
              textElement.textContent = message;
            }

            if (subtextElement) {
              subtextElement.textContent = subtext;
            } else if (subtext) {
              const loadingContent =
                this.loadingOverlay.querySelector(".loading-content");
              const subtextDiv = document.createElement("div");
              subtextDiv.className = "loading-subtext";
              subtextDiv.textContent = subtext;
              loadingContent.appendChild(subtextDiv);
            }
          } catch (error) {
            console.error("Failed to update loading message:", error);
          }
        }

        hide() {
          try {
            if (!this.isLoading || !this.loadingOverlay) return;

            this.isLoading = false;

            // Remove from DOM
            if (this.loadingOverlay.parentNode) {
              this.loadingOverlay.parentNode.removeChild(this.loadingOverlay);
            }

            this.loadingOverlay = null;

            // Restore body scroll
            document.body.style.overflow = "";

            console.log("Loading overlay hidden");
          } catch (error) {
            console.error("Failed to hide loading overlay:", error);
          }
        }
      }

      class ErrorBoundary {
        constructor() {
          this.errorHandlers = new Map();
          this.globalErrorHandler = null;
          this.setupGlobalErrorHandling();
        }

        setupGlobalErrorHandling() {
          // Handle uncaught JavaScript errors
          window.addEventListener("error", (event) => {
            this.handleGlobalError({
              message: event.message,
              filename: event.filename,
              lineno: event.lineno,
              colno: event.colno,
              error: event.error,
            });
          });

          // Handle unhandled promise rejections
          window.addEventListener("unhandledrejection", (event) => {
            this.handleGlobalError({
              message: "Unhandled Promise Rejection",
              error: event.reason,
            });
          });
        }

        handleGlobalError(errorInfo) {
          try {
            console.error("Global error caught:", errorInfo);

            // Show user-friendly error message
            notificationManager.error(
              "Application Error",
              "An unexpected error occurred. The application will continue to work, but some features may be affected.",
              {
                duration: 10000,
                actions: [
                  {
                    id: "reload",
                    label: "Reload Page",
                    handler: () => window.location.reload(),
                  },
                ],
              }
            );

            // Call custom global error handler if set
            if (this.globalErrorHandler) {
              this.globalErrorHandler(errorInfo);
            }
          } catch (error) {
            console.error("Failed to handle global error:", error);
          }
        }

        setGlobalErrorHandler(handler) {
          this.globalErrorHandler = handler;
        }

        wrapFunction(fn, context = "Unknown") {
          return (...args) => {
            try {
              return fn.apply(this, args);
            } catch (error) {
              this.handleError(error, context);
              throw error;
            }
          };
        }

        wrapAsyncFunction(fn, context = "Unknown") {
          return async (...args) => {
            try {
              return await fn.apply(this, args);
            } catch (error) {
              this.handleError(error, context);
              throw error;
            }
          };
        }

        handleError(error, context = "Unknown") {
          try {
            console.error(`Error in ${context}:`, error);

            // Get or create error handler for this context
            const handler = this.errorHandlers.get(context);
            if (handler) {
              handler(error);
            } else {
              // Default error handling
              this.showDefaultError(error, context);
            }
          } catch (handlingError) {
            console.error("Failed to handle error:", handlingError);
          }
        }

        showDefaultError(error, context) {
          const userFriendlyMessage = this.getUserFriendlyMessage(
            error,
            context
          );

          notificationManager.error("Operation Failed", userFriendlyMessage, {
            duration: 8000,
            actions: [
              {
                id: "retry",
                label: "Try Again",
                handler: () => {
                  // Emit retry event
                  stateEvents.emit("errorRetry", { error, context });
                },
              },
            ],
          });
        }

        getUserFriendlyMessage(error, context) {
          // Map technical errors to user-friendly messages
          const errorMessages = {
            NetworkError:
              "Network connection failed. Please check your internet connection.",
            TypeError:
              "Invalid data format. Please refresh the page and try again.",
            ReferenceError: "Missing required data. Please refresh the page.",
            SyntaxError: "Data format error. Please try again.",
            SecurityError:
              "Security restriction. Please check your browser settings.",
            QuotaExceededError:
              "Storage limit exceeded. Please clear browser data.",
            NotAllowedError:
              "Permission denied. Please check browser permissions.",
            AbortError: "Operation was cancelled. Please try again.",
            TimeoutError: "Operation timed out. Please try again.",
            ValidationError: "Invalid input data. Please check your entries.",
          };

          const errorType = error.constructor.name;
          const contextMessages = {
            ImageLoad:
              "Failed to load image. Please try a different image or check your connection.",
            FontLoad: "Failed to load font. Using fallback font instead.",
            Export:
              "Failed to export background. Please try again or use a different browser.",
            Upload:
              "Failed to upload file. Please check the file format and size.",
            StateUpdate:
              "Failed to save changes. Your changes may not be preserved.",
            AssetLoad: "Failed to load assets. Please refresh the page.",
          };

          return (
            contextMessages[context] ||
            errorMessages[errorType] ||
            error.message ||
            "An unexpected error occurred. Please try again."
          );
        }

        registerErrorHandler(context, handler) {
          this.errorHandlers.set(context, handler);
        }

        removeErrorHandler(context) {
          this.errorHandlers.delete(context);
        }
      }

      class FormValidator {
        constructor() {
          this.validators = new Map();
          this.errorElements = new Map();
        }

        registerField(fieldId, validationRules) {
          this.validators.set(fieldId, validationRules);

          const field = document.getElementById(fieldId);
          if (field) {
            // Add real-time validation
            field.addEventListener("blur", () => this.validateField(fieldId));
            field.addEventListener("input", () =>
              this.clearFieldError(fieldId)
            );
          }
        }

        validateField(fieldId) {
          try {
            const field = document.getElementById(fieldId);
            const rules = this.validators.get(fieldId);

            if (!field || !rules) return true;

            const value = field.value.trim();

            // Clear previous errors
            this.clearFieldError(fieldId);

            // Run validation rules
            for (const rule of rules) {
              const result = rule.validator(value, field);
              if (!result.valid) {
                this.showFieldError(fieldId, result.message);
                return false;
              }
            }

            return true;
          } catch (error) {
            console.error("Field validation error:", error);
            return false;
          }
        }

        validateForm(formId) {
          try {
            const form = document.getElementById(formId);
            if (!form) return true;

            let isValid = true;
            const fields = form.querySelectorAll("input, select, textarea");

            fields.forEach((field) => {
              if (this.validators.has(field.id)) {
                const fieldValid = this.validateField(field.id);
                if (!fieldValid) {
                  isValid = false;
                }
              }
            });

            return isValid;
          } catch (error) {
            console.error("Form validation error:", error);
            return false;
          }
        }

        showFieldError(fieldId, message) {
          try {
            const field = document.getElementById(fieldId);
            if (!field) return;

            // Add error class to field
            field.classList.add("form-field-error");

            // Create or update error message
            let errorElement = this.errorElements.get(fieldId);
            if (!errorElement) {
              errorElement = document.createElement("span");
              errorElement.className = "field-error-message";
              errorElement.setAttribute("role", "alert");

              // Insert after field
              field.parentNode.insertBefore(errorElement, field.nextSibling);
              this.errorElements.set(fieldId, errorElement);
            }

            errorElement.innerHTML = `<span class="field-error-icon">⚠️</span>${message}`;
            errorElement.style.display = "block";
          } catch (error) {
            console.error("Failed to show field error:", error);
          }
        }

        clearFieldError(fieldId) {
          try {
            const field = document.getElementById(fieldId);
            if (field) {
              field.classList.remove("form-field-error");
            }

            const errorElement = this.errorElements.get(fieldId);
            if (errorElement) {
              errorElement.style.display = "none";
            }
          } catch (error) {
            console.error("Failed to clear field error:", error);
          }
        }

        clearAllErrors() {
          try {
            this.errorElements.forEach((errorElement, fieldId) => {
              this.clearFieldError(fieldId);
            });
          } catch (error) {
            console.error("Failed to clear all errors:", error);
          }
        }
      }

      // Global instances
      const notificationManager = new NotificationManager();
      const loadingManager = new LoadingManager();
      const errorBoundary = new ErrorBoundary();
      const formValidator = new FormValidator();

      // Initialize error handling and form validation
      function initializeErrorHandling() {
        try {
          console.log(
            "Initializing error handling and user feedback systems..."
          );

          // Set up form validation rules
          formValidator.registerField("fullName", [
            {
              validator: (value) => ({
                valid: value.trim().length > 0,
                message: "Full name is required",
              }),
            },
            {
              validator: (value) => ({
                valid: value.length <= 100,
                message: "Full name must be 100 characters or less",
              }),
            },
          ]);

          formValidator.registerField("nickname", [
            {
              validator: (value) => ({
                valid: value.trim().length > 0,
                message: "Nickname is required",
              }),
            },
            {
              validator: (value) => ({
                valid: value.length <= 50,
                message: "Nickname must be 50 characters or less",
              }),
            },
          ]);

          formValidator.registerField("positionEn", [
            {
              validator: (value) => ({
                valid: value.trim().length > 0,
                message: "English position is required",
              }),
            },
            {
              validator: (value) => ({
                valid: value.length <= 100,
                message: "English position must be 100 characters or less",
              }),
            },
          ]);

          formValidator.registerField("positionJp", [
            {
              validator: (value) => ({
                valid: value.trim().length > 0,
                message: "Japanese position is required",
              }),
            },
            {
              validator: (value) => ({
                valid: value.length <= 100,
                message: "Japanese position must be 100 characters or less",
              }),
            },
          ]);

          // Set up error handlers for specific contexts
          errorBoundary.registerErrorHandler("FontLoad", (error) => {
            notificationManager.warning(
              "Font Loading Issue",
              "Some fonts may not display correctly. Using fallback fonts.",
              { duration: 4000 }
            );
          });

          errorBoundary.registerErrorHandler("AssetLoad", (error) => {
            notificationManager.error(
              "Asset Loading Failed",
              "Failed to load some images. Please refresh the page or check your connection.",
              {
                duration: 6000,
                actions: [
                  {
                    id: "refresh",
                    label: "Refresh Page",
                    handler: () => window.location.reload(),
                  },
                ],
              }
            );
          });

          errorBoundary.registerErrorHandler("PreviewUpdate", (error) => {
            notificationManager.warning(
              "Preview Update Failed",
              "The preview may not reflect your latest changes. Try refreshing the page.",
              { duration: 4000 }
            );
          });

          // Set up retry handlers
          stateEvents.on("errorRetry", (data) => {
            console.log("Retry requested for context:", data.context);

            switch (data.context) {
              case "Export":
                // Retry export
                const exportBtn = document.getElementById("export-btn");
                if (exportBtn && !exportBtn.disabled) {
                  exportBtn.click();
                }
                break;
              case "AssetLoad":
                // Refresh asset galleries
                if (window.assetManager) {
                  window.assetManager.loadLogos();
                  window.assetManager.loadBackgrounds();
                }
                break;
              case "PreviewUpdate":
                // Retry preview update
                if (window.updatePreview) {
                  window.updatePreview();
                }
                break;
            }
          });

          // Add mobile detection for better error handling
          const isMobile =
            /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
              navigator.userAgent
            );
          if (isMobile) {
            document.body.classList.add("mobile-optimized");

            // Show mobile-specific guidance
            setTimeout(() => {
              notificationManager.info(
                "Mobile Device Detected",
                "For the best experience, use landscape orientation when exporting.",
                { duration: 6000 }
              );
            }, 2000);
          }

          // Check for required browser features
          if (!window.FileReader) {
            notificationManager.error(
              "Browser Not Supported",
              "Your browser does not support file uploads. Please use a modern browser.",
              { persistent: true }
            );
          }

          if (!document.createElement("canvas").getContext) {
            notificationManager.error(
              "Canvas Not Supported",
              "Your browser does not support canvas. Export functionality will not work.",
              { persistent: true }
            );
          }

          if (typeof html2canvas === "undefined") {
            notificationManager.error(
              "Export Library Missing",
              "Export functionality is not available. Please refresh the page.",
              {
                persistent: true,
                actions: [
                  {
                    id: "refresh",
                    label: "Refresh Page",
                    handler: () => window.location.reload(),
                  },
                ],
              }
            );
          }

          console.log(
            "Error handling and user feedback systems initialized successfully"
          );
        } catch (error) {
          console.error("Failed to initialize error handling:", error);
          // Fallback error display
          alert(
            "Failed to initialize error handling system. Some features may not work properly."
          );
        }
      }

      // Enhanced preview update function with error handling
      function safeUpdatePreview() {
        try {
          if (window.updatePreview) {
            window.updatePreview();
          }
        } catch (error) {
          console.error("Preview update failed:", error);
          errorBoundary.handleError(error, "PreviewUpdate");
        }
      }

      // Enhanced state update with validation
      function safeUpdateAppState(path, value, options = {}) {
        try {
          // Validate form if updating text fields
          if (path.startsWith("text.fields.")) {
            const fieldId = path.split(".").pop();
            if (!formValidator.validateField(fieldId)) {
              throw new Error(`Invalid value for ${fieldId}`);
            }
          }

          return updateAppState(path, value, options);
        } catch (error) {
          console.error("Safe state update failed:", error);
          errorBoundary.handleError(error, "StateUpdate");
          throw error;
        }
      }

      // State Validation Rules
      const stateValidators = {
        "layout.type": (value) => {
          const validLayouts = ["layout1", "layout2"];
          if (!validLayouts.includes(value)) {
            throw new Error(
              `Invalid layout type: ${value}. Must be one of: ${validLayouts.join(
                ", "
              )}`
            );
          }
          return true;
        },

        "text.fields.fullName": (value) => {
          if (typeof value !== "string") {
            throw new Error("Full name must be a string");
          }
          if (value.length > 100) {
            throw new Error("Full name must be 100 characters or less");
          }
          return true;
        },

        "text.fields.nickname": (value) => {
          if (typeof value !== "string") {
            throw new Error("Nickname must be a string");
          }
          if (value.length > 50) {
            throw new Error("Nickname must be 50 characters or less");
          }
          return true;
        },

        "text.fields.positionEn": (value) => {
          if (typeof value !== "string") {
            throw new Error("English position must be a string");
          }
          if (value.length > 100) {
            throw new Error("English position must be 100 characters or less");
          }
          return true;
        },

        "text.fields.positionJp": (value) => {
          if (typeof value !== "string") {
            throw new Error("Japanese position must be a string");
          }
          if (value.length > 100) {
            throw new Error("Japanese position must be 100 characters or less");
          }
          return true;
        },

        "text.typography.japaneseFont": (value) => {
          const validFonts = [
            "Noto Sans JP",
            "Hiragino Sans",
            "Yu Gothic",
            "Meiryo",
            "Aoboshi One",
            "Kaisei Decol",
          ];
          if (!validFonts.includes(value)) {
            throw new Error(
              `Invalid Japanese font: ${value}. Must be one of: ${validFonts.join(
                ", "
              )}`
            );
          }
          return true;
        },

        "text.typography.englishFont": (value) => {
          const validFonts = [
            "Roboto",
            "Open Sans",
            "Lato",
            "Montserrat",
            "Arial",
            "Times New Roman",
          ];
          if (!validFonts.includes(value)) {
            throw new Error(
              `Invalid English font: ${value}. Must be one of: ${validFonts.join(
                ", "
              )}`
            );
          }
          return true;
        },

        "text.typography.fontSize": (value) => {
          const size = Number(value);
          if (isNaN(size) || size < 12 || size > 24) {
            throw new Error("Font size must be a number between 12 and 24");
          }
          return true;
        },

        "text.typography.textColor": (value) => {
          const validColors = ["white", "black"];
          if (!validColors.includes(value)) {
            throw new Error(
              `Invalid text color: ${value}. Must be one of: ${validColors.join(
                ", "
              )}`
            );
          }
          return true;
        },

        "text.positioning.layout1": (value) => {
          const validPositions = ["top-right", "middle-right", "bottom-right"];
          if (!validPositions.includes(value)) {
            throw new Error(
              `Invalid layout1 position: ${value}. Must be one of: ${validPositions.join(
                ", "
              )}`
            );
          }
          return true;
        },

        "text.positioning.layout2": (value) => {
          const validPositions = [
            "top-right",
            "middle-right",
            "bottom-right",
            "bottom-left",
          ];
          if (!validPositions.includes(value)) {
            throw new Error(
              `Invalid layout2 position: ${value}. Must be one of: ${validPositions.join(
                ", "
              )}`
            );
          }
          return true;
        },

        "export.quality": (value) => {
          const quality = Number(value);
          if (isNaN(quality) || quality < 0.1 || quality > 1.0) {
            throw new Error(
              "Export quality must be a number between 0.1 and 1.0"
            );
          }
          return true;
        },

        "layout.overlay.opacity": (value) => {
          const opacity = Number(value);
          if (isNaN(opacity) || opacity < 0 || opacity > 100) {
            throw new Error(
              "Overlay opacity must be a number between 0 and 100"
            );
          }
          return true;
        },

        "layout.overlay.size": (value) => {
          const size = Number(value);
          if (isNaN(size) || size < 20 || size > 80) {
            throw new Error("Overlay size must be a number between 20 and 80");
          }
          return true;
        },
      };

      // State Management Functions
      function validateStateValue(path, value) {
        const validator = stateValidators[path];
        if (validator) {
          return validator(value);
        }
        return true;
      }

      function updateAppState(path, value, options = {}) {
        try {
          // Validate the new value
          if (!options.skipValidation) {
            validateStateValue(path, value);
          }

          // Get the old value for comparison
          const oldValue = getAppState(path);

          // Update the state
          const keys = path.split(".");
          let current = appState;

          for (let i = 0; i < keys.length - 1; i++) {
            if (!current[keys[i]]) {
              current[keys[i]] = {};
            }
            current = current[keys[i]];
          }

          current[keys[keys.length - 1]] = value;

          // Emit state change event if value actually changed
          if (oldValue !== value) {
            stateEvents.emit("stateChange", {
              path: path,
              oldValue: oldValue,
              newValue: value,
              timestamp: Date.now(),
            });

            // Emit specific path change event
            stateEvents.emit(`stateChange:${path}`, {
              oldValue: oldValue,
              newValue: value,
              timestamp: Date.now(),
            });
          }

          // Auto-save state if enabled
          if (!options.skipPersistence) {
            saveStateToStorage();
          }

          console.log("App state updated:", path, value);
          return true;
        } catch (error) {
          console.error("Failed to update app state:", error.message);

          // Show user-friendly error notification
          notificationManager.error(
            "Settings Update Failed",
            errorBoundary.getUserFriendlyMessage(error, "StateUpdate"),
            { duration: 5000 }
          );

          throw error;
        }
      }

      function getAppState(path) {
        try {
          if (!path) {
            return { ...appState }; // Return a copy of the entire state
          }

          const keys = path.split(".");
          let current = appState;

          for (const key of keys) {
            if (current === null || current === undefined) {
              return undefined;
            }
            current = current[key];
          }

          return current;
        } catch (error) {
          console.error("Failed to get app state:", error.message);
          return undefined;
        }
      }

      function resetAppState() {
        try {
          // Reset to default values
          const defaultState = {
            layout: {
              type: "layout1",
              dimensions: { width: 1920, height: 1080 },
            },
            text: {
              fields: {
                fullName: "John Smith",
                nickname: "ジョン",
                positionEn: "Senior Data Analyst",
                positionJp: "シニアデータアナリスト",
              },
              typography: {
                japaneseFont: "Noto Sans JP",
                englishFont: "Roboto",
                fontSize: 18,
                textColor: "white",
              },
              positioning: {
                layout1: "top-right",
                layout2: "top-right",
              },
            },
            assets: {
              selectedLogo: "logo/no-bg-logo-1.png",
              selectedBackground: null,
              customBackground: null,
              logoScale: 1.0,
            },
            export: {
              filename: "",
              quality: 1.0,
            },
          };

          // Update each property to trigger events
          Object.keys(defaultState).forEach((key) => {
            appState[key] = defaultState[key];
          });

          // Emit reset event
          stateEvents.emit("stateReset", {
            timestamp: Date.now(),
          });

          // Save to storage
          saveStateToStorage();

          console.log("App state reset to defaults");
          return true;
        } catch (error) {
          console.error("Failed to reset app state:", error.message);
          return false;
        }
      }

      // State Persistence Functions
      function saveStateToStorage() {
        try {
          const stateJson = JSON.stringify(appState);
          localStorage.setItem("ddamBackgroundGenerator_state", stateJson);
          console.log("State saved to localStorage");
          return true;
        } catch (error) {
          console.error("Failed to save state to localStorage:", error.message);
          return false;
        }
      }

      function loadStateFromStorage() {
        try {
          const stateJson = localStorage.getItem(
            "ddamBackgroundGenerator_state"
          );
          if (!stateJson) {
            console.log("No saved state found in localStorage");
            return false;
          }

          const savedState = JSON.parse(stateJson);

          // Validate and merge saved state with current state
          Object.keys(savedState).forEach((key) => {
            if (appState.hasOwnProperty(key)) {
              appState[key] = { ...appState[key], ...savedState[key] };
            }
          });

          // Emit state loaded event
          stateEvents.emit("stateLoaded", {
            timestamp: Date.now(),
          });

          console.log("State loaded from localStorage");
          return true;
        } catch (error) {
          console.error(
            "Failed to load state from localStorage:",
            error.message
          );
          return false;
        }
      }

      function clearStoredState() {
        try {
          localStorage.removeItem("ddamBackgroundGenerator_state");
          console.log("Stored state cleared");
          return true;
        } catch (error) {
          console.error("Failed to clear stored state:", error.message);
          return false;
        }
      }

      // Cross-Browser Compatibility and Testing System
      class BrowserCompatibilityManager {
        constructor() {
          this.browserInfo = this.detectBrowser();
          this.supportedFeatures = new Map();
          this.fallbacks = new Map();
          this.testResults = new Map();
          this.initializeFallbacks();
        }

        detectBrowser() {
          const userAgent = navigator.userAgent;
          const browserInfo = {
            name: "Unknown",
            version: "Unknown",
            engine: "Unknown",
            mobile:
              /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                userAgent
              ),
            platform: navigator.platform,
          };

          // Detect browser
          if (userAgent.includes("Chrome") && !userAgent.includes("Edg")) {
            browserInfo.name = "Chrome";
            browserInfo.version =
              userAgent.match(/Chrome\/(\d+)/)?.[1] || "Unknown";
            browserInfo.engine = "Blink";
          } else if (userAgent.includes("Firefox")) {
            browserInfo.name = "Firefox";
            browserInfo.version =
              userAgent.match(/Firefox\/(\d+)/)?.[1] || "Unknown";
            browserInfo.engine = "Gecko";
          } else if (
            userAgent.includes("Safari") &&
            !userAgent.includes("Chrome")
          ) {
            browserInfo.name = "Safari";
            browserInfo.version =
              userAgent.match(/Version\/(\d+)/)?.[1] || "Unknown";
            browserInfo.engine = "WebKit";
          } else if (userAgent.includes("Edg")) {
            browserInfo.name = "Edge";
            browserInfo.version =
              userAgent.match(/Edg\/(\d+)/)?.[1] || "Unknown";
            browserInfo.engine = "Blink";
          } else if (
            userAgent.includes("MSIE") ||
            userAgent.includes("Trident")
          ) {
            browserInfo.name = "Internet Explorer";
            browserInfo.version =
              userAgent.match(/(?:MSIE |rv:)(\d+)/)?.[1] || "Unknown";
            browserInfo.engine = "Trident";
          }

          return browserInfo;
        }

        initializeFallbacks() {
          // CSS Feature Fallbacks
          this.fallbacks.set("backdrop-filter", () => {
            // Fallback for browsers that don't support backdrop-filter
            const style = document.createElement("style");
            style.textContent = `
                      .notification:not(.backdrop-filter-supported) {
                          background: rgba(220, 53, 69, 0.95) !important;
                      }
                      .notification.success:not(.backdrop-filter-supported) {
                          background: rgba(40, 167, 69, 0.95) !important;
                      }
                      .notification.warning:not(.backdrop-filter-supported) {
                          background: rgba(255, 193, 7, 0.95) !important;
                      }
                      .notification.info:not(.backdrop-filter-supported) {
                          background: rgba(23, 162, 184, 0.95) !important;
                      }
                      .asset-selector:not(.backdrop-filter-supported),
                      .layout-selector:not(.backdrop-filter-supported) {
                          background: rgba(255, 255, 255, 0.95) !important;
                      }
                  `;
            document.head.appendChild(style);
          });

          // Font Loading Fallbacks
          this.fallbacks.set("font-loading", () => {
            // Fallback font stack for Japanese text
            const style = document.createElement("style");
            style.textContent = `
                      .font-fallback-jp {
                          font-family: "Hiragino Sans", "ヒラギノ角ゴシック", "Yu Gothic", "游ゴシック", "Meiryo", "メイリオ", sans-serif !important;
                      }
                      .font-fallback-en {
                          font-family: Arial, Helvetica, sans-serif !important;
                      }
                  `;
            document.head.appendChild(style);
          });

          // Canvas Fallbacks
          this.fallbacks.set("canvas", () => {
            // Show error message if canvas is not supported
            notificationManager.error(
              "Canvas Not Supported",
              "Your browser does not support HTML5 Canvas. Export functionality will not work.",
              { persistent: true }
            );
          });

          // File API Fallbacks
          this.fallbacks.set("file-api", () => {
            // Hide upload functionality if File API is not supported
            const uploadAreas = document.querySelectorAll(".upload-area");
            uploadAreas.forEach((area) => {
              area.style.display = "none";
            });

            notificationManager.warning(
              "File Upload Not Supported",
              "Your browser does not support file uploads. You can only use pre-loaded backgrounds.",
              { duration: 8000 }
            );
          });

          // HTML2Canvas Fallbacks
          this.fallbacks.set("html2canvas", () => {
            // Disable export functionality
            const exportBtn = document.getElementById("export-btn");
            if (exportBtn) {
              exportBtn.disabled = true;
              exportBtn.textContent = "Export Not Available";
              exportBtn.title = "Export library failed to load";
            }

            notificationManager.error(
              "Export Library Failed",
              "The export library could not be loaded. Export functionality is not available.",
              { persistent: true }
            );
          });
        }

        async testBrowserFeatures() {
          console.log("Testing browser features for compatibility...");
          const results = new Map();

          try {
            // Test CSS Features
            results.set("css-grid", this.testCSSFeature("display", "grid"));
            results.set("css-flexbox", this.testCSSFeature("display", "flex"));
            results.set(
              "css-backdrop-filter",
              this.testCSSFeature("backdrop-filter", "blur(5px)")
            );
            results.set(
              "css-transforms",
              this.testCSSFeature("transform", "translateX(0)")
            );
            results.set(
              "css-transitions",
              this.testCSSFeature("transition", "all 0.3s ease")
            );
            results.set(
              "css-custom-properties",
              this.testCSSCustomProperties()
            );

            // Test JavaScript Features
            results.set("es6-classes", this.testES6Classes());
            results.set("es6-arrow-functions", this.testArrowFunctions());
            results.set("es6-template-literals", this.testTemplateLiterals());
            results.set("es6-destructuring", this.testDestructuring());
            results.set("async-await", this.testAsyncAwait());
            results.set("fetch-api", this.testFetchAPI());

            // Test Web APIs
            results.set("canvas-api", this.testCanvasAPI());
            results.set("file-api", this.testFileAPI());
            results.set("local-storage", this.testLocalStorage());
            results.set("event-listeners", this.testEventListeners());

            // Test Font Loading
            results.set("font-loading-api", this.testFontLoadingAPI());
            results.set("google-fonts", await this.testGoogleFonts());

            // Test HTML2Canvas
            results.set("html2canvas", this.testHTML2Canvas());

            // Store results
            this.testResults = results;

            // Apply fallbacks for unsupported features
            this.applyFallbacks(results);

            // Log results
            this.logTestResults(results);

            return results;
          } catch (error) {
            console.error("Browser feature testing failed:", error);
            return results;
          }
        }

        testCSSFeature(property, value) {
          try {
            const element = document.createElement("div");
            element.style[property] = value;
            return element.style[property] === value;
          } catch (error) {
            return false;
          }
        }

        testCSSCustomProperties() {
          try {
            const element = document.createElement("div");
            element.style.setProperty("--test-prop", "test");
            return element.style.getPropertyValue("--test-prop") === "test";
          } catch (error) {
            return false;
          }
        }

        testES6Classes() {
          try {
            eval("class TestClass {}");
            return true;
          } catch (error) {
            return false;
          }
        }

        testArrowFunctions() {
          try {
            eval("(() => {})");
            return true;
          } catch (error) {
            return false;
          }
        }

        testTemplateLiterals() {
          try {
            eval("`template ${1} literal`");
            return true;
          } catch (error) {
            return false;
          }
        }

        testDestructuring() {
          try {
            eval("const {a} = {a: 1}");
            return true;
          } catch (error) {
            return false;
          }
        }

        testAsyncAwait() {
          try {
            eval("async function test() { await Promise.resolve(); }");
            return true;
          } catch (error) {
            return false;
          }
        }

        testFetchAPI() {
          return typeof fetch !== "undefined";
        }

        testCanvasAPI() {
          try {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            return ctx !== null;
          } catch (error) {
            return false;
          }
        }

        testFileAPI() {
          return (
            typeof FileReader !== "undefined" &&
            typeof File !== "undefined" &&
            typeof Blob !== "undefined"
          );
        }

        testLocalStorage() {
          try {
            const testKey = "__test_localStorage__";
            localStorage.setItem(testKey, "test");
            const result = localStorage.getItem(testKey) === "test";
            localStorage.removeItem(testKey);
            return result;
          } catch (error) {
            return false;
          }
        }

        testEventListeners() {
          try {
            const element = document.createElement("div");
            const handler = () => {};
            element.addEventListener("test", handler);
            element.removeEventListener("test", handler);
            return true;
          } catch (error) {
            return false;
          }
        }

        testFontLoadingAPI() {
          return (
            typeof document.fonts !== "undefined" &&
            typeof document.fonts.load === "function"
          );
        }

        async testGoogleFonts() {
          try {
            // Test if Google Fonts are loading
            const testFonts = [
              "Roboto",
              "Noto Sans JP",
              "Open Sans",
              "Lato",
              "Montserrat",
            ];

            const fontTests = testFonts.map(async (fontFamily) => {
              try {
                if (document.fonts && document.fonts.check) {
                  return document.fonts.check(`16px "${fontFamily}"`);
                } else {
                  // Fallback test using canvas
                  return this.testFontWithCanvas(fontFamily);
                }
              } catch (error) {
                return false;
              }
            });

            const results = await Promise.all(fontTests);
            return results.some((result) => result === true);
          } catch (error) {
            console.error("Google Fonts test failed:", error);
            return false;
          }
        }

        testFontWithCanvas(fontFamily) {
          try {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");

            // Test text with default font
            ctx.font = "16px serif";
            const defaultWidth = ctx.measureText("Test").width;

            // Test text with target font
            ctx.font = `16px "${fontFamily}", serif`;
            const testWidth = ctx.measureText("Test").width;

            // If widths are different, font is likely loaded
            return Math.abs(defaultWidth - testWidth) > 1;
          } catch (error) {
            return false;
          }
        }

        testHTML2Canvas() {
          return typeof html2canvas !== "undefined";
        }

        applyFallbacks(results) {
          try {
            // Apply CSS fallbacks
            if (!results.get("css-backdrop-filter")) {
              this.fallbacks.get("backdrop-filter")();
              document.body.classList.add("no-backdrop-filter");
            } else {
              document.body.classList.add("backdrop-filter-supported");
            }

            // Apply font fallbacks
            if (
              !results.get("google-fonts") ||
              !results.get("font-loading-api")
            ) {
              this.fallbacks.get("font-loading")();
              document.body.classList.add("font-fallback");
            }

            // Apply Canvas fallbacks
            if (!results.get("canvas-api")) {
              this.fallbacks.get("canvas")();
              document.body.classList.add("no-canvas");
            }

            // Apply File API fallbacks
            if (!results.get("file-api")) {
              this.fallbacks.get("file-api")();
              document.body.classList.add("no-file-api");
            }

            // Apply HTML2Canvas fallbacks
            if (!results.get("html2canvas")) {
              this.fallbacks.get("html2canvas")();
              document.body.classList.add("no-html2canvas");
            }

            // Browser-specific optimizations
            this.applyBrowserSpecificOptimizations();
          } catch (error) {
            console.error("Failed to apply fallbacks:", error);
          }
        }

        applyBrowserSpecificOptimizations() {
          try {
            const { name, version, mobile } = this.browserInfo;

            // Safari-specific optimizations
            if (name === "Safari") {
              document.body.classList.add("browser-safari");

              // Fix Safari font rendering issues
              const style = document.createElement("style");
              style.textContent = `
                          .browser-safari * {
                              -webkit-font-smoothing: antialiased;
                              -moz-osx-font-smoothing: grayscale;
                          }
                          .browser-safari .form-input,
                          .browser-safari .form-select {
                              -webkit-appearance: none;
                              border-radius: 4px;
                          }
                      `;
              document.head.appendChild(style);
            }

            // Firefox-specific optimizations
            if (name === "Firefox") {
              document.body.classList.add("browser-firefox");

              const style = document.createElement("style");
              style.textContent = `
                          .browser-firefox .form-range::-moz-range-track {
                              background: #e9ecef;
                              height: 6px;
                              border-radius: 3px;
                          }
                          .browser-firefox .form-range::-moz-range-thumb {
                              border: none;
                              border-radius: 50%;
                              background: #667eea;
                              width: 20px;
                              height: 20px;
                          }
                      `;
              document.head.appendChild(style);
            }

            // Edge-specific optimizations
            if (name === "Edge") {
              document.body.classList.add("browser-edge");
            }

            // Chrome-specific optimizations
            if (name === "Chrome") {
              document.body.classList.add("browser-chrome");
            }

            // Mobile-specific optimizations
            if (mobile) {
              document.body.classList.add("mobile-device");

              // Improve mobile performance
              const style = document.createElement("style");
              style.textContent = `
                          .mobile-device * {
                              -webkit-tap-highlight-color: transparent;
                          }
                          .mobile-device .preview-container {
                              transform: translateZ(0);
                              -webkit-transform: translateZ(0);
                          }
                      `;
              document.head.appendChild(style);
            }
          } catch (error) {
            console.error(
              "Failed to apply browser-specific optimizations:",
              error
            );
          }
        }

        logTestResults(results) {
          console.log("=== Browser Compatibility Test Results ===");
          console.log("Browser:", this.browserInfo);
          console.log("Feature Support:");

          const categories = {
            "CSS Features": [
              "css-grid",
              "css-flexbox",
              "css-backdrop-filter",
              "css-transforms",
              "css-transitions",
              "css-custom-properties",
            ],
            "JavaScript Features": [
              "es6-classes",
              "es6-arrow-functions",
              "es6-template-literals",
              "es6-destructuring",
              "async-await",
              "fetch-api",
            ],
            "Web APIs": [
              "canvas-api",
              "file-api",
              "local-storage",
              "event-listeners",
            ],
            "Font Loading": ["font-loading-api", "google-fonts"],
            "Export Features": ["html2canvas"],
          };

          Object.entries(categories).forEach(([category, features]) => {
            console.log(`\n${category}:`);
            features.forEach((feature) => {
              const supported = results.get(feature);
              const status = supported ? "✅" : "❌";
              console.log(`  ${status} ${feature}: ${supported}`);
            });
          });

          // Calculate overall compatibility score
          const totalFeatures = Array.from(results.values()).length;
          const supportedFeatures = Array.from(results.values()).filter(
            Boolean
          ).length;
          const compatibilityScore = Math.round(
            (supportedFeatures / totalFeatures) * 100
          );

          console.log(`\nOverall Compatibility Score: ${compatibilityScore}%`);

          // Show user notification about compatibility
          if (compatibilityScore < 80) {
            notificationManager.warning(
              "Limited Browser Support",
              `Your browser supports ${compatibilityScore}% of features. Some functionality may be limited.`,
              { duration: 8000 }
            );
          } else if (compatibilityScore < 100) {
            notificationManager.info(
              "Good Browser Support",
              `Your browser supports ${compatibilityScore}% of features. Most functionality should work well.`,
              { duration: 5000 }
            );
          }
        }

        getBrowserInfo() {
          return { ...this.browserInfo };
        }

        getTestResults() {
          return new Map(this.testResults);
        }

        isFeatureSupported(feature) {
          return this.testResults.get(feature) === true;
        }
      }

      // Font Loading Manager with Cross-Browser Support
      class FontLoadingManager {
        constructor() {
          this.loadedFonts = new Set();
          this.fontLoadPromises = new Map();
          this.fallbackFonts = new Map();
          this.initializeFallbacks();
        }

        initializeFallbacks() {
          // Define fallback fonts for each Google Font
          this.fallbackFonts.set("Noto Sans JP", [
            "Hiragino Sans",
            "Yu Gothic",
            "Meiryo",
            "sans-serif",
          ]);
          this.fallbackFonts.set("Roboto", [
            "Arial",
            "Helvetica",
            "sans-serif",
          ]);
          this.fallbackFonts.set("Open Sans", [
            "Arial",
            "Helvetica",
            "sans-serif",
          ]);
          this.fallbackFonts.set("Lato", ["Arial", "Helvetica", "sans-serif"]);
          this.fallbackFonts.set("Montserrat", [
            "Arial",
            "Helvetica",
            "sans-serif",
          ]);
          this.fallbackFonts.set("Aoboshi One", ["serif"]);
          this.fallbackFonts.set("Kaisei Decol", ["serif"]);
          this.fallbackFonts.set("Hiragino Sans", [
            "Yu Gothic",
            "Meiryo",
            "sans-serif",
          ]);
          this.fallbackFonts.set("Yu Gothic", ["Meiryo", "sans-serif"]);
          this.fallbackFonts.set("Meiryo", ["sans-serif"]);
        }

        async loadFont(fontFamily, options = {}) {
          try {
            // Check if font is already loaded
            if (this.loadedFonts.has(fontFamily)) {
              return true;
            }

            // Check if font loading is already in progress
            if (this.fontLoadPromises.has(fontFamily)) {
              return await this.fontLoadPromises.get(fontFamily);
            }

            // Create font loading promise
            const loadPromise = this.performFontLoad(fontFamily, options);
            this.fontLoadPromises.set(fontFamily, loadPromise);

            const result = await loadPromise;

            // Clean up promise
            this.fontLoadPromises.delete(fontFamily);

            if (result) {
              this.loadedFonts.add(fontFamily);
            }

            return result;
          } catch (error) {
            console.error(`Failed to load font ${fontFamily}:`, error);
            this.fontLoadPromises.delete(fontFamily);
            return false;
          }
        }

        async performFontLoad(fontFamily, options = {}) {
          const timeout = options.timeout || 5000;
          const weight = options.weight || "400";
          const style = options.style || "normal";

          try {
            // Method 1: Use Font Loading API if available
            if (document.fonts && document.fonts.load) {
              const fontSpec = `${weight} ${style} 16px "${fontFamily}"`;

              // Set timeout for font loading
              const timeoutPromise = new Promise((_, reject) => {
                setTimeout(
                  () => reject(new Error("Font loading timeout")),
                  timeout
                );
              });

              const loadPromise = document.fonts.load(fontSpec);

              await Promise.race([loadPromise, timeoutPromise]);

              // Verify font is actually loaded
              return document.fonts.check(fontSpec);
            }

            // Method 2: Fallback using canvas measurement
            return await this.loadFontWithCanvas(fontFamily, timeout);
          } catch (error) {
            console.warn(
              `Font loading method failed for ${fontFamily}:`,
              error.message
            );

            // Try fallback method
            try {
              return await this.loadFontWithCanvas(fontFamily, timeout);
            } catch (fallbackError) {
              console.error(
                `All font loading methods failed for ${fontFamily}:`,
                fallbackError.message
              );
              return false;
            }
          }
        }

        async loadFontWithCanvas(fontFamily, timeout = 5000) {
          return new Promise((resolve) => {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");

            // Measure text with fallback font
            ctx.font = "16px serif";
            const fallbackWidth = ctx.measureText("Test Font Loading").width;

            let attempts = 0;
            const maxAttempts = timeout / 100; // Check every 100ms

            const checkFont = () => {
              attempts++;

              // Measure text with target font
              ctx.font = `16px "${fontFamily}", serif`;
              const testWidth = ctx.measureText("Test Font Loading").width;

              // If width changed significantly, font is loaded
              if (Math.abs(testWidth - fallbackWidth) > 2) {
                resolve(true);
                return;
              }

              // If we've exceeded max attempts, give up
              if (attempts >= maxAttempts) {
                resolve(false);
                return;
              }

              // Try again in 100ms
              setTimeout(checkFont, 100);
            };

            // Start checking
            setTimeout(checkFont, 100);
          });
        }

        async loadAllGoogleFonts() {
          const googleFonts = [
            "Noto Sans JP",
            "Roboto",
            "Open Sans",
            "Lato",
            "Montserrat",
            "Aoboshi One",
            "Kaisei Decol",
          ];

          console.log("Loading Google Fonts...");

          const loadPromises = googleFonts.map(async (font) => {
            try {
              const loaded = await this.loadFont(font, { timeout: 8000 });
              console.log(`Font ${font}: ${loaded ? "loaded" : "failed"}`);
              return { font, loaded };
            } catch (error) {
              console.error(`Error loading font ${font}:`, error);
              return { font, loaded: false };
            }
          });

          const results = await Promise.all(loadPromises);

          // Report results
          const loadedCount = results.filter((r) => r.loaded).length;
          const totalCount = results.length;

          console.log(`Google Fonts loaded: ${loadedCount}/${totalCount}`);

          // Show notification if some fonts failed
          if (loadedCount < totalCount) {
            const failedFonts = results
              .filter((r) => !r.loaded)
              .map((r) => r.font);
            notificationManager.warning(
              "Some Fonts Failed to Load",
              `${failedFonts.length} fonts could not be loaded. Fallback fonts will be used.`,
              { duration: 6000 }
            );
          }

          return results;
        }

        getFontStack(primaryFont) {
          const fallbacks = this.fallbackFonts.get(primaryFont) || [
            "sans-serif",
          ];
          return [primaryFont, ...fallbacks]
            .map((font) => (font.includes(" ") ? `"${font}"` : font))
            .join(", ");
        }

        isFontLoaded(fontFamily) {
          return this.loadedFonts.has(fontFamily);
        }

        getLoadedFonts() {
          return Array.from(this.loadedFonts);
        }
      }

      // HTML2Canvas Compatibility Manager
      class HTML2CanvasManager {
        constructor() {
          this.isAvailable = typeof html2canvas !== "undefined";
          this.config = this.getOptimalConfig();
          this.browserSpecificFixes = new Map();
          this.initializeBrowserFixes();
        }

        getOptimalConfig() {
          const browserInfo = browserCompatibility.getBrowserInfo();

          const baseConfig = {
            allowTaint: true,
            useCORS: true,
            scale: 1,
            width: 1920,
            height: 1080,
            backgroundColor: null,
            logging: false,
            removeContainer: true,
          };

          // Browser-specific optimizations
          if (browserInfo.name === "Safari") {
            return {
              ...baseConfig,
              useCORS: false, // Safari has CORS issues
              allowTaint: true,
              foreignObjectRendering: false,
            };
          }

          if (browserInfo.name === "Firefox") {
            return {
              ...baseConfig,
              scrollX: 0,
              scrollY: 0,
              windowWidth: 1920,
              windowHeight: 1080,
            };
          }

          if (browserInfo.name === "Edge") {
            return {
              ...baseConfig,
              ignoreElements: (element) => {
                // Skip problematic elements in Edge
                return (
                  element.tagName === "IFRAME" ||
                  element.classList.contains("edge-skip")
                );
              },
            };
          }

          return baseConfig;
        }

        initializeBrowserFixes() {
          // Safari fixes
          this.browserSpecificFixes.set("Safari", (element) => {
            // Fix Safari font rendering
            const style = element.style;
            style.webkitFontSmoothing = "antialiased";
            style.mozOsxFontSmoothing = "grayscale";

            // Fix Safari transform issues
            if (style.transform) {
              style.webkitTransform = style.transform;
            }
          });

          // Firefox fixes
          this.browserSpecificFixes.set("Firefox", (element) => {
            // Fix Firefox canvas scaling
            if (element.tagName === "CANVAS") {
              element.style.imageRendering = "crisp-edges";
            }
          });

          // Edge fixes
          this.browserSpecificFixes.set("Edge", (element) => {
            // Fix Edge backdrop-filter issues
            if (element.style.backdropFilter) {
              element.style.backdropFilter = "none";
              element.style.background = element.style.background.replace(
                /rgba\(([^)]+)\)/,
                "rgba($1, 0.95)"
              );
            }
          });
        }

        async captureElement(element, options = {}) {
          if (!this.isAvailable) {
            throw new Error("HTML2Canvas is not available");
          }

          try {
            // Apply browser-specific fixes
            this.applyBrowserFixes(element);

            // Merge options with optimal config
            const config = { ...this.config, ...options };

            // Capture the element
            const canvas = await html2canvas(element, config);

            return canvas;
          } catch (error) {
            console.error("HTML2Canvas capture failed:", error);
            throw new Error(`Export failed: ${error.message}`);
          }
        }

        applyBrowserFixes(element) {
          const browserInfo = browserCompatibility.getBrowserInfo();
          const fixes = this.browserSpecificFixes.get(browserInfo.name);

          if (fixes) {
            // Apply fixes to element and its children
            fixes(element);
            element.querySelectorAll("*").forEach(fixes);
          }
        }

        async exportToPNG(element, filename, quality = 1.0) {
          try {
            const canvas = await this.captureElement(element, {
              backgroundColor: "#ffffff",
              scale: quality,
            });

            // Convert to blob
            return new Promise((resolve, reject) => {
              canvas.toBlob(
                (blob) => {
                  if (blob) {
                    // Create download link
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement("a");
                    link.href = url;
                    link.download = filename;

                    // Trigger download
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    // Clean up
                    setTimeout(() => URL.revokeObjectURL(url), 100);

                    resolve(blob);
                  } else {
                    reject(new Error("Failed to create image blob"));
                  }
                },
                "image/png",
                quality
              );
            });
          } catch (error) {
            console.error("PNG export failed:", error);
            throw error;
          }
        }

        isSupported() {
          return this.isAvailable;
        }

        getConfig() {
          return { ...this.config };
        }
      }

      // Initialize cross-browser compatibility
      const browserCompatibility = new BrowserCompatibilityManager();
      const fontLoadingManager = new FontLoadingManager();
      const html2canvasManager = new HTML2CanvasManager();

      // Comprehensive Browser Testing Function
      async function runComprehensiveBrowserTests() {
        console.log("=== COMPREHENSIVE BROWSER TESTING ===");

        const testResults = {
          browser: browserCompatibility.getBrowserInfo(),
          features: {},
          fonts: {},
          functionality: {},
          performance: {},
          errors: [],
        };

        try {
          // 1. Test Browser Features
          console.log("1. Testing browser features...");
          testResults.features = Object.fromEntries(
            await browserCompatibility.testBrowserFeatures()
          );

          // 2. Test Font Loading
          console.log("2. Testing font loading...");
          const fontTests = await fontLoadingManager.loadAllGoogleFonts();
          testResults.fonts = Object.fromEntries(
            fontTests.map((f) => [f.font, f.loaded])
          );

          // 3. Test HTML2Canvas
          console.log("3. Testing HTML2Canvas...");
          testResults.functionality.html2canvas =
            html2canvasManager.isSupported();

          if (testResults.functionality.html2canvas) {
            try {
              // Test canvas capture with a simple element
              const testDiv = document.createElement("div");
              testDiv.style.width = "100px";
              testDiv.style.height = "100px";
              testDiv.style.background = "#ff0000";
              testDiv.textContent = "Test";
              document.body.appendChild(testDiv);

              const canvas = await html2canvasManager.captureElement(testDiv);
              testResults.functionality.canvasCapture =
                canvas && canvas.width > 0 && canvas.height > 0;

              document.body.removeChild(testDiv);
            } catch (error) {
              testResults.functionality.canvasCapture = false;
              testResults.errors.push(
                `Canvas capture test failed: ${error.message}`
              );
            }
          }

          // 4. Test Canvas API
          console.log("4. Testing Canvas API...");
          try {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            ctx.fillStyle = "#ff0000";
            ctx.fillRect(0, 0, 10, 10);
            testResults.functionality.canvasAPI = true;
          } catch (error) {
            testResults.functionality.canvasAPI = false;
            testResults.errors.push(`Canvas API test failed: ${error.message}`);
          }

          // 5. Test File API
          console.log("5. Testing File API...");
          testResults.functionality.fileAPI =
            typeof FileReader !== "undefined" &&
            typeof File !== "undefined" &&
            typeof Blob !== "undefined";

          // 6. Test Local Storage
          console.log("6. Testing Local Storage...");
          try {
            const testKey = "__browser_test__";
            localStorage.setItem(testKey, "test");
            testResults.functionality.localStorage =
              localStorage.getItem(testKey) === "test";
            localStorage.removeItem(testKey);
          } catch (error) {
            testResults.functionality.localStorage = false;
            testResults.errors.push(
              `LocalStorage test failed: ${error.message}`
            );
          }

          // 7. Test CSS Features
          console.log("7. Testing CSS features...");
          testResults.functionality.cssGrid = CSS.supports("display", "grid");
          testResults.functionality.cssFlexbox = CSS.supports(
            "display",
            "flex"
          );
          testResults.functionality.cssBackdropFilter = CSS.supports(
            "backdrop-filter",
            "blur(5px)"
          );
          testResults.functionality.cssTransforms = CSS.supports(
            "transform",
            "translateX(0)"
          );

          // 8. Performance Tests
          console.log("8. Running performance tests...");
          const perfStart = performance.now();

          // Test canvas rendering performance
          const canvas = document.createElement("canvas");
          canvas.width = 1920;
          canvas.height = 1080;
          const ctx = canvas.getContext("2d");

          for (let i = 0; i < 100; i++) {
            ctx.fillStyle = `hsl(${i * 3.6}, 50%, 50%)`;
            ctx.fillRect(i * 10, i * 5, 50, 50);
          }

          const perfEnd = performance.now();
          testResults.performance.canvasRenderTime = perfEnd - perfStart;
          testResults.performance.canvasRenderScore =
            perfEnd - perfStart < 100
              ? "Good"
              : perfEnd - perfStart < 500
              ? "Fair"
              : "Poor";

          // 9. Test Application-Specific Functionality
          console.log("9. Testing application functionality...");

          // Test state management
          try {
            const testPath = "test.value";
            const testValue = "test123";
            updateAppState(testPath, testValue);
            testResults.functionality.stateManagement =
              getAppState(testPath) === testValue;
          } catch (error) {
            testResults.functionality.stateManagement = false;
            testResults.errors.push(
              `State management test failed: ${error.message}`
            );
          }

          // Test preview canvas
          const previewCanvas = document.getElementById("preview-canvas");
          testResults.functionality.previewCanvas = previewCanvas !== null;

          // Test form controls
          const formControls = [
            "fullName",
            "nickname",
            "positionEn",
            "positionJp",
            "japaneseFont",
            "englishFont",
            "fontSize",
            "export-btn",
          ];
          testResults.functionality.formControls = formControls.every(
            (id) => document.getElementById(id) !== null
          );

          // 10. Calculate Overall Score
          const featureScore =
            Object.values(testResults.features).filter(Boolean).length /
            Object.values(testResults.features).length;
          const fontScore =
            Object.values(testResults.fonts).filter(Boolean).length /
            Object.values(testResults.fonts).length;
          const functionalityScore =
            Object.values(testResults.functionality).filter(Boolean).length /
            Object.values(testResults.functionality).length;

          testResults.overallScore = Math.round(
            ((featureScore + fontScore + functionalityScore) / 3) * 100
          );

          // Log comprehensive results
          console.log("=== BROWSER TEST RESULTS ===");
          console.log("Browser Info:", testResults.browser);
          console.log("Feature Support:", testResults.features);
          console.log("Font Loading:", testResults.fonts);
          console.log("Functionality:", testResults.functionality);
          console.log("Performance:", testResults.performance);
          console.log("Errors:", testResults.errors);
          console.log(
            `Overall Compatibility Score: ${testResults.overallScore}%`
          );

          // Show user notification
          if (testResults.overallScore >= 90) {
            notificationManager.success(
              "Excellent Browser Support",
              `Your browser scored ${testResults.overallScore}% compatibility. All features should work perfectly.`,
              { duration: 5000 }
            );
          } else if (testResults.overallScore >= 75) {
            notificationManager.info(
              "Good Browser Support",
              `Your browser scored ${testResults.overallScore}% compatibility. Most features should work well.`,
              { duration: 6000 }
            );
          } else if (testResults.overallScore >= 60) {
            notificationManager.warning(
              "Limited Browser Support",
              `Your browser scored ${testResults.overallScore}% compatibility. Some features may not work correctly.`,
              { duration: 8000 }
            );
          } else {
            notificationManager.error(
              "Poor Browser Support",
              `Your browser scored ${testResults.overallScore}% compatibility. Many features may not work. Consider updating your browser.`,
              {
                duration: 10000,
                persistent: true,
              }
            );
          }

          return testResults;
        } catch (error) {
          console.error("Comprehensive browser testing failed:", error);
          testResults.errors.push(`Testing framework error: ${error.message}`);
          return testResults;
        }
      }

      // Export testing function to global scope for manual testing
      window.runBrowserTests = runComprehensiveBrowserTests;

      // Cross-browser initialization function
      async function initializeCrossBrowserSupport() {
        try {
          console.log("Initializing cross-browser support...");

          // Test browser features
          await browserCompatibility.testBrowserFeatures();

          // Load Google Fonts with fallbacks
          await fontLoadingManager.loadAllGoogleFonts();

          // Verify HTML2Canvas availability
          if (!html2canvasManager.isSupported()) {
            console.warn(
              "HTML2Canvas is not available - export functionality disabled"
            );
          }

          // Apply browser-specific CSS classes
          const browserInfo = browserCompatibility.getBrowserInfo();
          document.body.classList.add(
            `browser-${browserInfo.name.toLowerCase()}`
          );
          document.body.classList.add(
            `engine-${browserInfo.engine.toLowerCase()}`
          );

          if (browserInfo.mobile) {
            document.body.classList.add("mobile-browser");
          }

          console.log("Cross-browser support initialized successfully");

          // Show compatibility report to user (only in development)
          if (
            window.location.hostname === "localhost" ||
            window.location.hostname === "127.0.0.1"
          ) {
            setTimeout(() => {
              const testResults = browserCompatibility.getTestResults();
              const supportedFeatures = Array.from(testResults.values()).filter(
                Boolean
              ).length;
              const totalFeatures = Array.from(testResults.values()).length;
              const score = Math.round(
                (supportedFeatures / totalFeatures) * 100
              );

              notificationManager.info(
                "Development Mode",
                `Browser compatibility: ${score}% (${supportedFeatures}/${totalFeatures} features supported)`,
                { duration: 5000 }
              );
            }, 1000);
          }

          return true;
        } catch (error) {
          console.error("Failed to initialize cross-browser support:", error);

          notificationManager.error(
            "Compatibility Check Failed",
            "Some browser features could not be verified. The application may not work correctly.",
            { duration: 8000 }
          );

          return false;
        }
      }

      // Batch State Updates
      function batchUpdateState(updates, options = {}) {
        try {
          const results = [];
          const errors = [];

          // Disable persistence during batch updates
          const batchOptions = { ...options, skipPersistence: true };

          updates.forEach(({ path, value }, index) => {
            try {
              updateAppState(path, value, batchOptions);
              results.push({ index, path, success: true });
            } catch (error) {
              errors.push({ index, path, error: error.message });
              results.push({
                index,
                path,
                success: false,
                error: error.message,
              });
            }
          });

          // Save state once after all updates
          if (!options.skipPersistence) {
            saveStateToStorage();
          }

          // Emit batch update event
          stateEvents.emit("batchStateUpdate", {
            results: results,
            errors: errors,
            timestamp: Date.now(),
          });

          console.log(
            "Batch state update completed:",
            results.length,
            "updates,",
            errors.length,
            "errors"
          );
          return { results, errors };
        } catch (error) {
          console.error("Failed to perform batch state update:", error.message);
          throw error;
        }
      }

      // State Debugging Utilities
      function debugState() {
        console.group("DDAM App State Debug");
        console.log("Current State:", JSON.stringify(appState, null, 2));
        console.log("Event Listeners:", Object.keys(stateEvents.listeners));
        console.log(
          "LocalStorage State:",
          localStorage.getItem("ddamBackgroundGenerator_state")
        );
        console.groupEnd();
      }

      // Export state management functions to global scope for use in other tasks
      window.ddamState = {
        get: getAppState,
        update: updateAppState,
        reset: resetAppState,
        save: saveStateToStorage,
        load: loadStateFromStorage,
        clear: clearStoredState,
        batch: batchUpdateState,
        debug: debugState,
        events: stateEvents,
      };

      // Layout Selection Management
      class LayoutSelector {
        constructor() {
          this.currentLayout = getAppState("layout.type") || "layout1";
          this.layoutCards = {};
          this.init();
        }

        init() {
          // Get layout card elements
          this.layoutCards.layout1 = document.getElementById("layout1-card");
          this.layoutCards.layout2 = document.getElementById("layout2-card");

          if (!this.layoutCards.layout1 || !this.layoutCards.layout2) {
            console.error("Layout cards not found in DOM");
            return;
          }

          // Set up event listeners
          this.setupEventListeners();

          // Set initial active state
          this.updateActiveLayout(this.currentLayout);

          // Initialize preview text content
          this.updatePreviewTextContent();

          console.log(
            "Layout selector initialized with layout:",
            this.currentLayout
          );
        }

        setupEventListeners() {
          // Add click listeners to layout cards
          Object.keys(this.layoutCards).forEach((layoutType) => {
            const card = this.layoutCards[layoutType];
            if (card) {
              card.addEventListener("click", () => {
                this.selectLayout(layoutType);
              });

              // Add keyboard support
              card.addEventListener("keydown", (e) => {
                if (e.key === "Enter" || e.key === " ") {
                  e.preventDefault();
                  this.selectLayout(layoutType);
                }
              });

              // Make cards focusable
              card.setAttribute("tabindex", "0");
              card.setAttribute("role", "button");
              card.setAttribute(
                "aria-label",
                `Select ${layoutType === "layout1" ? "Layout 1" : "Layout 2"}`
              );
            }
          });

          // Listen for state changes
          stateEvents.on("stateChange:layout.type", (data) => {
            this.currentLayout = data.newValue;
            this.updateActiveLayout(data.newValue);
          });

          // Listen for text field changes to update preview
          stateEvents.on("stateChange:text.fields.fullName", () =>
            this.updatePreviewTextContent()
          );
          stateEvents.on("stateChange:text.fields.nickname", () =>
            this.updatePreviewTextContent()
          );
          stateEvents.on("stateChange:text.fields.positionEn", () =>
            this.updatePreviewTextContent()
          );
          stateEvents.on("stateChange:text.fields.positionJp", () =>
            this.updatePreviewTextContent()
          );

          // Listen for text positioning changes
          stateEvents.on("stateChange:text.positioning.layout1", () =>
            this.updatePreviewTextPosition(this.currentLayout)
          );
          stateEvents.on("stateChange:text.positioning.layout2", () =>
            this.updatePreviewTextPosition(this.currentLayout)
          );

          // Listen for overlay changes (Layout 1 only)
          stateEvents.on("stateChange:layout.overlay.opacity", () => {
            if (this.currentLayout === "layout1") {
              updatePreview();
            }
          });
          stateEvents.on("stateChange:layout.overlay.size", () => {
            if (this.currentLayout === "layout1") {
              updatePreview();
            }
          });
        }

        selectLayout(layoutType) {
          if (!this.layoutCards[layoutType]) {
            console.error("Invalid layout type:", layoutType);
            return;
          }

          if (this.currentLayout === layoutType) {
            console.log("Layout already selected:", layoutType);
            return;
          }

          try {
            // Update application state
            updateAppState("layout.type", layoutType);

            // Visual feedback
            this.showSelectionFeedback(layoutType);

            console.log("Layout selected:", layoutType);
          } catch (error) {
            console.error("Failed to select layout:", error.message);
            this.showError("Failed to select layout. Please try again.");
          }
        }

        updateActiveLayout(layoutType) {
          // Remove active class from all cards
          Object.values(this.layoutCards).forEach((card) => {
            if (card) {
              card.classList.remove("active");
              card.setAttribute("aria-selected", "false");
            }
          });

          // Add active class to selected card
          const activeCard = this.layoutCards[layoutType];
          if (activeCard) {
            activeCard.classList.add("active");
            activeCard.setAttribute("aria-selected", "true");
          }

          // Update preview text positioning based on layout
          this.updatePreviewTextPosition(layoutType);
        }

        updatePreviewTextPosition(layoutType) {
          const layout1Text = document.querySelector(".preview-text-layout1");
          const layout2Text = document.querySelector(".preview-text-layout2");

          if (layout1Text && layout2Text) {
            // Get current text positioning from state
            const currentPosition1 =
              getAppState("text.positioning.layout1") || "top-right";
            const currentPosition2 =
              getAppState("text.positioning.layout2") || "top-right";

            // Update layout 1 text position
            layout1Text.className = "preview-text preview-text-layout1";
            layout1Text.classList.add(`position-${currentPosition1}`);

            // Update layout 2 text position
            layout2Text.className = "preview-text preview-text-layout2";
            layout2Text.classList.add(`position-${currentPosition2}`);
          }
        }

        showSelectionFeedback(layoutType) {
          const card = this.layoutCards[layoutType];
          if (!card) return;

          // Add temporary animation class
          card.classList.add("selection-feedback");

          // Remove animation class after animation completes
          setTimeout(() => {
            card.classList.remove("selection-feedback");
          }, 300);
        }

        showError(message) {
          // Create or update error message element
          let errorElement = document.querySelector(".layout-selection-error");
          if (!errorElement) {
            errorElement = document.createElement("div");
            errorElement.className = "layout-selection-error error";
            const layoutSelection = document.querySelector(".layout-selection");
            if (layoutSelection && layoutSelection.parentNode) {
              layoutSelection.parentNode.insertBefore(
                errorElement,
                layoutSelection
              );
            }
          }

          errorElement.textContent = message;
          errorElement.style.display = "block";

          // Auto-hide error after 5 seconds
          setTimeout(() => {
            if (errorElement) {
              errorElement.style.display = "none";
            }
          }, 5000);
        }

        getCurrentLayout() {
          return this.currentLayout;
        }

        // Method to programmatically select layout (for external use)
        setLayout(layoutType) {
          this.selectLayout(layoutType);
        }

        // Method to refresh layout selector (useful after state changes)
        refresh() {
          const currentLayout = getAppState("layout.type");
          if (currentLayout !== this.currentLayout) {
            this.currentLayout = currentLayout;
            this.updateActiveLayout(currentLayout);
          }

          // Update preview text content
          this.updatePreviewTextContent();
        }

        // Update preview text content in layout cards
        updatePreviewTextContent() {
          const textFields = getAppState("text.fields");
          if (!textFields) return;

          const layout1Text = document.querySelector(".preview-text-layout1");
          const layout2Text = document.querySelector(".preview-text-layout2");

          if (layout1Text) {
            layout1Text.innerHTML = `
                      <div>${textFields.fullName}</div>
                      <div>${textFields.nickname}</div>
                      <div>${textFields.positionEn}</div>
                      <div>${textFields.positionJp}</div>
                  `;
          }

          if (layout2Text) {
            layout2Text.innerHTML = `
                      <div>${textFields.fullName}</div>
                      <div>${textFields.nickname}</div>
                      <div>${textFields.positionEn}</div>
                      <div>${textFields.positionJp}</div>
                  `;
          }
        }
      }

      // Text Input Handler Class
      class TextInputHandler {
        constructor() {
          this.form = null;
          this.inputs = {};
          this.debounceTimers = {};
          this.debounceDelay = 300; // 300ms debounce for performance

          this.init();
        }

        init() {
          this.form = document.getElementById("text-form");
          if (!this.form) {
            console.error("Text form not found");
            return;
          }

          // Get all text input elements
          this.inputs = {
            fullName: document.getElementById("fullName"),
            nickname: document.getElementById("nickname"),
            positionEn: document.getElementById("positionEn"),
            positionJp: document.getElementById("positionJp"),
          };

          // Verify all inputs exist
          for (const [key, input] of Object.entries(this.inputs)) {
            if (!input) {
              console.error(`Text input not found: ${key}`);
              return;
            }
          }

          this.attachEventListeners();
          this.syncInputsWithState();

          console.log("Text input handler initialized");
        }

        attachEventListeners() {
          // Add event listeners for each input
          Object.entries(this.inputs).forEach(([fieldName, input]) => {
            // Input event for real-time updates (with debouncing)
            input.addEventListener("input", (e) => {
              this.handleInputChange(fieldName, e.target.value);
            });

            // Change event for final validation
            input.addEventListener("change", (e) => {
              this.handleInputChange(fieldName, e.target.value, {
                immediate: true,
                sanitize: true,
              });
            });

            // Blur event for validation feedback and sanitization
            input.addEventListener("blur", (e) => {
              this.handleInputChange(fieldName, e.target.value, {
                immediate: true,
                sanitize: true,
              });
              this.validateInput(fieldName, e.target.value);
            });

            // Focus event to clear any error states
            input.addEventListener("focus", (e) => {
              this.clearInputError(fieldName);
            });
          });

          // Form submission prevention (since this is a single-page app)
          this.form.addEventListener("submit", (e) => {
            e.preventDefault();
            console.log("Form submission prevented - using real-time updates");
          });
        }

        handleInputChange(fieldName, value, options = {}) {
          try {
            // Only sanitize on blur/change events, not during typing
            let processedValue = value;
            if (options.immediate || options.sanitize) {
              processedValue = this.sanitizeInput(value);

              // Update the input value if sanitization changed it
              if (processedValue !== value) {
                this.inputs[fieldName].value = processedValue;
              }
            }

            // Debounce updates unless immediate is requested
            if (options.immediate) {
              this.updateStateField(fieldName, processedValue);
            } else {
              this.debounceUpdate(fieldName, processedValue);
            }
          } catch (error) {
            console.error("Error handling input change:", error);
            this.showInputError(fieldName, error.message);
          }
        }

        debounceUpdate(fieldName, value) {
          // Clear existing timer
          if (this.debounceTimers[fieldName]) {
            clearTimeout(this.debounceTimers[fieldName]);
          }

          // Set new timer
          this.debounceTimers[fieldName] = setTimeout(() => {
            this.updateStateField(fieldName, value);
            delete this.debounceTimers[fieldName];
          }, this.debounceDelay);
        }

        updateStateField(fieldName, value) {
          try {
            const statePath = `text.fields.${fieldName}`;
            updateAppState(statePath, value);

            // Clear any error state
            this.clearInputError(fieldName);

            console.log(`Updated ${fieldName}:`, value);
          } catch (error) {
            console.error(`Failed to update ${fieldName}:`, error);
            this.showInputError(fieldName, error.message);
          }
        }

        sanitizeInput(value) {
          if (typeof value !== "string") {
            return "";
          }

          // Remove potentially harmful characters while preserving normal spaces
          return value
            .replace(/[<>]/g, "") // Remove angle brackets to prevent HTML injection
            .replace(/\s{3,}/g, "  ") // Only reduce excessive spaces (3+ becomes 2)
            .replace(/^\s+|\s+$/g, ""); // Trim leading/trailing whitespace only
        }

        validateInput(fieldName, value) {
          try {
            const statePath = `text.fields.${fieldName}`;
            validateStateValue(statePath, value);

            // Additional field-specific validation
            if (fieldName === "fullName" && value.length === 0) {
              throw new Error("Full name is required");
            }

            if (fieldName === "nickname" && value.length === 0) {
              throw new Error("Nickname is required");
            }

            if (fieldName === "positionEn" && value.length === 0) {
              throw new Error("English position is required");
            }

            if (fieldName === "positionJp" && value.length === 0) {
              throw new Error("Japanese position is required");
            }

            this.clearInputError(fieldName);
            return true;
          } catch (error) {
            this.showInputError(fieldName, error.message);
            return false;
          }
        }

        showInputError(fieldName, message) {
          const input = this.inputs[fieldName];
          if (!input) return;

          // Add error class
          input.classList.add("error");

          // Create or update error message
          let errorElement = document.getElementById(`${fieldName}-error`);
          if (!errorElement) {
            errorElement = document.createElement("div");
            errorElement.id = `${fieldName}-error`;
            errorElement.className = "form-error";
            input.parentNode.appendChild(errorElement);
          }

          errorElement.textContent = message;
          errorElement.style.display = "block";
        }

        clearInputError(fieldName) {
          const input = this.inputs[fieldName];
          if (!input) return;

          // Remove error class
          input.classList.remove("error");

          // Hide error message
          const errorElement = document.getElementById(`${fieldName}-error`);
          if (errorElement) {
            errorElement.style.display = "none";
          }
        }

        syncInputsWithState() {
          // Sync input values with current state
          const textFields = getAppState("text.fields");
          if (!textFields) return;

          Object.entries(this.inputs).forEach(([fieldName, input]) => {
            if (textFields[fieldName] !== undefined) {
              input.value = textFields[fieldName];
            }
          });

          console.log("Text inputs synced with state");
        }

        // Public method to update inputs from external state changes
        updateFromState() {
          this.syncInputsWithState();
        }

        // Public method to validate all inputs
        validateAll() {
          let allValid = true;

          Object.entries(this.inputs).forEach(([fieldName, input]) => {
            const isValid = this.validateInput(fieldName, input.value);
            if (!isValid) {
              allValid = false;
            }
          });

          return allValid;
        }

        // Public method to get current form data
        getFormData() {
          const data = {};
          Object.entries(this.inputs).forEach(([fieldName, input]) => {
            data[fieldName] = input.value;
          });
          return data;
        }
      }

      // Global layout selector instance
      let layoutSelector = null;

      // Global text input handler instance
      let textInputHandler = null;

      // Global text position handler instance
      let textPositionHandler = null;

      // Initialize application
      document.addEventListener("DOMContentLoaded", async function () {
        console.log("DDAM Meeting Background Generator initializing...");

        try {
          // Initialize cross-browser support first
          await initializeCrossBrowserSupport();

          // Initialize error handling and user feedback systems
          initializeErrorHandling();

          console.log("Google Fonts loaded:", document.fonts.ready);
          console.log(
            "HTML2Canvas available:",
            typeof html2canvas !== "undefined"
          );
          console.log("Browser:", browserCompatibility.getBrowserInfo());

          // Load saved state from localStorage
          loadStateFromStorage();

          // Debug: Check initial state
          console.log("Initial app state:", getAppState());
          console.log(
            "Initial selected logo:",
            getAppState("assets.selectedLogo")
          );

          // Test logo loading with error handling
          const testLogo = "logo/no-bg-logo-1.png";
          console.log("Testing logo load:", testLogo);
          loadImage(testLogo)
            .then((img) => {
              console.log("Test logo load result:", img ? "SUCCESS" : "FAILED");
              if (img) {
                console.log(
                  "Test logo dimensions:",
                  img.width,
                  "x",
                  img.height
                );
              } else {
                notificationManager.warning(
                  "Asset Loading Issue",
                  "Some assets may not load properly. Please refresh if you experience issues.",
                  { duration: 5000 }
                );
              }
            })
            .catch((error) => {
              console.error("Test logo load failed:", error);
              errorBoundary.handleError(error, "AssetLoad");
            });

          // Set up state change event listeners
          stateEvents.on("stateChange", function (data) {
            console.log(
              "State changed:",
              data.path,
              "from",
              data.oldValue,
              "to",
              data.newValue
            );
            // Trigger preview update when state changes (will be implemented in future tasks)
            try {
              updatePreview();
            } catch (error) {
              console.error("Preview update failed:", error);
              errorBoundary.handleError(error, "PreviewUpdate");
            }
          });

          stateEvents.on("stateReset", function (data) {
            console.log("State reset at:", new Date(data.timestamp));
            try {
              updatePreview();
            } catch (error) {
              errorBoundary.handleError(error, "PreviewUpdate");
            }
          });

          stateEvents.on("stateLoaded", function (data) {
            console.log(
              "State loaded from storage at:",
              new Date(data.timestamp)
            );
            try {
              updatePreview();
            } catch (error) {
              errorBoundary.handleError(error, "PreviewUpdate");
            }
          });

          stateEvents.on("batchStateUpdate", function (data) {
            console.log(
              "Batch state update completed:",
              data.results.length,
              "updates"
            );
            if (data.errors.length > 0) {
              console.warn("Batch update errors:", data.errors);
              notificationManager.warning(
                "Some Settings Not Saved",
                "Some of your changes may not have been saved properly.",
                { duration: 4000 }
              );
            }
          });

          // Listen for text field changes to update layout previews
          stateEvents.on("stateChange", function (data) {
            if (data.path.startsWith("text.fields.")) {
              try {
                updateLayoutPreviewText();
              } catch (error) {
                errorBoundary.handleError(error, "PreviewUpdate");
              }
            }
          });

          // Initialize canvas renderer
          canvasRenderer = new CanvasRenderer();

          // Verify font loading and update preview
          document.fonts.ready.then(function () {
            console.log("All fonts loaded successfully");
            updatePreview(); // Redraw with proper fonts
          });

          // Initialize layout selector
          layoutSelector = new LayoutSelector();

          // Initialize text input handler
          textInputHandler = new TextInputHandler();

          // Initialize font manager
          fontManager = new FontManager();

          // Initialize asset manager
          assetManager = new AssetManager();

          // Initialize text position handler
          textPositionHandler = new TextPositionHandler();

          // Initialize preview update manager
          previewUpdateManager = new PreviewUpdateManager();

          // Initialize logo scale control
          const logoScaleInput = document.getElementById("logoScale");
          const logoScaleValue = document.getElementById("logoScale-value");

          if (logoScaleInput && logoScaleValue) {
            logoScaleInput.addEventListener("input", (e) => {
              const scale = parseFloat(e.target.value);
              const percentage = Math.round(scale * 100);
              logoScaleValue.textContent = percentage + "%";

              console.log(
                "Logo scale changed to:",
                scale,
                "(" + percentage + "%)"
              );

              // Update state (use updateAppState to trigger events)
              updateAppState("assets.logoScale", scale);
            });

            // Initialize display value
            const currentScale = getAppState("assets.logoScale") || 1.0;
            logoScaleInput.value = currentScale;
            logoScaleValue.textContent = Math.round(currentScale * 100) + "%";
          }

          // Initialize overlay controls
          const overlayOpacityInput =
            document.getElementById("overlay-opacity");
          const overlayOpacityValue = document.getElementById(
            "overlay-opacity-value"
          );
          const overlaySizeInput = document.getElementById("overlay-size");
          const overlaySizeValue =
            document.getElementById("overlay-size-value");

          if (overlayOpacityInput && overlayOpacityValue) {
            overlayOpacityInput.addEventListener("input", (e) => {
              const opacity = parseInt(e.target.value);
              overlayOpacityValue.textContent = opacity + "%";

              console.log("Overlay opacity changed to:", opacity + "%");

              // Update state (use updateAppState to trigger events)
              updateAppState("layout.overlay.opacity", opacity);
            });

            // Initialize display value
            const currentOpacity = getAppState("layout.overlay.opacity") || 80;
            overlayOpacityInput.value = currentOpacity;
            overlayOpacityValue.textContent = currentOpacity + "%";
          }

          if (overlaySizeInput && overlaySizeValue) {
            overlaySizeInput.addEventListener("input", (e) => {
              const size = parseInt(e.target.value);
              overlaySizeValue.textContent = size + "%";

              console.log("Overlay size changed to:", size + "%");

              // Update state (use updateAppState to trigger events)
              updateAppState("layout.overlay.size", size);
            });

            // Initialize display value
            const currentSize = getAppState("layout.overlay.size") || 40;
            overlaySizeInput.value = currentSize;
            overlaySizeValue.textContent = currentSize + "%";
          }

          // Expose layout selector for external access
          window.ddamLayoutSelector = layoutSelector;

          // Expose text input handler for external access
          window.ddamTextInputHandler = textInputHandler;

          // Expose font manager for external access
          window.ddamFontManager = fontManager;

          // Expose asset manager for external access
          window.ddamAssetManager = assetManager;

          // Expose canvas renderer for external access
          window.ddamCanvasRenderer = canvasRenderer;

          // Expose text position handler for external access
          window.ddamTextPositionHandler = textPositionHandler;

          // Expose preview update manager for external access
          window.ddamPreviewUpdateManager = previewUpdateManager;

          // Initialize mobile optimizer
          mobileOptimizer = new MobileOptimizer();

          // Initialize export manager
          exportManager = new ExportManager();

          // Initialize export controls
          initializeExportControls();

          // Expose export manager for external access
          window.ddamExportManager = exportManager;

          // Expose mobile optimizer for external access
          window.ddamMobileOptimizer = mobileOptimizer;

          // Expose debug functions
          window.debugCanvas = debugCanvas;
          window.debugExport = debugExport;

          // Expose state management for debugging
          window.debugState = debugState;

          console.log("State management system initialized");
          console.log(
            "Available state functions:",
            Object.keys(window.ddamState)
          );
          console.log("Layout selector initialized");
          console.log("Export manager initialized");

          // Force an initial render after everything is loaded
          setTimeout(() => {
            console.log("Forcing initial preview render...");
            updatePreview();
          }, 1000);
        } catch (error) {
          console.error("Failed to initialize application:", error);

          // Show error notification to user
          if (typeof notificationManager !== "undefined") {
            notificationManager.error(
              "Initialization Failed",
              "The application failed to initialize properly. Please refresh the page.",
              {
                persistent: true,
                actions: [
                  {
                    id: "refresh",
                    label: "Refresh Page",
                    handler: () => window.location.reload(),
                  },
                ],
              }
            );
          } else {
            // Fallback if notification manager isn't available
            alert("Application failed to initialize. Please refresh the page.");
          }
        }
      });

      // Function to update layout preview text in real-time
      function updateLayoutPreviewText() {
        const textFields = getAppState("text.fields");
        if (!textFields) return;

        const layout1Text = document.querySelector(".preview-text-layout1");
        const layout2Text = document.querySelector(".preview-text-layout2");

        const textContent = `
              <div>${textFields.fullName}</div>
              <div>${textFields.nickname}</div>
              <div>${textFields.positionEn}</div>
              <div>${textFields.positionJp}</div>
          `;

        if (layout1Text) {
          layout1Text.innerHTML = textContent;
        }

        if (layout2Text) {
          layout2Text.innerHTML = textContent;
        }
      }

      // Font Management System
      class FontManager {
        constructor() {
          this.loadedFonts = new Set();
          this.fontLoadPromises = new Map();
          this.initializeFontControls();
        }

        initializeFontControls() {
          const japaneseFontSelect = document.getElementById("japaneseFont");
          const englishFontSelect = document.getElementById("englishFont");
          const fontSizeSlider = document.getElementById("fontSize");
          const colorToggleButtons =
            document.querySelectorAll(".color-toggle-btn");

          if (japaneseFontSelect) {
            japaneseFontSelect.addEventListener("change", (e) => {
              this.handleJapaneseFontChange(e.target.value);
            });
          }

          if (englishFontSelect) {
            englishFontSelect.addEventListener("change", (e) => {
              this.handleEnglishFontChange(e.target.value);
            });
          }

          if (fontSizeSlider) {
            fontSizeSlider.addEventListener("input", (e) => {
              this.handleFontSizeChange(parseInt(e.target.value));
            });
          }

          colorToggleButtons.forEach((button) => {
            button.addEventListener("click", (e) => {
              const color = e.currentTarget.dataset.color;
              this.handleTextColorChange(color);
            });
          });

          // Load initial fonts
          this.loadFont(appState.text.typography.japaneseFont);
          this.loadFont(appState.text.typography.englishFont);

          // Initialize UI with current state
          this.updateFontSizeDisplay();
          this.updateColorToggleDisplay();

          // Listen for state changes to update typography in real-time
          stateEvents.on("stateChange", (data) => {
            if (data.path.startsWith("text.typography")) {
              this.handleTypographyStateChange(data);
            }
          });
        }

        async loadFont(fontFamily) {
          if (this.loadedFonts.has(fontFamily)) {
            return Promise.resolve();
          }

          if (this.fontLoadPromises.has(fontFamily)) {
            return this.fontLoadPromises.get(fontFamily);
          }

          const loadPromise = this.verifyFontLoading(fontFamily);
          this.fontLoadPromises.set(fontFamily, loadPromise);

          try {
            await loadPromise;
            this.loadedFonts.add(fontFamily);
            console.log(`Font loaded successfully: ${fontFamily}`);
            return true;
          } catch (error) {
            console.warn(`Failed to load font: ${fontFamily}`, error);
            this.fontLoadPromises.delete(fontFamily);
            return false;
          }
        }

        async verifyFontLoading(fontFamily) {
          // System fonts that don't need loading verification
          const systemFonts = [
            "Hiragino Sans",
            "Yu Gothic",
            "Meiryo",
            "Arial",
            "Times New Roman",
          ];

          if (systemFonts.includes(fontFamily)) {
            // System fonts are assumed to be available
            return Promise.resolve();
          }

          // Check if font is already available
          if (document.fonts.check(`16px "${fontFamily}"`)) {
            return Promise.resolve();
          }

          // Try to load the font (for Google Fonts)
          try {
            await document.fonts.load(`16px "${fontFamily}"`);

            // Verify the font was actually loaded
            if (document.fonts.check(`16px "${fontFamily}"`)) {
              return Promise.resolve();
            } else {
              throw new Error(`Font verification failed: ${fontFamily}`);
            }
          } catch (error) {
            // Fallback: wait for fonts.ready and check again
            await document.fonts.ready;

            if (document.fonts.check(`16px "${fontFamily}"`)) {
              return Promise.resolve();
            } else {
              // For system fonts, we'll assume they're available even if check fails
              if (systemFonts.includes(fontFamily)) {
                console.warn(
                  `System font may not be available: ${fontFamily}, but proceeding anyway`
                );
                return Promise.resolve();
              }
              throw new Error(`Font not available: ${fontFamily}`);
            }
          }
        }

        async handleJapaneseFontChange(fontFamily) {
          try {
            // Show loading state for font change
            const fontSelect = document.getElementById("japaneseFont");
            if (fontSelect) {
              fontSelect.disabled = true;
            }

            // Validate font selection
            updateAppState("text.typography.japaneseFont", fontFamily);

            // Load the font using the cross-browser font manager
            const loaded = await fontLoadingManager.loadFont(fontFamily, {
              timeout: 8000,
            });

            if (!loaded) {
              throw new Error(`Failed to load font: ${fontFamily}`);
            }

            console.log(`Japanese font loaded successfully: ${fontFamily}`);
            const fontLoaded = await Promise.race([
              this.loadFont(fontFamily),
              new Promise((_, reject) =>
                setTimeout(() => reject(new Error("Font load timeout")), 5000)
              ),
            ]);

            if (!fontLoaded) {
              throw new Error("Font failed to load properly");
            }

            // Update preview
            updatePreview();

            // Show success notification
            notificationManager.success(
              "Font Updated",
              `Japanese font changed to ${fontFamily}`,
              { duration: 2000 }
            );

            console.log(`Japanese font changed to: ${fontFamily}`);
          } catch (error) {
            console.error("Error changing Japanese font:", error);

            // Revert to previous font
            const previousFont = getAppState("text.typography.japaneseFont");
            if (previousFont !== fontFamily) {
              updateAppState("text.typography.japaneseFont", "Noto Sans JP", {
                skipValidation: true,
              });
            }

            // Show error notification
            notificationManager.error(
              "Font Load Failed",
              `Failed to load ${fontFamily}. Reverted to fallback font.`,
              {
                duration: 4000,
                actions: [
                  {
                    id: "retry",
                    label: "Try Again",
                    handler: () => this.handleJapaneseFontChange(fontFamily),
                  },
                ],
              }
            );

            errorBoundary.handleError(error, "FontLoad");
          } finally {
            // Re-enable font select
            const fontSelect = document.getElementById("japaneseFont");
            if (fontSelect) {
              fontSelect.disabled = false;
            }
          }
        }

        async handleEnglishFontChange(fontFamily) {
          try {
            // Show loading state for font change
            const fontSelect = document.getElementById("englishFont");
            if (fontSelect) {
              fontSelect.disabled = true;
            }

            // Validate font selection
            updateAppState("text.typography.englishFont", fontFamily);

            // Load the font using the cross-browser font manager
            const loaded = await fontLoadingManager.loadFont(fontFamily, {
              timeout: 8000,
            });

            if (!loaded) {
              throw new Error(`Failed to load font: ${fontFamily}`);
            }

            console.log(`English font loaded successfully: ${fontFamily}`);

            // Load the font with timeout
            const fontLoaded = await Promise.race([
              this.loadFont(fontFamily),
              new Promise((_, reject) =>
                setTimeout(() => reject(new Error("Font load timeout")), 5000)
              ),
            ]);

            if (!fontLoaded) {
              throw new Error("Font failed to load properly");
            }

            // Update preview
            updatePreview();

            // Show success notification
            notificationManager.success(
              "Font Updated",
              `English font changed to ${fontFamily}`,
              { duration: 2000 }
            );

            console.log(`English font changed to: ${fontFamily}`);
          } catch (error) {
            console.error("Error changing English font:", error);

            // Revert to previous font
            const previousFont = getAppState("text.typography.englishFont");
            if (previousFont !== fontFamily) {
              updateAppState("text.typography.englishFont", "Roboto", {
                skipValidation: true,
              });
            }

            // Show error notification
            notificationManager.error(
              "Font Load Failed",
              `Failed to load ${fontFamily}. Reverted to fallback font.`,
              {
                duration: 4000,
                actions: [
                  {
                    id: "retry",
                    label: "Try Again",
                    handler: () => this.handleEnglishFontChange(fontFamily),
                  },
                ],
              }
            );

            errorBoundary.handleError(error, "FontLoad");
          } finally {
            // Re-enable font select
            const fontSelect = document.getElementById("englishFont");
            if (fontSelect) {
              fontSelect.disabled = false;
            }
          }
        }

        showFontError(message) {
          // Create or update error message
          let errorElement = document.getElementById("font-error");
          if (!errorElement) {
            errorElement = document.createElement("div");
            errorElement.id = "font-error";
            errorElement.className = "error";

            const typographySection = document.querySelector(
              ".control-section:has(#japaneseFont)"
            );
            if (typographySection) {
              typographySection.insertBefore(
                errorElement,
                typographySection.firstChild.nextSibling
              );
            }
          }

          errorElement.textContent = message;
          errorElement.style.display = "block";

          // Auto-hide after 5 seconds
          setTimeout(() => {
            if (errorElement) {
              errorElement.style.display = "none";
            }
          }, 5000);
        }

        getFontLoadStatus(fontFamily) {
          return this.loadedFonts.has(fontFamily);
        }

        handleFontSizeChange(fontSize) {
          try {
            // Validate font size range
            if (fontSize < 12 || fontSize > 24) {
              throw new Error("Font size must be between 12px and 24px");
            }

            // Update application state
            updateAppState("text.typography.fontSize", fontSize);

            // Update display
            this.updateFontSizeDisplay();

            // Update preview
            updatePreview();

            console.log(`Font size changed to: ${fontSize}px`);
          } catch (error) {
            console.error("Error changing font size:", error);
            this.showFontError(
              "Invalid font size. Please select a value between 12px and 24px."
            );
          }
        }

        handleTextColorChange(color) {
          try {
            // Validate color selection
            const validColors = ["white", "black"];
            if (!validColors.includes(color)) {
              throw new Error(
                `Invalid text color: ${color}. Must be 'white' or 'black'.`
              );
            }

            // Update application state
            updateAppState("text.typography.textColor", color);

            // Update display
            this.updateColorToggleDisplay();

            // Update preview
            updatePreview();

            console.log(`Text color changed to: ${color}`);
          } catch (error) {
            console.error("Error changing text color:", error);
            this.showFontError(
              "Failed to change text color. Please try again."
            );
          }
        }

        updateFontSizeDisplay() {
          const fontSizeSlider = document.getElementById("fontSize");
          const fontSizeValue = document.getElementById("fontSize-value");
          const currentSize = getAppState("text.typography.fontSize");

          if (fontSizeSlider && currentSize) {
            fontSizeSlider.value = currentSize;
          }

          if (fontSizeValue && currentSize) {
            fontSizeValue.textContent = `${currentSize}px`;
          }
        }

        updateColorToggleDisplay() {
          const colorButtons = document.querySelectorAll(".color-toggle-btn");
          const currentColor = getAppState("text.typography.textColor");

          colorButtons.forEach((button) => {
            const buttonColor = button.dataset.color;
            const isActive = buttonColor === currentColor;

            button.classList.toggle("active", isActive);
            button.setAttribute("aria-checked", isActive.toString());
          });
        }

        handleTypographyStateChange(data) {
          const { path, newValue } = data;
          console.log(`Typography state changed: ${path} = ${newValue}`);

          switch (path) {
            case "text.typography.fontSize":
              this.updateFontSizeDisplay();
              break;
            case "text.typography.textColor":
              this.updateColorToggleDisplay();
              break;
            case "text.typography.japaneseFont":
              // Update Japanese font dropdown if changed externally
              const japaneseFontSelect =
                document.getElementById("japaneseFont");
              if (japaneseFontSelect && japaneseFontSelect.value !== newValue) {
                japaneseFontSelect.value = newValue;
              }
              break;
            case "text.typography.englishFont":
              // Update English font dropdown if changed externally
              const englishFontSelect = document.getElementById("englishFont");
              if (englishFontSelect && englishFontSelect.value !== newValue) {
                englishFontSelect.value = newValue;
              }
              break;
          }

          // Update layout preview text with new typography
          this.updateLayoutPreviewTypography();
        }

        updateLayoutPreviewTypography() {
          const typography = getAppState("text.typography");
          if (!typography) return;

          const layout1Text = document.querySelector(".preview-text-layout1");
          const layout2Text = document.querySelector(".preview-text-layout2");

          const fontSize = Math.max(8, typography.fontSize * 0.5); // Scale down for preview
          const color =
            typography.textColor === "white" ? "#ffffff" : "#000000";

          [layout1Text, layout2Text].forEach((element) => {
            if (element) {
              element.style.fontSize = `${fontSize}px`;
              element.style.color = color;

              // Apply font families to appropriate text elements
              const children = element.children;
              for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (i === 0 || i === 2) {
                  // Full name and English position
                  child.style.fontFamily = typography.englishFont;
                } else {
                  // Nickname and Japanese position
                  child.style.fontFamily = typography.japaneseFont;
                }
              }
            }
          });
        }

        getAllLoadedFonts() {
          return Array.from(this.loadedFonts);
        }
      }

      // Initialize font manager
      let fontManager;

      // Text Position Handler Class
      class TextPositionHandler {
        constructor() {
          this.layout1Positions = null;
          this.layout2Positions = null;
          this.currentLayout = "layout1";

          this.init();
        }

        init() {
          // Get position control elements
          this.layout1Positions = document.getElementById("layout1-positions");
          this.layout2Positions = document.getElementById("layout2-positions");

          if (!this.layout1Positions || !this.layout2Positions) {
            console.error("Position control elements not found");
            return;
          }

          // Set up event listeners
          this.setupEventListeners();

          // Set initial state based on app state
          this.updatePositionControls();

          console.log("Text position handler initialized");
        }

        setupEventListeners() {
          // Layout 1 position controls
          const layout1Radios = document.querySelectorAll(
            'input[name="layout1-position"]'
          );
          layout1Radios.forEach((radio) => {
            radio.addEventListener("change", (e) => {
              if (e.target.checked) {
                this.selectPosition("layout1", e.target.value);
              }
            });
          });

          // Layout 1 position option labels (for better UX)
          const layout1Options = document.querySelectorAll(
            "#layout1-positions .position-option"
          );
          layout1Options.forEach((option) => {
            option.addEventListener("click", (e) => {
              const radio = option.querySelector('input[type="radio"]');
              if (radio && !radio.checked) {
                radio.checked = true;
                this.selectPosition("layout1", radio.value);
              }
            });

            // Keyboard support
            option.addEventListener("keydown", (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                const radio = option.querySelector('input[type="radio"]');
                if (radio) {
                  radio.checked = true;
                  this.selectPosition("layout1", radio.value);
                }
              }
            });
          });

          // Layout 2 position controls
          const layout2Radios = document.querySelectorAll(
            'input[name="layout2-position"]'
          );
          layout2Radios.forEach((radio) => {
            radio.addEventListener("change", (e) => {
              if (e.target.checked) {
                this.selectPosition("layout2", e.target.value);
              }
            });
          });

          // Layout 2 position option labels (for better UX)
          const layout2Options = document.querySelectorAll(
            "#layout2-positions .position-option"
          );
          layout2Options.forEach((option) => {
            option.addEventListener("click", (e) => {
              const radio = option.querySelector('input[type="radio"]');
              if (radio && !radio.checked) {
                radio.checked = true;
                this.selectPosition("layout2", radio.value);
              }
            });

            // Keyboard support
            option.addEventListener("keydown", (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                const radio = option.querySelector('input[type="radio"]');
                if (radio) {
                  radio.checked = true;
                  this.selectPosition("layout2", radio.value);
                }
              }
            });
          });

          // Listen for layout changes to show/hide appropriate position controls
          stateEvents.on("stateChange:layout.type", (data) => {
            this.currentLayout = data.newValue;
            this.updateVisiblePositionControls(data.newValue);
          });

          // Listen for position changes from external sources
          stateEvents.on("stateChange:text.positioning.layout1", (data) => {
            this.updatePositionSelection("layout1", data.newValue);
          });

          stateEvents.on("stateChange:text.positioning.layout2", (data) => {
            this.updatePositionSelection("layout2", data.newValue);
          });
        }

        selectPosition(layout, position) {
          try {
            // Validate position for the layout
            const validPositions = this.getValidPositions(layout);
            if (!validPositions.includes(position)) {
              throw new Error(`Invalid position "${position}" for ${layout}`);
            }

            console.log(`Selecting position for ${layout}:`, position);

            // Update application state
            updateAppState(`text.positioning.${layout}`, position);

            // Update visual selection
            this.updatePositionSelection(layout, position);

            console.log(`Position selected for ${layout}:`, position);
            console.log(
              "Current state after position change:",
              getAppState(`text.positioning.${layout}`)
            );
          } catch (error) {
            console.error("Failed to select position:", error);
            this.showPositionError(
              layout,
              "Failed to select position. Please try again."
            );
          }
        }

        updatePositionSelection(layout, selectedPosition) {
          const options = document.querySelectorAll(
            `#${layout}-positions .position-option`
          );
          const radios = document.querySelectorAll(
            `input[name="${layout}-position"]`
          );

          // Update radio buttons
          radios.forEach((radio) => {
            radio.checked = radio.value === selectedPosition;
          });

          // Update visual selection
          options.forEach((option) => {
            const radio = option.querySelector('input[type="radio"]');
            const isSelected = radio && radio.value === selectedPosition;
            option.classList.toggle("active", isSelected);
          });
        }

        updateVisiblePositionControls(layoutType) {
          // Hide all position control sections
          this.layout1Positions.classList.remove("active");
          this.layout2Positions.classList.remove("active");

          // Show the appropriate section
          if (layoutType === "layout1") {
            this.layout1Positions.classList.add("active");
          } else if (layoutType === "layout2") {
            this.layout2Positions.classList.add("active");
          }
        }

        updatePositionControls() {
          // Get current state
          const currentLayout = getAppState("layout.type") || "layout1";
          const layout1Position =
            getAppState("text.positioning.layout1") || "top-right";
          const layout2Position =
            getAppState("text.positioning.layout2") || "top-right";

          // Update current layout
          this.currentLayout = currentLayout;

          // Update visible controls
          this.updateVisiblePositionControls(currentLayout);

          // Update selections
          this.updatePositionSelection("layout1", layout1Position);
          this.updatePositionSelection("layout2", layout2Position);
        }

        getValidPositions(layout) {
          switch (layout) {
            case "layout1":
              return ["top-right", "middle-right", "bottom-right"];
            case "layout2":
              return [
                "top-right",
                "middle-right",
                "bottom-right",
                "bottom-left",
              ];
            default:
              return [];
          }
        }

        showPositionError(layout, message) {
          // Create or update error message element
          let errorElement = document.querySelector(
            `#${layout}-positions .position-error`
          );
          if (!errorElement) {
            errorElement = document.createElement("div");
            errorElement.className = "position-error error";
            const positionSection = document.getElementById(
              `${layout}-positions`
            );
            if (positionSection) {
              positionSection.appendChild(errorElement);
            }
          }

          errorElement.textContent = message;
          errorElement.style.display = "block";

          // Auto-hide error after 5 seconds
          setTimeout(() => {
            if (errorElement) {
              errorElement.style.display = "none";
            }
          }, 5000);
        }

        // Method to get current position for a layout
        getCurrentPosition(layout) {
          return getAppState(`text.positioning.${layout}`);
        }

        // Method to programmatically set position (for external use)
        setPosition(layout, position) {
          this.selectPosition(layout, position);
        }

        // Method to refresh position controls (useful after state changes)
        refresh() {
          this.updatePositionControls();
        }

        // Method to get position coordinates for canvas rendering
        getPositionCoordinates(
          layout,
          position,
          containerWidth,
          containerHeight,
          textWidth,
          textHeight
        ) {
          const padding = 20; // Reduced padding for closer alignment to corners
          let x, y;

          switch (position) {
            case "top-right":
              x = containerWidth - textWidth - padding;
              y = padding;
              break;
            case "middle":
              x = (containerWidth - textWidth) / 2;
              y = (containerHeight - textHeight) / 2;
              break;
            case "middle-right":
              x = containerWidth - textWidth - padding;
              y = (containerHeight - textHeight) / 2;
              break;
            case "bottom-left":
              x = padding;
              y = containerHeight - textHeight - padding;
              break;
            case "bottom-right":
              x = containerWidth - textWidth - padding;
              y = containerHeight - textHeight - padding;
              break;
            default:
              x = padding;
              y = padding;
          }

          // Layout-specific adjustments
          if (layout === "layout1") {
            // Adjust for overlay area in Layout 1 - keep text closer to right edge
            if (
              position === "top-right" ||
              position === "middle-right" ||
              position === "bottom-right"
            ) {
              // Ensure text is within the overlay area but closer to the right edge
              x = Math.min(x, containerWidth - padding); // Much closer to right edge
              x = Math.max(x, containerWidth * 0.65); // Keep within overlay but allow closer positioning
            }
          }

          return { x, y };
        }
      }

      // Asset Management System
      class AssetManager {
        constructor() {
          this.logoCache = new Map();
          this.backgroundCache = new Map();
          this.currentTab = "logos";
          this.logoList = [
            "logo/logo-1.png",
            "logo/logo-2.png",
            "logo/logo-3.png",
            "logo/no-bg-logo-1.png",
            "logo/no-bg-logo-2.png",
            "logo/no-bg-logo-3.png",
          ];
          this.backgroundList = [
            "background-img/12.png",
            "background-img/13.png",
            "background-img/14.png",
            "background-img/15.png",
            "background-img/16.png",
            "background-img/17.png",
            "background-img/18.png",
            "background-img/19.png",
            "background-img/20.png",
            "background-img/21.png",
          ];

          this.init();
        }

        init() {
          this.setupTabNavigation();
          this.setupUploadArea();
          this.loadLogos();

          // Listen for asset state changes
          stateEvents.on("stateChange:assets.selectedLogo", (data) => {
            this.updateLogoSelection(data.newValue);
            this.updateLogoScaleVisibility(data.newValue);
          });

          stateEvents.on("stateChange:assets.selectedBackground", (data) => {
            this.updateBackgroundSelection(data.newValue);
          });

          console.log("Asset manager initialized");
        }

        setupTabNavigation() {
          const tabs = document.querySelectorAll(".asset-tab");
          const panels = document.querySelectorAll(".asset-panel");

          tabs.forEach((tab) => {
            tab.addEventListener("click", (e) => {
              const tabName = e.target.dataset.tab;
              this.switchTab(tabName);
            });
          });
        }

        switchTab(tabName) {
          const tabs = document.querySelectorAll(".asset-tab");
          const panels = document.querySelectorAll(".asset-panel");

          // Update tab active states
          tabs.forEach((tab) => {
            tab.classList.toggle("active", tab.dataset.tab === tabName);
          });

          // Show/hide panels
          panels.forEach((panel) => {
            panel.style.display =
              panel.id === `${tabName}-panel` ? "block" : "none";
          });

          this.currentTab = tabName;

          // Load content for the selected tab
          switch (tabName) {
            case "logos":
              this.loadLogos();
              break;
            case "backgrounds":
              this.loadBackgrounds();
              break;
            case "upload":
              // Upload panel is already set up
              break;
          }

          console.log(`Switched to ${tabName} tab`);
        }

        async loadLogos() {
          const loadingElement = document.getElementById("logos-loading");
          const galleryElement = document.getElementById("logos-gallery");
          const errorElement = document.getElementById("logos-error");

          try {
            // Show loading state
            loadingElement.style.display = "flex";
            galleryElement.style.display = "none";
            errorElement.style.display = "none";

            // Clear existing gallery
            galleryElement.innerHTML = "";

            // Add "No logo" option first
            const noLogoElement = this.createNoLogoOption();
            galleryElement.appendChild(noLogoElement);

            // Load each logo
            const logoPromises = this.logoList.map((logoPath) =>
              this.loadLogoItem(logoPath)
            );
            const logoResults = await Promise.allSettled(logoPromises);

            // Process results
            const successfulLogos = [];
            logoResults.forEach((result, index) => {
              if (result.status === "fulfilled") {
                successfulLogos.push(result.value);
              } else {
                console.warn(
                  `Failed to load logo: ${this.logoList[index]}`,
                  result.reason
                );
              }
            });

            if (successfulLogos.length === 0) {
              console.warn(
                "No logos could be loaded, but 'No logo' option is available"
              );
            }

            // Populate gallery with loaded logos
            successfulLogos.forEach((logoElement) => {
              galleryElement.appendChild(logoElement);
            });

            // Update selection state
            const selectedLogo = getAppState("assets.selectedLogo");
            console.log("Current selected logo from state:", selectedLogo);

            if (selectedLogo) {
              this.updateLogoSelection(selectedLogo);
              this.updateLogoScaleVisibility(selectedLogo);
              console.log("Updated logo selection to:", selectedLogo);
            } else {
              // If no logo is selected, default to "none"
              console.log("No logo selected, setting default to 'none'");
              updateAppState("assets.selectedLogo", "none");
              this.updateLogoSelection("none");
              this.updateLogoScaleVisibility("none");
            }

            // Show gallery
            loadingElement.style.display = "none";
            galleryElement.style.display = "grid";

            console.log(`Loaded ${successfulLogos.length} logos successfully`);

            // Trigger preview update to ensure logo appears
            updatePreview();
          } catch (error) {
            console.error("Failed to load logos:", error);
            loadingElement.style.display = "none";
            errorElement.style.display = "block";
            errorElement.textContent =
              "Failed to load logos. Please refresh the page.";
          }
        }

        async loadLogoItem(logoPath) {
          return new Promise((resolve, reject) => {
            // Check cache first
            if (this.logoCache.has(logoPath)) {
              const cachedElement = this.logoCache
                .get(logoPath)
                .cloneNode(true);
              this.attachLogoEventListeners(cachedElement, logoPath);
              resolve(cachedElement);
              return;
            }

            // Create logo item element
            const logoItem = document.createElement("div");
            logoItem.className = "asset-item logo-item";
            logoItem.dataset.logoPath = logoPath;
            logoItem.setAttribute("tabindex", "0");
            logoItem.setAttribute("role", "button");
            logoItem.setAttribute("aria-label", `Select logo ${logoPath}`);

            // Create thumbnail image
            const thumbnail = document.createElement("img");
            thumbnail.className = "asset-thumbnail logo-thumbnail";
            thumbnail.alt = `Logo ${logoPath}`;

            // Create selector indicator
            const selector = document.createElement("div");
            selector.className = "asset-selector";
            selector.innerHTML = '<div class="asset-selector-icon">✓</div>';

            // Handle image load
            thumbnail.onload = () => {
              logoItem.appendChild(thumbnail);
              logoItem.appendChild(selector);

              // Cache the element
              this.logoCache.set(logoPath, logoItem.cloneNode(true));

              // Attach event listeners
              this.attachLogoEventListeners(logoItem, logoPath);

              resolve(logoItem);
            };

            // Handle image error
            thumbnail.onerror = () => {
              reject(new Error(`Failed to load logo image: ${logoPath}`));
            };

            // Set image source
            thumbnail.src = logoPath;
          });
        }

        createNoLogoOption() {
          // Create no logo item element
          const noLogoItem = document.createElement("div");
          noLogoItem.className = "asset-item logo-item no-logo-item";
          noLogoItem.dataset.logoPath = "none";
          noLogoItem.setAttribute("tabindex", "0");
          noLogoItem.setAttribute("role", "button");
          noLogoItem.setAttribute("aria-label", "No logo option");

          // Create no logo content
          const noLogoContent = document.createElement("div");
          noLogoContent.className = "no-logo-content";
          noLogoContent.innerHTML = `
            <div class="no-logo-icon">🚫</div>
            <div class="no-logo-text">No Logo</div>
          `;

          // Create selector indicator
          const selector = document.createElement("div");
          selector.className = "asset-selector";
          selector.innerHTML = '<div class="asset-selector-icon">✓</div>';

          noLogoItem.appendChild(noLogoContent);
          noLogoItem.appendChild(selector);

          // Attach event listeners
          this.attachLogoEventListeners(noLogoItem, "none");

          return noLogoItem;
        }

        attachLogoEventListeners(logoItem, logoPath) {
          // Click handler
          logoItem.addEventListener("click", () => {
            this.selectLogo(logoPath);
          });

          // Keyboard handler
          logoItem.addEventListener("keydown", (e) => {
            if (e.key === "Enter" || e.key === " ") {
              e.preventDefault();
              this.selectLogo(logoPath);
            }
          });
        }

        selectLogo(logoPath) {
          try {
            // Update application state
            updateAppState("assets.selectedLogo", logoPath);

            // Update preview
            updatePreview();

            console.log(`Logo selected: ${logoPath}`);
          } catch (error) {
            console.error("Failed to select logo:", error);
            this.showAssetError(
              "logos",
              "Failed to select logo. Please try again."
            );
          }
        }

        updateLogoSelection(selectedLogoPath) {
          const logoItems = document.querySelectorAll(".logo-item");

          logoItems.forEach((item) => {
            const isSelected = item.dataset.logoPath === selectedLogoPath;
            item.classList.toggle("active", isSelected);
            item.setAttribute("aria-selected", isSelected.toString());
          });
        }

        updateLogoScaleVisibility(selectedLogoPath) {
          const logoScaleGroup = document.querySelector(
            'label[for="logoScale"]'
          )?.parentElement;
          if (logoScaleGroup) {
            if (selectedLogoPath === "none") {
              logoScaleGroup.style.display = "none";
            } else {
              logoScaleGroup.style.display = "block";
            }
          }
        }

        async loadBackgrounds() {
          const loadingElement = document.getElementById("backgrounds-loading");
          const galleryElement = document.getElementById("backgrounds-gallery");
          const errorElement = document.getElementById("backgrounds-error");

          try {
            // Show loading state
            loadingElement.style.display = "flex";
            galleryElement.style.display = "none";
            errorElement.style.display = "none";

            // Clear existing gallery
            galleryElement.innerHTML = "";

            // Load each background
            const backgroundPromises = this.backgroundList.map((bgPath) =>
              this.loadBackgroundItem(bgPath)
            );
            const backgroundResults = await Promise.allSettled(
              backgroundPromises
            );

            // Process results
            const successfulBackgrounds = [];
            backgroundResults.forEach((result, index) => {
              if (result.status === "fulfilled") {
                successfulBackgrounds.push(result.value);
              } else {
                console.warn(
                  `Failed to load background: ${this.backgroundList[index]}`,
                  result.reason
                );
              }
            });

            if (successfulBackgrounds.length === 0) {
              throw new Error("No backgrounds could be loaded");
            }

            // Populate gallery
            successfulBackgrounds.forEach((backgroundElement) => {
              galleryElement.appendChild(backgroundElement);
            });

            // Update selection state
            const selectedBackground = getAppState("assets.selectedBackground");
            if (selectedBackground) {
              this.updateBackgroundSelection(selectedBackground);
            }

            // Show gallery
            loadingElement.style.display = "none";
            galleryElement.style.display = "grid";

            console.log(
              `Loaded ${successfulBackgrounds.length} backgrounds successfully`
            );
          } catch (error) {
            console.error("Failed to load backgrounds:", error);
            loadingElement.style.display = "none";
            errorElement.style.display = "block";
            errorElement.textContent =
              "Failed to load backgrounds. Please refresh the page.";
          }
        }

        async loadBackgroundItem(backgroundPath) {
          return new Promise((resolve, reject) => {
            // Check cache first
            if (this.backgroundCache.has(backgroundPath)) {
              const cachedElement = this.backgroundCache
                .get(backgroundPath)
                .cloneNode(true);
              this.attachBackgroundEventListeners(
                cachedElement,
                backgroundPath
              );
              resolve(cachedElement);
              return;
            }

            // Create background item element
            const backgroundItem = document.createElement("div");
            backgroundItem.className = "asset-item background-item";
            backgroundItem.dataset.backgroundPath = backgroundPath;
            backgroundItem.setAttribute("tabindex", "0");
            backgroundItem.setAttribute("role", "button");
            backgroundItem.setAttribute(
              "aria-label",
              `Select background ${backgroundPath}`
            );

            // Create thumbnail image
            const thumbnail = document.createElement("img");
            thumbnail.className = "asset-thumbnail background-thumbnail";
            thumbnail.alt = `Background ${backgroundPath}`;

            // Create selector indicator
            const selector = document.createElement("div");
            selector.className = "asset-selector";
            selector.innerHTML = '<div class="asset-selector-icon">✓</div>';

            // Handle image load
            thumbnail.onload = () => {
              backgroundItem.appendChild(thumbnail);
              backgroundItem.appendChild(selector);

              // Cache the element
              this.backgroundCache.set(
                backgroundPath,
                backgroundItem.cloneNode(true)
              );

              // Attach event listeners
              this.attachBackgroundEventListeners(
                backgroundItem,
                backgroundPath
              );

              resolve(backgroundItem);
            };

            // Handle image error
            thumbnail.onerror = () => {
              reject(
                new Error(`Failed to load background image: ${backgroundPath}`)
              );
            };

            // Set image source
            thumbnail.src = backgroundPath;
          });
        }

        attachBackgroundEventListeners(backgroundItem, backgroundPath) {
          // Click handler
          backgroundItem.addEventListener("click", () => {
            this.selectBackground(backgroundPath);
          });

          // Keyboard handler
          backgroundItem.addEventListener("keydown", (e) => {
            if (e.key === "Enter" || e.key === " ") {
              e.preventDefault();
              this.selectBackground(backgroundPath);
            }
          });
        }

        selectBackground(backgroundPath) {
          try {
            // Update application state
            updateAppState("assets.selectedBackground", backgroundPath);

            // Clear custom background if selecting a preset
            if (getAppState("assets.customBackground")) {
              updateAppState("assets.customBackground", null);
            }

            // Update preview
            updatePreview();

            console.log(`Background selected: ${backgroundPath}`);
          } catch (error) {
            console.error("Failed to select background:", error);
            this.showAssetError(
              "backgrounds",
              "Failed to select background. Please try again."
            );
          }
        }

        updateBackgroundSelection(selectedBackgroundPath) {
          const backgroundItems = document.querySelectorAll(".background-item");

          backgroundItems.forEach((item) => {
            const isSelected =
              item.dataset.backgroundPath === selectedBackgroundPath;
            item.classList.toggle("active", isSelected);
            item.setAttribute("aria-selected", isSelected.toString());
          });
        }

        setupUploadArea() {
          const uploadArea = document.getElementById("upload-area");
          const uploadInput = document.getElementById("upload-input");
          const uploadError = document.getElementById("upload-error");

          if (!uploadArea || !uploadInput) {
            console.error("Upload elements not found");
            return;
          }

          // Click to upload
          uploadArea.addEventListener("click", () => {
            uploadInput.click();
          });

          // File input change
          uploadInput.addEventListener("change", (e) => {
            const file = e.target.files[0];
            if (file) {
              this.handleFileUpload(file);
            }
          });

          // Drag and drop
          uploadArea.addEventListener("dragover", (e) => {
            e.preventDefault();
            uploadArea.classList.add("dragover");
          });

          uploadArea.addEventListener("dragleave", (e) => {
            e.preventDefault();
            uploadArea.classList.remove("dragover");
          });

          uploadArea.addEventListener("drop", (e) => {
            e.preventDefault();
            uploadArea.classList.remove("dragover");

            const files = e.dataTransfer.files;
            if (files.length > 0) {
              this.handleFileUpload(files[0]);
            }
          });
        }

        async handleFileUpload(file) {
          const uploadError = document.getElementById("upload-error");

          try {
            // Show loading state
            loadingManager.show(
              "Processing Upload",
              `Processing ${file.name}...`
            );

            // Validate file
            this.validateUploadedFile(file);

            loadingManager.updateMessage(
              "Processing Image",
              "Resizing and optimizing..."
            );

            // Process image
            const processedImage = await this.processUploadedImage(file);

            if (!processedImage) {
              throw new Error("Failed to process uploaded image");
            }

            // Update application state
            updateAppState("assets.customBackground", processedImage);
            updateAppState("assets.selectedBackground", null); // Clear preset selection

            // Update preview
            updatePreview();

            // Hide error
            uploadError.style.display = "none";

            // Show success notification
            notificationManager.success(
              "Upload Successful",
              `${file.name} has been uploaded and processed successfully.`,
              { duration: 4000 }
            );

            console.log("File uploaded successfully:", file.name);
          } catch (error) {
            console.error("File upload failed:", error);

            // Show user-friendly error notification
            notificationManager.error(
              "Upload Failed",
              errorBoundary.getUserFriendlyMessage(error, "Upload"),
              {
                duration: 6000,
                actions: [
                  {
                    id: "retry",
                    label: "Try Again",
                    handler: () => {
                      const uploadInput =
                        document.getElementById("upload-input");
                      if (uploadInput) uploadInput.click();
                    },
                  },
                ],
              }
            );

            this.showAssetError("upload", error.message);
            errorBoundary.handleError(error, "Upload");
          } finally {
            loadingManager.hide();
          }
        }

        validateUploadedFile(file) {
          const validTypes = ["image/jpeg", "image/png", "image/webp"];
          const maxSize = 10 * 1024 * 1024; // 10MB

          if (!validTypes.includes(file.type)) {
            throw new Error(
              "Please upload a valid image file (JPEG, PNG, or WebP)"
            );
          }

          if (file.size > maxSize) {
            throw new Error("File size must be less than 10MB");
          }

          return true;
        }

        async processUploadedImage(file) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();

            reader.onload = (e) => {
              const img = new Image();

              img.onload = () => {
                try {
                  // Create canvas for processing
                  const canvas = document.createElement("canvas");
                  const ctx = canvas.getContext("2d");

                  // Set target dimensions (16:9 aspect ratio)
                  const targetWidth = 1920;
                  const targetHeight = 1080;

                  canvas.width = targetWidth;
                  canvas.height = targetHeight;

                  // Calculate scaling to maintain aspect ratio
                  const imgAspect = img.width / img.height;
                  const targetAspect = targetWidth / targetHeight;

                  let drawWidth, drawHeight, drawX, drawY;

                  if (imgAspect > targetAspect) {
                    // Image is wider than target - fit by height
                    drawHeight = targetHeight;
                    drawWidth = drawHeight * imgAspect;
                    drawX = (targetWidth - drawWidth) / 2;
                    drawY = 0;
                  } else {
                    // Image is taller than target - fit by width
                    drawWidth = targetWidth;
                    drawHeight = drawWidth / imgAspect;
                    drawX = 0;
                    drawY = (targetHeight - drawHeight) / 2;
                  }

                  // Fill background with black
                  ctx.fillStyle = "#000000";
                  ctx.fillRect(0, 0, targetWidth, targetHeight);

                  // Draw image
                  ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);

                  // Convert to data URL
                  const dataUrl = canvas.toDataURL("image/jpeg", 0.9);

                  resolve({
                    dataUrl: dataUrl,
                    originalName: file.name,
                    processedWidth: targetWidth,
                    processedHeight: targetHeight,
                  });
                } catch (error) {
                  reject(
                    new Error("Failed to process image: " + error.message)
                  );
                }
              };

              img.onerror = () => {
                reject(new Error("Failed to load uploaded image"));
              };

              img.src = e.target.result;
            };

            reader.onerror = () => {
              reject(new Error("Failed to read uploaded file"));
            };

            reader.readAsDataURL(file);
          });
        }

        showUploadSuccess() {
          const uploadArea = document.getElementById("upload-area");
          if (!uploadArea) return;

          // Temporarily show success state
          const originalContent = uploadArea.innerHTML;
          uploadArea.innerHTML = `
                  <div class="upload-icon">✅</div>
                  <div class="upload-text">Upload successful!</div>
                  <div class="upload-hint">Your custom background has been applied</div>
              `;

          // Restore original content after 3 seconds
          setTimeout(() => {
            uploadArea.innerHTML = originalContent;
          }, 3000);
        }

        showAssetError(section, message) {
          try {
            const errorElement = document.getElementById(`${section}-error`);
            if (!errorElement) {
              console.warn(`Error element not found for section: ${section}`);
              return;
            }

            // Create enhanced error display with retry option
            errorElement.innerHTML = `
                      <div class="error-boundary">
                          <div class="error-boundary-header">
                              <span class="error-boundary-icon">⚠️</span>
                              Asset Loading Error
                          </div>
                          <div class="error-boundary-message">${message}</div>
                          <div class="error-boundary-actions">
                              <button class="error-retry-btn" onclick="window.assetManager.refreshAssets()">
                                  Retry Loading
                              </button>
                              <button class="error-dismiss-btn" onclick="this.parentElement.parentElement.parentElement.style.display='none'">
                                  Dismiss
                              </button>
                          </div>
                      </div>
                  `;

            errorElement.style.display = "block";

            // Auto-hide after 10 seconds (longer for enhanced error)
            setTimeout(() => {
              if (errorElement.style.display !== "none") {
                errorElement.style.display = "none";
              }
            }, 10000);
          } catch (error) {
            console.error("Failed to show asset error:", error);
            // Fallback to simple error display
            const errorElement = document.getElementById(`${section}-error`);
            if (errorElement) {
              errorElement.textContent = message;
              errorElement.style.display = "block";
            }
          }
        }

        showUploadSuccess() {
          try {
            notificationManager.success(
              "Upload Complete",
              "Your custom background has been uploaded and is ready to use.",
              { duration: 4000 }
            );
          } catch (error) {
            console.error("Failed to show upload success:", error);
          }
        }

        // Fallback mechanism for failed asset loads
        handleAssetLoadFailure(assetType, assetPath) {
          try {
            console.warn(`Asset load failure: ${assetType} - ${assetPath}`);

            switch (assetType) {
              case "logo":
                // Fallback to default logo or text-based logo
                notificationManager.warning(
                  "Logo Load Failed",
                  "Using default logo. You can try selecting a different logo.",
                  { duration: 4000 }
                );
                break;
              case "background":
                // Fallback to gradient background
                notificationManager.info(
                  "Background Load Failed",
                  "Using gradient background. You can try uploading a custom image.",
                  { duration: 4000 }
                );
                break;
            }
          } catch (error) {
            console.error("Failed to handle asset load failure:", error);
          }
        }

        // Public methods for external access
        getSelectedLogo() {
          return getAppState("assets.selectedLogo");
        }

        getSelectedBackground() {
          return getAppState("assets.selectedBackground");
        }

        getCustomBackground() {
          return getAppState("assets.customBackground");
        }

        refreshAssets() {
          switch (this.currentTab) {
            case "logos":
              this.loadLogos();
              break;
            case "backgrounds":
              this.loadBackgrounds();
              break;
          }
        }
      }

      // Initialize asset manager
      let assetManager;

      // Canvas Rendering System
      class CanvasRenderer {
        constructor() {
          this.canvas = document.getElementById("preview-canvas");
          this.ctx = this.canvas.getContext("2d");
          this.outputWidth = 1920;
          this.outputHeight = 1080;
          this.aspectRatio = 16 / 9;

          this.init();
        }

        init() {
          if (!this.canvas || !this.ctx) {
            console.error("Canvas or context not found");
            return;
          }

          // Set canvas dimensions for 1920x1080 output
          this.canvas.width = this.outputWidth;
          this.canvas.height = this.outputHeight;

          // Set up responsive scaling
          this.setupResponsiveScaling();

          // Initialize coordinate system
          this.setupCoordinateSystem();

          console.log(
            "Canvas renderer initialized with dimensions:",
            this.outputWidth,
            "x",
            this.outputHeight
          );

          // Test canvas drawing capability
          this.testCanvasDrawing();
        }

        setupResponsiveScaling() {
          // The canvas will be scaled via CSS to fit the container
          // while maintaining the 16:9 aspect ratio
          const container = this.canvas.parentElement;
          if (container) {
            // CSS already handles responsive scaling via aspect-ratio and max-width
            console.log("Responsive scaling configured via CSS");
          }
        }

        setupCoordinateSystem() {
          // Set up coordinate system for 1920x1080 output
          // Origin (0,0) is top-left corner
          // X increases to the right, Y increases downward
          this.ctx.textBaseline = "top";
          this.ctx.textAlign = "left";

          // Enable high-quality rendering
          this.ctx.imageSmoothingEnabled = true;
          this.ctx.imageSmoothingQuality = "high";

          console.log("Coordinate system configured for 1920x1080 output");
        }

        testCanvasDrawing() {
          // Test if canvas can draw
          this.ctx.fillStyle = "#ff0000";
          this.ctx.fillRect(10, 10, 100, 100);
          console.log("Canvas test drawing completed - red square at (10,10)");

          // Clear the test drawing
          setTimeout(() => {
            this.ctx.clearRect(10, 10, 100, 100);
            console.log("Canvas test drawing cleared");
          }, 1000);
        }

        // Basic drawing utilities
        clear() {
          this.ctx.clearRect(0, 0, this.outputWidth, this.outputHeight);
          console.log(
            "Canvas cleared - dimensions:",
            this.outputWidth,
            "x",
            this.outputHeight
          );
        }

        drawBackground(color = "#f8f9fa") {
          this.ctx.fillStyle = color;
          this.ctx.fillRect(0, 0, this.outputWidth, this.outputHeight);
          console.log(
            "Background drawn with color:",
            color,
            "at dimensions:",
            this.outputWidth,
            "x",
            this.outputHeight
          );
        }

        drawImage(image, x, y, width, height) {
          if (image && image.complete) {
            this.ctx.drawImage(image, x, y, width, height);
          }
        }

        drawText(text, x, y, options = {}) {
          const {
            font = "24px Roboto",
            color = "#000000",
            align = "left",
            baseline = "top",
            maxWidth = null,
            lineHeight = 1.2,
          } = options;

          this.ctx.save();
          this.ctx.font = font;
          this.ctx.fillStyle = color;
          this.ctx.textAlign = align;
          this.ctx.textBaseline = baseline;

          if (maxWidth) {
            this.ctx.fillText(text, x, y, maxWidth);
          } else {
            this.ctx.fillText(text, x, y);
          }

          this.ctx.restore();
        }

        drawRoundedRect(x, y, width, height, radius, options = {}) {
          const {
            fillStyle = null,
            strokeStyle = null,
            lineWidth = 1,
          } = options;

          this.ctx.save();
          this.ctx.beginPath();
          this.ctx.roundRect(x, y, width, height, radius);

          if (fillStyle) {
            this.ctx.fillStyle = fillStyle;
            this.ctx.fill();
          }

          if (strokeStyle) {
            this.ctx.strokeStyle = strokeStyle;
            this.ctx.lineWidth = lineWidth;
            this.ctx.stroke();
          }

          this.ctx.restore();
        }

        drawOverlay(x, y, width, height, color, opacity = 0.8) {
          this.ctx.save();
          this.ctx.globalAlpha = opacity;
          this.ctx.fillStyle = color;
          this.ctx.fillRect(x, y, width, height);
          this.ctx.restore();
        }

        // Utility methods for coordinate calculations
        getTextWidth(text, font) {
          this.ctx.save();
          this.ctx.font = font;
          const width = this.ctx.measureText(text).width;
          this.ctx.restore();
          return width;
        }

        getTextHeight(font) {
          this.ctx.save();
          this.ctx.font = font;
          const metrics = this.ctx.measureText("Mg");
          const height =
            metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
          this.ctx.restore();
          return height || parseInt(font.match(/\d+/)[0]); // Fallback to font size
        }

        // Position calculation utilities
        calculateTextPosition(
          position,
          containerWidth,
          containerHeight,
          textWidth,
          textHeight,
          padding = 20
        ) {
          let x, y;

          switch (position) {
            case "top-right":
              x = containerWidth - textWidth - padding;
              y = padding;
              break;
            case "middle":
              x = (containerWidth - textWidth) / 2;
              y = (containerHeight - textHeight) / 2;
              break;
            case "middle-right":
              x = containerWidth - textWidth - padding;
              y = (containerHeight - textHeight) / 2;
              break;
            case "bottom-left":
              x = padding;
              y = containerHeight - textHeight - padding;
              break;
            case "bottom-right":
              x = containerWidth - textWidth - padding;
              y = containerHeight - textHeight - padding;
              break;
            default:
              x = padding;
              y = padding;
          }

          return { x, y };
        }

        // Layout 1 rendering function
        renderLayout1(backgroundImage = null, logoImage = null) {
          console.log("Starting renderLayout1 with:", {
            backgroundImage: !!backgroundImage,
            logoImage: !!logoImage,
          });
          this.clear();

          // Draw background image or default background
          if (backgroundImage && backgroundImage.complete) {
            console.log("Drawing background image");
            this.drawImage(
              backgroundImage,
              0,
              0,
              this.outputWidth,
              this.outputHeight
            );
          } else {
            console.log("Drawing default gradient background");
            // Default gradient background
            const gradient = this.ctx.createLinearGradient(
              0,
              0,
              this.outputWidth,
              this.outputHeight
            );
            gradient.addColorStop(0, "#667eea");
            gradient.addColorStop(1, "#764ba2");
            this.ctx.fillStyle = gradient;
            this.ctx.fillRect(0, 0, this.outputWidth, this.outputHeight);
            console.log("Gradient background drawn");
          }

          // Draw rounded black frame
          const frameMargin = 20;
          const frameRadius = 20;
          this.drawRoundedRect(
            frameMargin,
            frameMargin,
            this.outputWidth - frameMargin * 2,
            this.outputHeight - frameMargin * 2,
            frameRadius,
            {
              strokeStyle: "rgba(0, 0, 0, 0.8)",
              lineWidth: 4,
            }
          );

          // Draw transparent black overlay on right side (dynamic size and opacity)
          const overlaySize = getAppState("layout.overlay.size") || 40; // Percentage of width
          const overlayOpacity = getAppState("layout.overlay.opacity") || 80; // Percentage opacity

          const overlayWidthPercent = overlaySize / 100; // Convert to decimal
          const overlayOpacityDecimal = overlayOpacity / 100; // Convert to decimal

          const overlayStartX = this.outputWidth * (1 - overlayWidthPercent); // Start position
          const overlayWidth = this.outputWidth * overlayWidthPercent; // Width of overlay

          this.drawOverlay(
            overlayStartX,
            frameMargin,
            overlayWidth - frameMargin,
            this.outputHeight - frameMargin * 2,
            `rgba(0, 0, 0, ${overlayOpacityDecimal})`,
            overlayOpacityDecimal
          );

          // Position logo in top-left corner (larger and more visible)
          const selectedLogo = getAppState("assets.selectedLogo");
          console.log("Layout1 - Logo rendering:", {
            selectedLogo: selectedLogo,
            logoImage: logoImage,
            hasLogo: !!logoImage,
            isComplete: logoImage ? logoImage.complete : false,
          });

          // Only render logo if not "none" and image is available
          if (selectedLogo !== "none" && logoImage && logoImage.complete) {
            // Get logo size from state (with default)
            const logoScale = getAppState("assets.logoScale") || 1.0;
            const baseLogoWidth = 400; // Base width for 500×300 aspect ratio
            const baseLogoHeight = 240; // Base height for 500×300 aspect ratio

            const logoWidth = baseLogoWidth * logoScale;
            const logoHeight = baseLogoHeight * logoScale;
            const logoMargin = 40; // Reduced from 80 to move closer to corner

            console.log(
              "Drawing logo image at:",
              logoMargin,
              logoMargin,
              logoWidth,
              logoHeight
            );
            console.log(
              "Logo scale applied:",
              logoScale,
              "Final size:",
              logoWidth,
              "x",
              logoHeight
            );
            this.drawImage(
              logoImage,
              logoMargin,
              logoMargin,
              logoWidth,
              logoHeight
            );
          } else if (
            selectedLogo !== "none" &&
            (!logoImage || !logoImage.complete)
          ) {
            // Draw placeholder logo only if not "none" (larger)
            console.log("Drawing placeholder logo - no valid logo image");
            this.drawText("DDAM LOGO", 40, 80, {
              font: "bold 64px Roboto",
              color: "white",
            });
          } else {
            console.log("No logo selected - skipping logo rendering");
          }

          // Add copyright text in bottom-left position
          const copyrightText =
            "©2025 Dentsu Data Artist Mongol LLC. All Rights Reserved.";
          this.drawText(copyrightText, 40, this.outputHeight - 60, {
            font: "28px Roboto", // Increased font size for better visibility
            color: "rgba(255, 255, 255, 0.8)",
          });

          // Implement flexible text positioning
          this.renderLayout1Text();

          console.log("renderLayout1 completed successfully");
        }

        renderLayout1Text() {
          const textFields = getAppState("text.fields");
          const typography = getAppState("text.typography");
          const position =
            getAppState("text.positioning.layout1") || "top-right";

          console.log("Layout1 - Rendering text with position:", position);

          if (!textFields || !typography) return;

          // Scale up font sizes for better visibility (multiply by 3 for 1920x1080)
          const baseFontSize = typography.fontSize * 3;
          const textColor =
            typography.textColor === "white" ? "#ffffff" : "#000000";
          const englishFont = typography.englishFont;
          const japaneseFont = typography.japaneseFont;

          // Prepare text lines with larger fonts
          const lines = [
            {
              text: textFields.fullName,
              font: `bold ${baseFontSize}px ${englishFont}`,
            },
            {
              text: textFields.nickname,
              font: `${baseFontSize}px ${japaneseFont}`,
            },
            {
              text: textFields.positionEn,
              font: `${Math.round(baseFontSize * 0.8)}px ${englishFont}`,
            },
            {
              text: textFields.positionJp,
              font: `${Math.round(baseFontSize * 0.8)}px ${japaneseFont}`,
            },
          ];

          // Calculate text block dimensions
          let maxWidth = 0;
          let totalHeight = 0;
          const lineHeight = baseFontSize * 1.3;

          lines.forEach((line) => {
            const width = this.getTextWidth(line.text, line.font);
            maxWidth = Math.max(maxWidth, width);
            totalHeight += lineHeight;
          });

          // Calculate position for Layout 1 with proper alignment
          let textPosition;
          const padding = 60;

          console.log("Layout1 - Calculating position for:", position);

          switch (position) {
            case "top-right":
              textPosition = {
                x: this.outputWidth - padding,
                y: padding + 100, // Closer to top, below logo area
                align: "right",
              };
              break;
            case "middle-right":
              textPosition = {
                x: this.outputWidth - padding,
                y: (this.outputHeight - totalHeight) / 2,
                align: "right",
              };
              break;
            case "bottom-right":
              textPosition = {
                x: this.outputWidth - padding,
                y: this.outputHeight - totalHeight - padding - 100, // Above copyright
                align: "right",
              };
              break;
            default:
              textPosition = {
                x: this.outputWidth - padding,
                y: padding + 280,
                align: "right",
              };
          }

          // Draw text lines with proper alignment
          let currentY = textPosition.y;
          lines.forEach((line) => {
            this.drawText(line.text, textPosition.x, currentY, {
              font: line.font,
              color: textColor,
              align: textPosition.align,
            });
            currentY += lineHeight;
          });
        }

        // Layout 2 rendering function
        renderLayout2(backgroundImage = null, logoImage = null) {
          this.clear();

          // Draw background image or default background
          if (backgroundImage && backgroundImage.complete) {
            this.drawImage(
              backgroundImage,
              0,
              0,
              this.outputWidth,
              this.outputHeight
            );
          } else {
            // Default gradient background
            const gradient = this.ctx.createLinearGradient(
              0,
              0,
              this.outputWidth,
              this.outputHeight
            );
            gradient.addColorStop(0, "#667eea");
            gradient.addColorStop(1, "#764ba2");
            this.ctx.fillStyle = gradient;
            this.ctx.fillRect(0, 0, this.outputWidth, this.outputHeight);
          }

          // Position logo in top-left corner (larger and more visible)
          const selectedLogo = getAppState("assets.selectedLogo");
          console.log("Layout2 - Logo rendering:", {
            selectedLogo: selectedLogo,
            logoImage: logoImage,
            hasLogo: !!logoImage,
            isComplete: logoImage ? logoImage.complete : false,
          });

          // Only render logo if not "none" and image is available
          if (selectedLogo !== "none" && logoImage && logoImage.complete) {
            // Get logo size from state (with default)
            const logoScale = getAppState("assets.logoScale") || 1.0;
            const baseLogoWidth = 400; // Base width for 500×300 aspect ratio
            const baseLogoHeight = 240; // Base height for 500×300 aspect ratio

            const logoWidth = baseLogoWidth * logoScale;
            const logoHeight = baseLogoHeight * logoScale;
            const logoMargin = 40; // Reduced from 80 to move closer to corner

            console.log(
              "Layout2 - Logo scale applied:",
              logoScale,
              "Final size:",
              logoWidth,
              "x",
              logoHeight
            );
            this.drawImage(
              logoImage,
              logoMargin,
              logoMargin,
              logoWidth,
              logoHeight
            );
          } else if (
            selectedLogo !== "none" &&
            (!logoImage || !logoImage.complete)
          ) {
            // Draw placeholder logo only if not "none" (larger)
            this.drawText("DDAM LOGO", 40, 80, {
              font: "bold 64px Roboto",
              color: "white",
            });
          } else {
            console.log("No logo selected - skipping logo rendering");
          }

          // Add copyright text in bottom-left position
          const copyrightText =
            "©2025 Dentsu Data Artist Mongol LLC. All Rights Reserved.";
          this.drawText(copyrightText, 40, this.outputHeight - 60, {
            font: "28px Roboto", // Increased font size for better visibility
            color: "rgba(255, 255, 255, 0.8)",
          });

          // Implement text positioning options
          this.renderLayout2Text();
        }

        renderLayout2Text() {
          const textFields = getAppState("text.fields");
          const typography = getAppState("text.typography");
          const position =
            getAppState("text.positioning.layout2") || "top-right";

          console.log("Layout2 - Rendering text with position:", position);

          if (!textFields || !typography) return;

          // Scale up font sizes for better visibility (multiply by 3 for 1920x1080)
          const baseFontSize = typography.fontSize * 3;
          const textColor =
            typography.textColor === "white" ? "#ffffff" : "#000000";
          const englishFont = typography.englishFont;
          const japaneseFont = typography.japaneseFont;

          // Prepare text lines with larger fonts
          const lines = [
            {
              text: textFields.fullName,
              font: `bold ${baseFontSize}px ${englishFont}`,
            },
            {
              text: textFields.nickname,
              font: `${baseFontSize}px ${japaneseFont}`,
            },
            {
              text: textFields.positionEn,
              font: `${Math.round(baseFontSize * 0.8)}px ${englishFont}`,
            },
            {
              text: textFields.positionJp,
              font: `${Math.round(baseFontSize * 0.8)}px ${japaneseFont}`,
            },
          ];

          // Calculate text block dimensions
          let maxWidth = 0;
          let totalHeight = 0;
          const lineHeight = baseFontSize * 1.3;

          lines.forEach((line) => {
            const width = this.getTextWidth(line.text, line.font);
            maxWidth = Math.max(maxWidth, width);
            totalHeight += lineHeight;
          });

          // Calculate position for Layout 2 positioning options
          let textPosition;
          const padding = 60;

          console.log("Layout2 - Calculating position for:", position);

          switch (position) {
            case "top-right":
              textPosition = {
                x: this.outputWidth - padding,
                y: padding + 100, // Closer to top, below logo area
                align: "right",
              };
              break;
            case "top-left":
              textPosition = {
                x: padding,
                y: padding + 100, // Closer to top, below logo area
                align: "left",
              };
              break;
            case "middle":
              textPosition = {
                x: this.outputWidth / 2,
                y: (this.outputHeight - totalHeight) / 2,
                align: "center",
              };
              break;
            case "bottom-left":
              textPosition = {
                x: padding,
                y: this.outputHeight - totalHeight - padding - 100, // Above copyright
                align: "left",
              };
              break;
            case "bottom-right":
              textPosition = {
                x: this.outputWidth - padding,
                y: this.outputHeight - totalHeight - padding - 100, // Above copyright
                align: "right",
              };
              break;
            default:
              textPosition = {
                x: this.outputWidth - padding,
                y: padding + 280,
                align: "right",
              };
          }

          // Draw text lines with proper alignment
          let currentY = textPosition.y;
          lines.forEach((line) => {
            this.drawText(line.text, textPosition.x, currentY, {
              font: line.font,
              color: textColor,
              align: textPosition.align,
            });
            currentY += lineHeight;
          });
        }

        // Render placeholder content
        renderPlaceholder() {
          this.clear();
          this.drawBackground("#f8f9fa");

          // Draw placeholder text
          this.drawText(
            "Preview Loading...",
            this.outputWidth / 2,
            this.outputHeight / 2 - 60,
            {
              font: "48px Roboto",
              color: "#6c757d",
              align: "center",
              baseline: "middle",
            }
          );

          this.drawText(
            "Canvas rendering system ready",
            this.outputWidth / 2,
            this.outputHeight / 2,
            {
              font: "24px Roboto",
              color: "#6c757d",
              align: "center",
              baseline: "middle",
            }
          );

          // Show current state info
          const currentLayout = getAppState("layout.type");
          const currentName = getAppState("text.fields.fullName");

          this.drawText(
            `Selected Layout: ${
              currentLayout === "layout1" ? "Layout 1" : "Layout 2"
            }`,
            this.outputWidth / 2,
            this.outputHeight / 2 + 60,
            {
              font: "20px Roboto",
              color: "#667eea",
              align: "center",
              baseline: "middle",
            }
          );

          this.drawText(
            `User: ${currentName}`,
            this.outputWidth / 2,
            this.outputHeight / 2 + 90,
            {
              font: "20px Roboto",
              color: "#6c757d",
              align: "center",
              baseline: "middle",
            }
          );
        }
      }

      // Global canvas renderer instance
      let canvasRenderer = null;

      // Asset loading utilities
      const assetCache = new Map();

      function loadImage(src) {
        return new Promise((resolve, reject) => {
          try {
            if (!src) {
              console.warn("loadImage: No source provided");
              resolve(null);
              return;
            }

            if (assetCache.has(src)) {
              console.log(`Using cached image: ${src}`);
              resolve(assetCache.get(src));
              return;
            }

            console.log(`Loading image: ${src}`);
            const img = new Image();

            // Don't set crossOrigin for local files to avoid CORS issues
            if (!src.startsWith("http")) {
              // Local file - don't set crossOrigin
            } else {
              img.crossOrigin = "anonymous";
            }

            img.onload = () => {
              try {
                console.log(`Successfully loaded image: ${src}`, {
                  width: img.width,
                  height: img.height,
                  complete: img.complete,
                });
                assetCache.set(src, img);
                resolve(img);
              } catch (error) {
                console.error(`Error processing loaded image: ${src}`, error);
                errorBoundary.handleError(error, "ImageLoad");
                resolve(null);
              }
            };

            img.onerror = (error) => {
              console.error(`Failed to load image: ${src}`, error);

              // Show user notification for critical image load failures
              if (src.includes("logo") || src.includes("background")) {
                notificationManager.warning(
                  "Image Load Failed",
                  `Failed to load ${
                    src.includes("logo") ? "logo" : "background"
                  } image. Using fallback instead.`,
                  { duration: 4000 }
                );
              }

              errorBoundary.handleError(
                new Error(`Image load failed: ${src}`),
                "ImageLoad"
              );
              resolve(null);
            };

            // Set timeout for image loading
            setTimeout(() => {
              if (!img.complete) {
                console.warn(`Image load timeout: ${src}`);
                notificationManager.warning(
                  "Slow Connection",
                  "Images are taking longer to load. Please check your connection.",
                  { duration: 3000 }
                );
              }
            }, 10000); // 10 second timeout warning

            img.src = src;
          } catch (error) {
            console.error(`Error in loadImage: ${src}`, error);
            errorBoundary.handleError(error, "ImageLoad");
            resolve(null);
          }
        });
      }

      // CORS-safe image loading for export
      function loadImageForExport(src) {
        return new Promise((resolve, reject) => {
          if (!src) {
            console.log("loadImageForExport: No source provided");
            resolve(null);
            return;
          }

          console.log(`loadImageForExport: Starting load for ${src}`);

          // For local files, we can load them directly
          if (!src.startsWith("http")) {
            const img = new Image();

            img.onload = () => {
              console.log(
                `loadImageForExport: Image loaded successfully ${src} (${img.width}x${img.height})`
              );

              // Convert to data URL to avoid CORS issues
              try {
                const canvas = document.createElement("canvas");
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext("2d");
                ctx.drawImage(img, 0, 0);

                const dataURL = canvas.toDataURL("image/png");
                console.log(
                  `loadImageForExport: Converted to data URL, length: ${dataURL.length}`
                );

                const exportImg = new Image();
                exportImg.onload = () => {
                  console.log(
                    `loadImageForExport: Export image ready ${src} (${exportImg.width}x${exportImg.height})`
                  );
                  resolve(exportImg);
                };
                exportImg.onerror = (error) => {
                  console.error(
                    `loadImageForExport: Failed to create export image for ${src}:`,
                    error
                  );
                  resolve(null);
                };
                exportImg.src = dataURL;
              } catch (error) {
                console.error(
                  `loadImageForExport: Failed to convert image to data URL ${src}:`,
                  error
                );
                resolve(null);
              }
            };

            img.onerror = (error) => {
              console.error(
                `loadImageForExport: Failed to load image ${src}:`,
                error
              );
              resolve(null);
            };

            img.src = src;
          } else {
            // For external URLs, try with CORS
            console.log(`loadImageForExport: Loading external image ${src}`);
            const img = new Image();
            img.crossOrigin = "anonymous";

            img.onload = () => {
              console.log(`loadImageForExport: External image loaded ${src}`);
              try {
                // Test if we can read the image data
                const canvas = document.createElement("canvas");
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext("2d");
                ctx.drawImage(img, 0, 0);

                const dataURL = canvas.toDataURL("image/png");
                const exportImg = new Image();
                exportImg.onload = () => {
                  console.log(
                    `loadImageForExport: External export image ready ${src}`
                  );
                  resolve(exportImg);
                };
                exportImg.src = dataURL;
              } catch (error) {
                console.error(
                  `loadImageForExport: CORS issue with external image ${src}:`,
                  error
                );
                resolve(null);
              }
            };

            img.onerror = (error) => {
              console.error(
                `loadImageForExport: Failed to load external image ${src}:`,
                error
              );
              resolve(null);
            };

            img.src = src;
          }
        });
      }

      // Real-time Preview Update System
      class PreviewUpdateManager {
        constructor() {
          this.debounceTimer = null;
          this.debounceDelay = 150; // 150ms for smooth performance
          this.isUpdating = false;
          this.pendingUpdate = false;

          this.init();
        }

        init() {
          // Listen for all state changes that affect preview
          stateEvents.on("stateChange", (data) => {
            this.handleStateChange(data);
          });

          // Add event listeners for all form controls
          this.attachFormListeners();

          console.log("Preview update manager initialized");
        }

        handleStateChange(data) {
          const { path } = data;

          // Check if this state change affects the preview
          const previewAffectingPaths = [
            "layout.type",
            "text.fields.",
            "text.typography.",
            "text.positioning.",
            "assets.",
          ];

          const shouldUpdate = previewAffectingPaths.some((prefix) =>
            path.startsWith(prefix)
          );

          if (shouldUpdate) {
            this.debouncedUpdate();
          }
        }

        attachFormListeners() {
          // Layout selection listeners (already handled by LayoutSelector)
          // Text input listeners (already handled by TextInputHandler)
          // Typography listeners (already handled by FontManager)

          // Add additional listeners for immediate updates on certain controls
          const immediateUpdateControls = [
            "japaneseFont",
            "englishFont",
            "fontSize",
            "textColor-white",
            "textColor-black",
            "logoScale",
          ];

          immediateUpdateControls.forEach((controlId) => {
            const element = document.getElementById(controlId);
            if (element) {
              const eventType = element.type === "range" ? "input" : "change";
              element.addEventListener(eventType, () => {
                this.debouncedUpdate();
              });
            }
          });

          // Add listeners for color toggle buttons
          document.querySelectorAll(".color-toggle-btn").forEach((button) => {
            button.addEventListener("click", () => {
              this.debouncedUpdate();
            });
          });

          // Add listeners for layout cards
          document.querySelectorAll(".layout-card").forEach((card) => {
            card.addEventListener("click", () => {
              // Layout changes should update immediately for better UX
              this.immediateUpdate();
            });
          });
        }

        debouncedUpdate() {
          // Clear existing timer
          if (this.debounceTimer) {
            clearTimeout(this.debounceTimer);
          }

          // Set new timer
          this.debounceTimer = setTimeout(() => {
            this.performUpdate();
            this.debounceTimer = null;
          }, this.debounceDelay);
        }

        immediateUpdate() {
          // Clear any pending debounced update
          if (this.debounceTimer) {
            clearTimeout(this.debounceTimer);
            this.debounceTimer = null;
          }

          this.performUpdate();
        }

        performUpdate() {
          if (this.isUpdating) {
            this.pendingUpdate = true;
            return;
          }

          this.isUpdating = true;

          try {
            // Add smooth transition effect
            this.addTransitionEffect();

            // Perform the actual update
            updatePreview();

            // Optimize for mobile devices
            this.optimizeForMobile();
          } catch (error) {
            console.error("Error updating preview:", error);
          } finally {
            this.isUpdating = false;

            // Handle any pending update
            if (this.pendingUpdate) {
              this.pendingUpdate = false;
              setTimeout(() => this.performUpdate(), 50);
            }
          }
        }

        addTransitionEffect() {
          // Add a subtle fade effect during updates
          const canvas = document.getElementById("preview-canvas");
          if (canvas) {
            canvas.style.transition = "opacity 0.1s ease-in-out";
            canvas.style.opacity = "0.95";

            setTimeout(() => {
              canvas.style.opacity = "1";
            }, 100);
          }
        }

        optimizeForMobile() {
          // Reduce update frequency on mobile devices for better performance
          if (window.innerWidth <= 768) {
            this.debounceDelay = Math.max(200, this.debounceDelay);
          } else {
            this.debounceDelay = 150;
          }
        }

        // Public method to force immediate update
        forceUpdate() {
          this.immediateUpdate();
        }
      }

      // Global preview update manager instance
      let previewUpdateManager = null;

      // Updated preview function
      async function updatePreview() {
        if (!canvasRenderer) {
          console.warn("Canvas renderer not initialized");
          return;
        }

        console.log("Updating preview...");

        const currentLayout = getAppState("layout.type");

        // Get current assets
        const selectedBackground = getAppState("assets.selectedBackground");
        const selectedLogo = getAppState("assets.selectedLogo");
        const customBackground = getAppState("assets.customBackground");

        console.log("Current assets:", {
          selectedBackground,
          selectedLogo,
          customBackground,
          currentLayout,
        });

        // Load assets
        let backgroundImage = null;
        let logoImage = null;

        try {
          // Load background image
          if (customBackground) {
            console.log("Loading custom background...");
            // Custom background is an object with dataUrl property
            const backgroundSrc = customBackground.dataUrl || customBackground;
            backgroundImage = await loadImage(backgroundSrc);
          } else if (selectedBackground) {
            console.log("Loading selected background...");
            backgroundImage = await loadImage(selectedBackground);
          }

          // Load logo image
          if (selectedLogo && selectedLogo !== "none") {
            console.log("Loading selected logo...");
            logoImage = await loadImage(selectedLogo);
            console.log("Logo loaded:", logoImage ? "success" : "failed");
          } else if (selectedLogo === "none") {
            console.log("No logo selected - skipping logo loading");
            logoImage = null;
          }

          // Render based on selected layout
          console.log("Rendering layout:", currentLayout, "with assets:", {
            hasBackground: !!backgroundImage,
            hasLogo: !!logoImage,
          });

          if (currentLayout === "layout1") {
            canvasRenderer.renderLayout1(backgroundImage, logoImage);
          } else if (currentLayout === "layout2") {
            canvasRenderer.renderLayout2(backgroundImage, logoImage);
          } else {
            canvasRenderer.renderPlaceholder();
          }
        } catch (error) {
          console.error("Error loading assets for preview:", error);
          // Fallback to rendering without assets
          if (currentLayout === "layout1") {
            canvasRenderer.renderLayout1(null, null);
          } else if (currentLayout === "layout2") {
            canvasRenderer.renderLayout2(null, null);
          } else {
            canvasRenderer.renderPlaceholder();
          }
        }
      }

      // Export System Implementation
      class ExportManager {
        constructor() {
          this.isExporting = false;
          this.exportConfig = {
            allowTaint: true,
            useCORS: true,
            scale: 1,
            width: 1920,
            height: 1080,
            backgroundColor: null,
            logging: false,
            removeContainer: false,
          };

          this.init();
        }

        init() {
          // Verify HTML2Canvas is available
          if (typeof html2canvas === "undefined") {
            console.error("HTML2Canvas library not loaded");
            this.showError(
              "Export functionality unavailable - HTML2Canvas library not loaded"
            );
            return;
          }

          console.log(
            "Export manager initialized with HTML2Canvas version:",
            html2canvas.version || "unknown"
          );
        }

        async exportToPNG() {
          if (this.isExporting) {
            console.warn("Export already in progress");
            notificationManager.warning(
              "Export In Progress",
              "Please wait for the current export to complete."
            );
            return null;
          }

          this.isExporting = true;

          try {
            // Show loading overlay
            loadingManager.show(
              "Preparing Export",
              "Setting up canvas and loading assets..."
            );

            // Validate current state
            const textFields = getAppState("text.fields");
            if (!textFields || !textFields.fullName.trim()) {
              throw new Error("Full name is required for export");
            }

            // Create a completely new export canvas and render everything fresh
            const exportCanvas = document.createElement("canvas");
            exportCanvas.width = 1920;
            exportCanvas.height = 1080;
            const exportCtx = exportCanvas.getContext("2d");

            if (!exportCtx) {
              throw new Error("Failed to create canvas context for export");
            }

            loadingManager.updateMessage(
              "Loading Assets",
              "Loading images and fonts..."
            );

            // Get current state
            const currentLayout = getAppState("layout.type");
            const selectedBackground = getAppState("assets.selectedBackground");
            const selectedLogo = getAppState("assets.selectedLogo");
            const customBackground = getAppState("assets.customBackground");

            console.log("Export state:", {
              layout: currentLayout,
              selectedBackground: selectedBackground,
              selectedLogo: selectedLogo,
              customBackground: customBackground,
            });

            // Load images as data URLs to avoid CORS taint
            let backgroundDataURL = null;
            let logoDataURL = null;

            // Load background with error handling
            try {
              if (customBackground) {
                console.log("Loading custom background for export");
                const backgroundSrc =
                  customBackground.dataUrl || customBackground;
                backgroundDataURL = await this.loadImageAsDataURL(
                  backgroundSrc
                );
              } else if (selectedBackground) {
                console.log(
                  "Loading selected background for export:",
                  selectedBackground
                );
                backgroundDataURL = await this.loadImageAsDataURL(
                  selectedBackground
                );
              }
            } catch (error) {
              console.warn("Failed to load background for export:", error);
              notificationManager.warning(
                "Background Load Failed",
                "Using default background for export."
              );
            }

            // Load logo with error handling
            try {
              if (selectedLogo && selectedLogo !== "none") {
                console.log("Loading selected logo for export:", selectedLogo);
                logoDataURL = await this.loadImageAsDataURL(selectedLogo);
              } else if (selectedLogo === "none") {
                console.log(
                  "No logo selected for export - skipping logo loading"
                );
                logoDataURL = null;
              } else {
                // Use default logo
                logoDataURL = await this.loadImageAsDataURL(
                  "logo/no-bg-logo-1.png"
                );
              }
            } catch (error) {
              console.warn("Failed to load logo for export:", error);
              notificationManager.warning(
                "Logo Load Failed",
                "Using text-based logo for export."
              );
            }

            loadingManager.updateMessage(
              "Rendering Export",
              "Creating high-quality image..."
            );

            // Render with the loaded data URLs
            if (currentLayout === "layout1") {
              await this.renderLayout1ExportWithAssets(
                exportCtx,
                exportCanvas.width,
                exportCanvas.height,
                backgroundDataURL,
                logoDataURL
              );
            } else if (currentLayout === "layout2") {
              await this.renderLayout2ExportWithAssets(
                exportCtx,
                exportCanvas.width,
                exportCanvas.height,
                backgroundDataURL,
                logoDataURL
              );
            } else {
              await this.renderLayout1ExportWithAssets(
                exportCtx,
                exportCanvas.width,
                exportCanvas.height,
                backgroundDataURL,
                logoDataURL
              );
            }

            loadingManager.updateMessage(
              "Finalizing Export",
              "Converting to PNG format..."
            );

            // Convert export canvas to blob
            const quality = getAppState("export.quality") || 1.0;

            console.log(
              "Converting export canvas to blob with quality:",
              quality
            );

            return new Promise((resolve, reject) => {
              try {
                exportCanvas.toBlob(
                  (blob) => {
                    if (blob) {
                      console.log("Export blob generated successfully:", {
                        size: blob.size,
                        type: blob.type,
                        dimensions: `${exportCanvas.width}x${exportCanvas.height}`,
                        sizeKB: Math.round(blob.size / 1024),
                      });

                      // Show success notification
                      notificationManager.success(
                        "Export Complete",
                        `Background exported successfully (${Math.round(
                          blob.size / 1024
                        )}KB)`,
                        { duration: 4000 }
                      );

                      resolve(blob);
                    } else {
                      console.error("Export canvas.toBlob returned null");
                      reject(
                        new Error(
                          "Failed to generate PNG blob from export canvas"
                        )
                      );
                    }
                  },
                  "image/png",
                  quality
                );
              } catch (error) {
                console.error("Error in export canvas.toBlob:", error);
                reject(error);
              }
            });
          } catch (error) {
            console.error("Export failed:", error);

            // Show user-friendly error notification
            notificationManager.error(
              "Export Failed",
              errorBoundary.getUserFriendlyMessage(error, "Export"),
              {
                duration: 8000,
                actions: [
                  {
                    id: "retry",
                    label: "Try Again",
                    handler: () => this.exportToPNG(),
                  },
                ],
              }
            );

            errorBoundary.handleError(error, "Export");
            throw error;
          } finally {
            this.isExporting = false;
            loadingManager.hide();
          }
        }

        async loadImageAsDataURL(imagePath) {
          return new Promise((resolve) => {
            try {
              console.log("Loading image as data URL:", imagePath);

              // If it's already a data URL, return it
              if (imagePath.startsWith("data:")) {
                console.log("Image is already a data URL");
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => resolve(null);
                img.src = imagePath;
                return;
              }

              // Load the image first
              const img = new Image();
              img.crossOrigin = "anonymous";

              img.onload = () => {
                try {
                  console.log("Image loaded, converting to data URL");

                  // Create a canvas to convert the image
                  const canvas = document.createElement("canvas");
                  canvas.width = img.width;
                  canvas.height = img.height;
                  const ctx = canvas.getContext("2d");

                  // Draw the image to the canvas
                  ctx.drawImage(img, 0, 0);

                  // Convert to data URL
                  const dataURL = canvas.toDataURL("image/png");

                  // Create a new image from the data URL
                  const dataImg = new Image();
                  dataImg.onload = () => {
                    console.log("Data URL image created successfully");
                    resolve(dataImg);
                  };
                  dataImg.onerror = () => {
                    console.error("Failed to create data URL image");
                    resolve(null);
                  };
                  dataImg.src = dataURL;
                } catch (error) {
                  console.error("Error converting image to data URL:", error);
                  resolve(null);
                }
              };

              img.onerror = () => {
                console.error("Failed to load image:", imagePath);
                resolve(null);
              };

              img.src = imagePath;
            } catch (error) {
              console.error("Error in loadImageAsDataURL:", error);
              resolve(null);
            }
          });
        }

        async renderLayout1ExportWithAssets(
          ctx,
          width,
          height,
          backgroundDataURL,
          logoDataURL
        ) {
          console.log("Rendering Layout 1 for export with assets");

          // Clear canvas
          ctx.clearRect(0, 0, width, height);

          // Draw background
          if (backgroundDataURL) {
            console.log("Drawing background image from data URL");
            ctx.drawImage(backgroundDataURL, 0, 0, width, height);
          } else {
            console.log("Drawing gradient background");
            const gradient = ctx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, "#667eea");
            gradient.addColorStop(1, "#764ba2");
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
          }

          // Draw frame
          const frameMargin = 20;
          const frameRadius = 20;
          ctx.strokeStyle = "rgba(0, 0, 0, 0.8)";
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.roundRect(
            frameMargin,
            frameMargin,
            width - frameMargin * 2,
            height - frameMargin * 2,
            frameRadius
          );
          ctx.stroke();

          // Draw overlay with dynamic settings
          const overlaySize = getAppState("layout.overlay.size") || 40; // Percentage of width
          const overlayOpacity = getAppState("layout.overlay.opacity") || 80; // Percentage opacity

          const overlayWidthPercent = overlaySize / 100; // Convert to decimal
          const overlayOpacityDecimal = overlayOpacity / 100; // Convert to decimal

          const overlayStartX = width * (1 - overlayWidthPercent); // Start position
          const overlayWidth = width * overlayWidthPercent; // Width of overlay

          ctx.fillStyle = `rgba(0, 0, 0, ${overlayOpacityDecimal})`;
          ctx.fillRect(
            overlayStartX,
            frameMargin,
            overlayWidth - frameMargin,
            height - frameMargin * 2
          );

          // Draw logo
          const selectedLogo = getAppState("assets.selectedLogo");
          if (logoDataURL && selectedLogo !== "none") {
            console.log("Drawing logo image from data URL");
            const logoScale = getAppState("assets.logoScale") || 1.0;
            const baseLogoWidth = 400;
            const baseLogoHeight = 240;
            const logoWidth = baseLogoWidth * logoScale;
            const logoHeight = baseLogoHeight * logoScale;
            const logoMargin = 40;

            ctx.drawImage(
              logoDataURL,
              logoMargin,
              logoMargin,
              logoWidth,
              logoHeight
            );
          } else if (selectedLogo !== "none") {
            console.log("Drawing text-based logo fallback");
            ctx.fillStyle = "white";
            ctx.font = "bold 64px Arial";
            ctx.textAlign = "left";
            ctx.fillText("DDAM", 40, 120);
            ctx.font = "32px Arial";
            ctx.fillText("Digital Design & Marketing", 40, 160);
          } else {
            console.log("No logo selected - skipping logo rendering in export");
          }

          // Draw copyright
          ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
          ctx.font = "28px Arial";
          ctx.textAlign = "left";
          ctx.fillText(
            "©2025 Dentsu Data Artist Mongol LLC. All Rights Reserved.",
            40,
            height - 40
          );

          // Draw user text
          this.drawUserText(ctx, width, height, "layout1");

          console.log("Layout 1 export render complete");
        }

        async renderLayout2ExportWithAssets(
          ctx,
          width,
          height,
          backgroundDataURL,
          logoDataURL
        ) {
          console.log("Rendering Layout 2 for export with assets");

          // Clear canvas
          ctx.clearRect(0, 0, width, height);

          // Draw background
          if (backgroundDataURL) {
            console.log("Drawing background image from data URL");
            ctx.drawImage(backgroundDataURL, 0, 0, width, height);
          } else {
            console.log("Drawing gradient background");
            const gradient = ctx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, "#667eea");
            gradient.addColorStop(1, "#764ba2");
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
          }

          // Draw logo
          const selectedLogo = getAppState("assets.selectedLogo");
          if (logoDataURL && selectedLogo !== "none") {
            console.log("Drawing logo image from data URL");
            const logoScale = getAppState("assets.logoScale") || 1.0;
            const baseLogoWidth = 400;
            const baseLogoHeight = 240;
            const logoWidth = baseLogoWidth * logoScale;
            const logoHeight = baseLogoHeight * logoScale;
            const logoMargin = 40;

            ctx.drawImage(
              logoDataURL,
              logoMargin,
              logoMargin,
              logoWidth,
              logoHeight
            );
          } else if (selectedLogo !== "none") {
            console.log("Drawing text-based logo fallback");
            ctx.fillStyle = "white";
            ctx.font = "bold 64px Arial";
            ctx.textAlign = "left";
            ctx.fillText("DDAM", 40, 120);
            ctx.font = "32px Arial";
            ctx.fillText("Digital Design & Marketing", 40, 160);
          } else {
            console.log("No logo selected - skipping logo rendering in export");
          }

          // Draw copyright
          ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
          ctx.font = "28px Arial";
          ctx.textAlign = "left";
          ctx.fillText(
            "©2025 Dentsu Data Artist Mongol LLC. All Rights Reserved.",
            40,
            height - 40
          );

          // Draw user text
          this.drawUserText(ctx, width, height, "layout2");

          console.log("Layout 2 export render complete");
        }

        async renderLayout1ExportClean(ctx, width, height) {
          console.log("Rendering Layout 1 for export (CORS-free)");

          // Clear canvas
          ctx.clearRect(0, 0, width, height);

          // Always draw gradient background to avoid CORS issues
          console.log("Drawing gradient background");
          const gradient = ctx.createLinearGradient(0, 0, width, height);
          gradient.addColorStop(0, "#667eea");
          gradient.addColorStop(1, "#764ba2");
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, width, height);

          // Draw frame
          const frameMargin = 20;
          const frameRadius = 20;
          ctx.strokeStyle = "rgba(0, 0, 0, 0.8)";
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.roundRect(
            frameMargin,
            frameMargin,
            width - frameMargin * 2,
            height - frameMargin * 2,
            frameRadius
          );
          ctx.stroke();

          // Draw overlay with dynamic settings
          const overlaySize = getAppState("layout.overlay.size") || 40; // Percentage of width
          const overlayOpacity = getAppState("layout.overlay.opacity") || 80; // Percentage opacity

          const overlayWidthPercent = overlaySize / 100; // Convert to decimal
          const overlayOpacityDecimal = overlayOpacity / 100; // Convert to decimal

          const overlayStartX = width * (1 - overlayWidthPercent); // Start position
          const overlayWidth = width * overlayWidthPercent; // Width of overlay

          ctx.fillStyle = `rgba(0, 0, 0, ${overlayOpacityDecimal})`;
          ctx.fillRect(
            overlayStartX,
            frameMargin,
            overlayWidth - frameMargin,
            height - frameMargin * 2
          );

          // Draw text-based logo to avoid CORS issues (only if logo is not "none")
          const selectedLogo = getAppState("assets.selectedLogo");
          if (selectedLogo !== "none") {
            console.log("Drawing text-based logo");
            ctx.fillStyle = "white";
            ctx.font = "bold 64px Arial";
            ctx.textAlign = "left";
            ctx.fillText("DDAM", 40, 120);
            ctx.font = "32px Arial";
            ctx.fillText("Digital Design & Marketing", 40, 160);
          } else {
            console.log(
              "No logo selected - skipping logo rendering in clean export"
            );
          }

          // Draw copyright
          ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
          ctx.font = "28px Arial";
          ctx.textAlign = "left";
          ctx.fillText(
            "©2025 Dentsu Data Artist Mongol LLC. All Rights Reserved.",
            40,
            height - 40
          );

          // Draw user text
          this.drawUserText(ctx, width, height, "layout1");

          console.log("Layout 1 export render complete");
        }

        async renderLayout1Export(
          ctx,
          width,
          height,
          backgroundImage,
          logoImage
        ) {
          console.log("Rendering Layout 1 for export");

          // Clear canvas
          ctx.clearRect(0, 0, width, height);

          // Draw background
          if (backgroundImage && backgroundImage.complete) {
            console.log("Drawing background image");
            ctx.drawImage(backgroundImage, 0, 0, width, height);
          } else {
            console.log("Drawing gradient background");
            const gradient = ctx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, "#667eea");
            gradient.addColorStop(1, "#764ba2");
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
          }

          // Draw frame
          const frameMargin = 20;
          const frameRadius = 20;
          ctx.strokeStyle = "rgba(0, 0, 0, 0.8)";
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.roundRect(
            frameMargin,
            frameMargin,
            width - frameMargin * 2,
            height - frameMargin * 2,
            frameRadius
          );
          ctx.stroke();

          // Draw overlay with dynamic settings
          const overlaySize = getAppState("layout.overlay.size") || 40; // Percentage of width
          const overlayOpacity = getAppState("layout.overlay.opacity") || 80; // Percentage opacity

          const overlayWidthPercent = overlaySize / 100; // Convert to decimal
          const overlayOpacityDecimal = overlayOpacity / 100; // Convert to decimal

          const overlayStartX = width * (1 - overlayWidthPercent); // Start position
          const overlayWidth = width * overlayWidthPercent; // Width of overlay

          ctx.fillStyle = `rgba(0, 0, 0, ${overlayOpacityDecimal})`;
          ctx.fillRect(
            overlayStartX,
            frameMargin,
            overlayWidth - frameMargin,
            height - frameMargin * 2
          );

          // Draw logo
          const selectedLogo = getAppState("assets.selectedLogo");
          if (selectedLogo !== "none" && logoImage && logoImage.complete) {
            console.log("Drawing logo image");
            const logoScale = getAppState("assets.logoScale") || 1.0;
            const baseLogoWidth = 400;
            const baseLogoHeight = 240;
            const logoWidth = baseLogoWidth * logoScale;
            const logoHeight = baseLogoHeight * logoScale;
            const logoMargin = 40;

            ctx.drawImage(
              logoImage,
              logoMargin,
              logoMargin,
              logoWidth,
              logoHeight
            );
          } else if (
            selectedLogo !== "none" &&
            (!logoImage || !logoImage.complete)
          ) {
            console.log("Drawing placeholder logo");
            ctx.fillStyle = "white";
            ctx.font = "bold 64px Arial";
            ctx.textAlign = "left";
            ctx.fillText("DDAM LOGO", 40, 120);
          } else {
            console.log("No logo selected - skipping logo rendering in export");
          }

          // Draw copyright
          ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
          ctx.font = "28px Arial";
          ctx.textAlign = "left";
          ctx.fillText(
            "©2025 Dentsu Data Artist Mongol LLC. All Rights Reserved.",
            40,
            height - 40
          );

          // Draw user text
          this.drawUserText(ctx, width, height, "layout1");

          console.log("Layout 1 export render complete");
        }

        async renderLayout2Export(
          ctx,
          width,
          height,
          backgroundImage,
          logoImage
        ) {
          console.log("Rendering Layout 2 for export");

          // Clear canvas
          ctx.clearRect(0, 0, width, height);

          // Draw background
          if (backgroundImage && backgroundImage.complete) {
            console.log("Drawing background image");
            ctx.drawImage(backgroundImage, 0, 0, width, height);
          } else {
            console.log("Drawing gradient background");
            const gradient = ctx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, "#667eea");
            gradient.addColorStop(1, "#764ba2");
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
          }

          // Draw logo
          const selectedLogo = getAppState("assets.selectedLogo");
          if (selectedLogo !== "none" && logoImage && logoImage.complete) {
            console.log("Drawing logo image");
            const logoScale = getAppState("assets.logoScale") || 1.0;
            const baseLogoWidth = 400;
            const baseLogoHeight = 240;
            const logoWidth = baseLogoWidth * logoScale;
            const logoHeight = baseLogoHeight * logoScale;
            const logoMargin = 40;

            ctx.drawImage(
              logoImage,
              logoMargin,
              logoMargin,
              logoWidth,
              logoHeight
            );
          } else if (
            selectedLogo !== "none" &&
            (!logoImage || !logoImage.complete)
          ) {
            console.log("Drawing placeholder logo");
            ctx.fillStyle = "white";
            ctx.font = "bold 64px Arial";
            ctx.textAlign = "left";
            ctx.fillText("DDAM LOGO", 40, 120);
          } else {
            console.log("No logo selected - skipping logo rendering in export");
          }

          // Draw copyright
          ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
          ctx.font = "28px Arial";
          ctx.textAlign = "left";
          ctx.fillText(
            "©2025 Dentsu Data Artist Mongol LLC. All Rights Reserved.",
            40,
            height - 40
          );

          // Draw user text
          this.drawUserText(ctx, width, height, "layout2");

          console.log("Layout 2 export render complete");
        }

        drawUserText(ctx, width, height, layout) {
          const textFields = getAppState("text.fields");
          const typography = getAppState("text.typography");
          const position =
            getAppState(`text.positioning.${layout}`) || "top-right";

          console.log(
            `Export - Drawing user text for ${layout} with position: ${position}`
          );

          if (!textFields || !typography) return;

          const baseFontSize = typography.fontSize * 3;
          const textColor =
            typography.textColor === "white" ? "#ffffff" : "#000000";

          const lines = [
            { text: textFields.fullName, font: `bold ${baseFontSize}px Arial` },
            { text: textFields.nickname, font: `${baseFontSize}px Arial` },
            {
              text: textFields.positionEn,
              font: `${Math.round(baseFontSize * 0.8)}px Arial`,
            },
            {
              text: textFields.positionJp,
              font: `${Math.round(baseFontSize * 0.8)}px Arial`,
            },
          ];

          const lineHeight = baseFontSize * 1.3;
          const totalTextHeight = lines.length * lineHeight;
          const padding = 60;

          // Calculate position based on layout and position option
          let textX, textY, textAlign;

          console.log(
            `Export - Calculating position for ${layout} - ${position}`
          );

          if (layout === "layout1") {
            // Layout 1 positioning logic
            switch (position) {
              case "top-right":
                textX = width - padding;
                textY = padding + 100;
                textAlign = "right";
                break;
              case "middle":
                textX = width - padding;
                textY = (height - totalTextHeight) / 2;
                textAlign = "right";
                break;
              case "bottom-left":
                textX = padding;
                textY = height - totalTextHeight - padding - 100;
                textAlign = "left";
                break;
              default:
                textX = width - padding;
                textY = padding + 100;
                textAlign = "right";
            }
          } else if (layout === "layout2") {
            // Layout 2 positioning logic
            switch (position) {
              case "top-right":
                textX = width - padding;
                textY = padding + 100;
                textAlign = "right";
                break;
              case "middle":
                textX = width / 2;
                textY = (height - totalTextHeight) / 2;
                textAlign = "center";
                break;
              case "bottom-left":
                textX = padding;
                textY = height - totalTextHeight - padding - 100;
                textAlign = "left";
                break;
              case "bottom-right":
                textX = width - padding;
                textY = height - totalTextHeight - padding - 100;
                textAlign = "right";
                break;
              default:
                textX = width - padding;
                textY = padding + 100;
                textAlign = "right";
            }
          } else {
            // Fallback positioning
            textX = width - padding;
            textY = padding + 100;
            textAlign = "right";
          }

          console.log(
            `Export - Final text position: x=${textX}, y=${textY}, align=${textAlign}`
          );

          // Draw text lines
          ctx.fillStyle = textColor;
          ctx.textAlign = textAlign;

          let currentY = textY;
          lines.forEach((line, index) => {
            ctx.font = line.font;
            ctx.fillText(line.text, textX, currentY);
            console.log(
              `Export - Drew line ${index}: "${line.text}" at (${textX}, ${currentY})`
            );
            currentY += lineHeight;
          });
        }

        async convertToDataURL(img) {
          return new Promise((resolve) => {
            try {
              if (!img || !img.complete) {
                console.log("convertToDataURL: Invalid or incomplete image");
                resolve(null);
                return;
              }

              console.log("convertToDataURL: Converting image to data URL");

              // Create a temporary canvas to convert the image
              const tempCanvas = document.createElement("canvas");
              tempCanvas.width = img.width;
              tempCanvas.height = img.height;
              const tempCtx = tempCanvas.getContext("2d");

              // Draw the image to the temporary canvas
              tempCtx.drawImage(img, 0, 0);

              // Convert to data URL
              const dataURL = tempCanvas.toDataURL("image/png");

              // Create a new image from the data URL
              const cleanImg = new Image();
              cleanImg.onload = () => {
                console.log(
                  "convertToDataURL: Clean image created successfully"
                );
                resolve(cleanImg);
              };
              cleanImg.onerror = () => {
                console.error("convertToDataURL: Failed to create clean image");
                resolve(null);
              };
              cleanImg.src = dataURL;
            } catch (error) {
              console.error(
                "convertToDataURL: Error during conversion:",
                error
              );
              resolve(null);
            }
          });
        }

        async convertImageForExport(img) {
          return new Promise((resolve) => {
            try {
              if (!img || !img.complete) {
                console.log(
                  "convertImageForExport: Invalid or incomplete image"
                );
                resolve(null);
                return;
              }

              console.log(
                "convertImageForExport: Converting image",
                img.width,
                "x",
                img.height
              );

              // Create a canvas to convert the image
              const canvas = document.createElement("canvas");
              canvas.width = img.width;
              canvas.height = img.height;
              const ctx = canvas.getContext("2d");

              // Draw the image to the canvas
              ctx.drawImage(img, 0, 0);

              // Convert to data URL
              const dataURL = canvas.toDataURL("image/png");

              // Create a new image from the data URL
              const exportImg = new Image();
              exportImg.onload = () => {
                console.log("convertImageForExport: Conversion successful");
                resolve(exportImg);
              };
              exportImg.onerror = () => {
                console.error(
                  "convertImageForExport: Failed to create export image"
                );
                resolve(null);
              };
              exportImg.src = dataURL;
            } catch (error) {
              console.error(
                "convertImageForExport: Error during conversion:",
                error
              );
              resolve(null);
            }
          });
        }

        async renderCleanExport(ctx, width, height) {
          console.log("Rendering export with CORS-safe images...");

          const currentLayout = getAppState("layout.type");
          const textFields = getAppState("text.fields");
          const typography = getAppState("text.typography");

          // Get current assets
          const selectedBackground = getAppState("assets.selectedBackground");
          const selectedLogo = getAppState("assets.selectedLogo");
          const customBackground = getAppState("assets.customBackground");

          // Clear canvas
          ctx.clearRect(0, 0, width, height);

          // Load images for export (CORS-safe)
          let backgroundImage = null;
          let logoImage = null;

          console.log("Export assets to load:", {
            selectedLogo: selectedLogo,
            selectedBackground: selectedBackground,
            customBackground: customBackground,
          });

          try {
            // Use the existing loadImage function and then convert for export
            if (customBackground) {
              console.log(
                "Loading custom background for export:",
                customBackground
              );
              const bgImg = await loadImage(
                customBackground.dataUrl || customBackground
              );
              if (bgImg) {
                backgroundImage = await this.convertImageForExport(bgImg);
              }
              console.log("Custom background loaded:", !!backgroundImage);
            } else if (selectedBackground) {
              console.log(
                "Loading selected background for export:",
                selectedBackground
              );
              const bgImg = await loadImage(selectedBackground);
              if (bgImg) {
                backgroundImage = await this.convertImageForExport(bgImg);
              }
              console.log("Selected background loaded:", !!backgroundImage);
            }

            // Load logo image
            if (selectedLogo && selectedLogo !== "none") {
              console.log("Loading logo for export:", selectedLogo);
              const logoImg = await loadImage(selectedLogo);
              if (logoImg) {
                logoImage = await this.convertImageForExport(logoImg);
              }
              console.log("Logo loaded:", !!logoImage);
            } else if (selectedLogo === "none") {
              console.log(
                "No logo selected for export - skipping logo loading"
              );
              logoImage = null;
              if (logoImage) {
                console.log(
                  "Logo dimensions:",
                  logoImage.width,
                  "x",
                  logoImage.height
                );
              }
            }
          } catch (error) {
            console.error("Error loading images for export:", error);
          }

          console.log("Final loaded assets:", {
            hasBackground: !!backgroundImage,
            hasLogo: !!logoImage,
          });

          // Draw background
          if (backgroundImage && backgroundImage.complete) {
            console.log("Drawing background image in export");
            console.log("Background draw parameters:", {
              x: 0,
              y: 0,
              width: width,
              height: height,
              imageSize: `${backgroundImage.width}x${backgroundImage.height}`,
            });
            ctx.drawImage(backgroundImage, 0, 0, width, height);
            console.log("Background drawn successfully");
          } else {
            console.log(
              "Drawing gradient background in export - backgroundImage:",
              !!backgroundImage,
              "complete:",
              backgroundImage ? backgroundImage.complete : "N/A"
            );
            // Fallback gradient background
            const gradient = ctx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, "#667eea");
            gradient.addColorStop(1, "#764ba2");
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
          }

          // Draw layout-specific elements
          if (currentLayout === "layout1") {
            // Draw Layout 1 frame
            const frameMargin = 20;
            const frameRadius = 20;

            ctx.strokeStyle = "rgba(0, 0, 0, 0.8)";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.roundRect(
              frameMargin,
              frameMargin,
              width - frameMargin * 2,
              height - frameMargin * 2,
              frameRadius
            );
            ctx.stroke();

            // Draw overlay with dynamic settings
            const overlaySize = getAppState("layout.overlay.size") || 40; // Percentage of width
            const overlayOpacity = getAppState("layout.overlay.opacity") || 80; // Percentage opacity

            const overlayWidthPercent = overlaySize / 100; // Convert to decimal
            const overlayOpacityDecimal = overlayOpacity / 100; // Convert to decimal

            const overlayStartX = width * (1 - overlayWidthPercent); // Start position
            const overlayWidth = width * overlayWidthPercent; // Width of overlay

            ctx.fillStyle = `rgba(0, 0, 0, ${overlayOpacityDecimal})`;
            ctx.fillRect(
              overlayStartX,
              frameMargin,
              overlayWidth - frameMargin,
              height - frameMargin * 2
            );
          }

          // Draw logo
          // selectedLogo already declared above, reusing the existing variable
          if (selectedLogo !== "none" && logoImage && logoImage.complete) {
            console.log("Drawing logo image in export");
            const logoScale = getAppState("assets.logoScale") || 1.0;
            const baseLogoWidth = 400;
            const baseLogoHeight = 240;
            const logoWidth = baseLogoWidth * logoScale;
            const logoHeight = baseLogoHeight * logoScale;
            const logoMargin = 40;

            console.log("Logo draw parameters:", {
              x: logoMargin,
              y: logoMargin,
              width: logoWidth,
              height: logoHeight,
              scale: logoScale,
              imageSize: `${logoImage.width}x${logoImage.height}`,
            });

            ctx.drawImage(
              logoImage,
              logoMargin,
              logoMargin,
              logoWidth,
              logoHeight
            );
            console.log("Logo drawn successfully");
          } else if (
            selectedLogo !== "none" &&
            (!logoImage || !logoImage.complete)
          ) {
            console.log(
              "Drawing placeholder logo text in export - logoImage:",
              !!logoImage,
              "complete:",
              logoImage ? logoImage.complete : "N/A"
            );
            // Fallback logo text
            ctx.fillStyle = "white";
            ctx.font = "bold 64px Arial";
            ctx.textAlign = "left";
            ctx.fillText("DDAM LOGO", 40, 120);
          } else {
            console.log("No logo selected - skipping logo rendering in export");
          }

          // Draw copyright
          ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
          ctx.font = "28px Arial";
          ctx.textAlign = "left";
          ctx.fillText(
            "©2025 Dentsu Data Artist Mongol LLC. All Rights Reserved.",
            40,
            height - 40
          );

          // Draw user text
          if (textFields && typography) {
            const baseFontSize = typography.fontSize * 3;
            const textColor =
              typography.textColor === "white" ? "#ffffff" : "#000000";
            const position =
              getAppState(`text.positioning.${currentLayout}`) || "top-right";

            const lines = [
              {
                text: textFields.fullName,
                font: `bold ${baseFontSize}px Arial`,
              },
              { text: textFields.nickname, font: `${baseFontSize}px Arial` },
              {
                text: textFields.positionEn,
                font: `${Math.round(baseFontSize * 0.8)}px Arial`,
              },
              {
                text: textFields.positionJp,
                font: `${Math.round(baseFontSize * 0.8)}px Arial`,
              },
            ];

            // Calculate position
            let textX, textAlign;
            const textY = 180;
            const lineHeight = baseFontSize * 1.3;

            switch (position) {
              case "top-right":
                textX = width - 60;
                textAlign = "right";
                break;
              case "middle":
                textX = width / 2;
                textAlign = "center";
                break;
              case "bottom-left":
                textX = 60;
                textAlign = "left";
                break;
              default:
                textX = width - 60;
                textAlign = "right";
            }

            // Draw text lines
            ctx.fillStyle = textColor;
            ctx.textAlign = textAlign;

            let currentY = textY;
            lines.forEach((line) => {
              ctx.font = line.font;
              ctx.fillText(line.text, textX, currentY);
              currentY += lineHeight;
            });
          }

          console.log("Export render completed with images");
        }

        generateFilename() {
          try {
            const fullName =
              getAppState("text.fields.fullName") || "DDAM_Background";
            const timestamp = new Date().toISOString().slice(0, 10); // YYYY-MM-DD format

            // Sanitize filename - remove invalid characters
            const sanitizedName = fullName
              .replace(/[<>:"/\\|?*]/g, "") // Remove invalid filename characters
              .replace(/\s+/g, "_") // Replace spaces with underscores
              .trim();

            const filename = `${sanitizedName}_DDAM_Background_${timestamp}.png`;

            // Update state with generated filename
            updateAppState("export.filename", filename);

            console.log("Generated filename:", filename);
            return filename;
          } catch (error) {
            console.error("Failed to generate filename:", error);
            return `DDAM_Background_${Date.now()}.png`;
          }
        }

        async downloadPNG(blob, filename) {
          try {
            console.log("Starting download process for:", filename);
            console.log("Blob details:", {
              size: blob.size,
              type: blob.type,
              sizeKB: Math.round(blob.size / 1024),
            });

            // Validate blob
            if (!blob || blob.size === 0) {
              throw new Error("Invalid or empty blob provided for download");
            }

            // Check if browser supports downloads
            if (!window.URL || !window.URL.createObjectURL) {
              throw new Error("Browser does not support file downloads");
            }

            // Create download link with improved browser compatibility
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");

            // Set link properties with additional attributes for better compatibility
            link.href = url;
            link.download = filename;
            link.style.display = "none";
            link.setAttribute("target", "_blank");
            link.setAttribute("rel", "noopener noreferrer");

            // Add to DOM temporarily
            document.body.appendChild(link);

            // Add a small delay to ensure the link is properly added to DOM
            await new Promise((resolve) => setTimeout(resolve, 10));

            // Try different methods for triggering download based on browser
            let downloadTriggered = false;

            try {
              // Method 1: Standard click with user gesture check
              if (document.hasFocus()) {
                link.click();
                downloadTriggered = true;
                console.log("Download triggered using standard click method");
              } else {
                console.warn("Document not focused, trying alternative method");
              }
            } catch (clickError) {
              console.warn("Standard click failed:", clickError);
            }

            if (!downloadTriggered) {
              try {
                // Method 2: Dispatch click event
                const clickEvent = new MouseEvent("click", {
                  view: window,
                  bubbles: true,
                  cancelable: true,
                  button: 0,
                });
                link.dispatchEvent(clickEvent);
                downloadTriggered = true;
                console.log("Download triggered using event dispatch method");
              } catch (eventError) {
                console.warn("Event dispatch failed:", eventError);
              }
            }

            if (!downloadTriggered) {
              // Method 3: Try programmatic navigation
              try {
                window.location.href = url;
                downloadTriggered = true;
                console.log("Download triggered using location.href method");
              } catch (navError) {
                console.warn("Navigation method failed:", navError);
              }
            }

            // Clean up DOM
            setTimeout(() => {
              if (document.body.contains(link)) {
                document.body.removeChild(link);
              }
            }, 100);

            // Clean up object URL with longer delay for slower browsers
            setTimeout(() => {
              try {
                URL.revokeObjectURL(url);
                console.log("Object URL cleaned up successfully");
              } catch (revokeError) {
                console.warn("Failed to revoke object URL:", revokeError);
              }
            }, 2000);

            if (downloadTriggered) {
              this.showExportSuccess(`Successfully exported: ${filename}`);
              console.log("Download process completed for:", filename);

              // Show additional user guidance
              notificationManager.info(
                "Download Started",
                "Check your browser's download folder or notification area. If the download didn't start, check if pop-ups are blocked.",
                { duration: 6000 }
              );

              return true;
            } else {
              throw new Error("All download methods failed");
            }
          } catch (error) {
            console.error("Download failed:", error);

            // Try fallback method using data URL
            try {
              console.log(
                "Attempting fallback download method using data URL..."
              );

              return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = function () {
                  try {
                    const link = document.createElement("a");
                    link.href = reader.result;
                    link.download = filename;
                    link.style.display = "none";
                    link.setAttribute("target", "_blank");

                    document.body.appendChild(link);

                    // Try clicking the data URL link
                    setTimeout(() => {
                      link.click();
                      document.body.removeChild(link);
                      console.log("Fallback download method completed");

                      this.showExportSuccess(
                        `Successfully exported: ${filename} (using fallback method)`
                      );
                      resolve(true);
                    }, 10);
                  } catch (fallbackError) {
                    console.error("Fallback method failed:", fallbackError);
                    this.showManualDownloadOption(blob, filename);
                    resolve(false);
                  }
                }.bind(this);

                reader.onerror = () => {
                  console.error("FileReader failed");
                  this.showManualDownloadOption(blob, filename);
                  resolve(false);
                };

                reader.readAsDataURL(blob);
              });
            } catch (fallbackError) {
              console.error(
                "Fallback download method setup failed:",
                fallbackError
              );
              this.showManualDownloadOption(blob, filename);
              return false;
            }
          }
        }

        showManualDownloadOption(blob, filename) {
          // Show manual download instructions
          const url = URL.createObjectURL(blob);

          notificationManager.error(
            "Download Failed",
            `Automatic download failed. <a href="${url}" download="${filename}" target="_blank" style="color: white; text-decoration: underline;">Click here to download manually</a>`,
            {
              duration: 15000,
              allowHTML: true,
              actions: [
                {
                  id: "manual-download",
                  label: "Manual Download",
                  handler: () => {
                    const link = document.createElement("a");
                    link.href = url;
                    link.download = filename;
                    link.click();
                  },
                },
              ],
            }
          );

          // Clean up URL after a longer delay
          setTimeout(() => {
            try {
              URL.revokeObjectURL(url);
            } catch (error) {
              console.warn("Failed to revoke manual download URL:", error);
            }
          }, 30000);
        }

        async exportAndDownload() {
          try {
            // Generate filename
            const filename = this.generateFilename();

            // Export to PNG
            const blob = await this.exportToPNG();
            if (!blob) {
              throw new Error("Failed to generate PNG");
            }

            // Download the file
            const success = await this.downloadPNG(blob, filename);

            return success;
          } catch (error) {
            console.error("Export and download failed:", error);
            this.showError(`Export failed: ${error.message}`);
            return false;
          }
        }

        showExportProgress(message) {
          // Create or update progress indicator
          let progressElement = document.getElementById("export-progress");
          if (!progressElement) {
            progressElement = document.createElement("div");
            progressElement.id = "export-progress";
            progressElement.className = "export-progress";
            progressElement.style.cssText = `
                      position: fixed;
                      top: 50%;
                      left: 50%;
                      transform: translate(-50%, -50%);
                      background: rgba(0, 0, 0, 0.8);
                      color: white;
                      padding: 1rem 2rem;
                      border-radius: 8px;
                      z-index: 10000;
                      font-size: 1rem;
                      text-align: center;
                      backdrop-filter: blur(4px);
                  `;
            document.body.appendChild(progressElement);
          }

          progressElement.innerHTML = `
                  <div style="margin-bottom: 0.5rem;">
                      <div style="display: inline-block; width: 20px; height: 20px; border: 2px solid #ffffff; border-top: 2px solid transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                  </div>
                  <div>${message}</div>
              `;

          // Add CSS animation if not already present
          if (!document.getElementById("export-spinner-style")) {
            const style = document.createElement("style");
            style.id = "export-spinner-style";
            style.textContent = `
                      @keyframes spin {
                          0% { transform: rotate(0deg); }
                          100% { transform: rotate(360deg); }
                      }
                  `;
            document.head.appendChild(style);
          }

          progressElement.style.display = "block";
        }

        hideExportProgress() {
          const progressElement = document.getElementById("export-progress");
          if (progressElement) {
            progressElement.style.display = "none";
          }
        }

        showExportSuccess(message) {
          this.showNotification(message, "success");
        }

        showError(message) {
          this.showNotification(message, "error");
        }

        showNotification(message, type = "info") {
          // Create notification element
          const notification = document.createElement("div");
          notification.className = `export-notification export-notification-${type}`;
          notification.style.cssText = `
                  position: fixed;
                  top: 20px;
                  right: 20px;
                  padding: 1rem 1.5rem;
                  border-radius: 8px;
                  z-index: 10001;
                  font-size: 0.9rem;
                  max-width: 400px;
                  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                  animation: slideInRight 0.3s ease-out;
              `;

          // Set colors based on type
          if (type === "success") {
            notification.style.background = "#d4edda";
            notification.style.color = "#155724";
            notification.style.border = "1px solid #c3e6cb";
          } else if (type === "error") {
            notification.style.background = "#f8d7da";
            notification.style.color = "#721c24";
            notification.style.border = "1px solid #f5c6cb";
          } else {
            notification.style.background = "#d1ecf1";
            notification.style.color = "#0c5460";
            notification.style.border = "1px solid #bee5eb";
          }

          notification.textContent = message;

          // Add CSS animation if not already present
          if (!document.getElementById("notification-animation-style")) {
            const style = document.createElement("style");
            style.id = "notification-animation-style";
            style.textContent = `
                      @keyframes slideInRight {
                          from {
                              transform: translateX(100%);
                              opacity: 0;
                          }
                          to {
                              transform: translateX(0);
                              opacity: 1;
                          }
                      }
                      @keyframes slideOutRight {
                          from {
                              transform: translateX(0);
                              opacity: 1;
                          }
                          to {
                              transform: translateX(100%);
                              opacity: 0;
                          }
                      }
                  `;
            document.head.appendChild(style);
          }

          document.body.appendChild(notification);

          // Auto-remove after 5 seconds
          setTimeout(() => {
            notification.style.animation = "slideOutRight 0.3s ease-in";
            setTimeout(() => {
              if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
              }
            }, 300);
          }, 5000);
        }

        // Public method to check if export is in progress
        isExportInProgress() {
          return this.isExporting;
        }

        // Public method to update export configuration
        updateConfig(newConfig) {
          this.exportConfig = { ...this.exportConfig, ...newConfig };
          console.log("Export config updated:", this.exportConfig);
        }
      }

      // Global export manager instance
      let exportManager = null;

      // Updated export function with cross-browser support
      async function exportBackground() {
        try {
          // Check if HTML2Canvas is available
          if (!html2canvasManager.isSupported()) {
            notificationManager.error(
              "Export Not Available",
              "Export functionality is not supported in your browser.",
              { duration: 5000 }
            );
            return false;
          }

          // Use export manager if available, otherwise use HTML2Canvas manager
          if (exportManager) {
            return await exportManager.exportAndDownload();
          } else {
            // Fallback to direct HTML2Canvas manager usage
            const canvas = document.getElementById("preview-canvas");
            if (!canvas) {
              throw new Error("Preview canvas not found");
            }

            // Generate filename
            const fullName =
              getAppState("text.fields.fullName") || "background";
            const filename = `${fullName.replace(
              /[^a-zA-Z0-9]/g,
              "_"
            )}_meeting_background.png`;

            // Show loading
            loadingManager.show(
              "Exporting background...",
              "Please wait while we generate your image."
            );

            try {
              await html2canvasManager.exportToPNG(canvas, filename, 1.0);

              notificationManager.success(
                "Export Successful",
                "Your meeting background has been downloaded.",
                { duration: 4000 }
              );

              return true;
            } finally {
              loadingManager.hide();
            }
          }
        } catch (error) {
          console.error("Export failed:", error);

          loadingManager.hide();

          notificationManager.error(
            "Export Failed",
            errorBoundary.getUserFriendlyMessage(error, "Export"),
            {
              duration: 6000,
              actions: [
                {
                  id: "retry",
                  label: "Try Again",
                  handler: () => exportBackground(),
                },
              ],
            }
          );

          return false;
        }
      }

      // Debug function to test canvas content
      function debugCanvas() {
        const canvas = document.getElementById("preview-canvas");
        if (!canvas) {
          console.error("Canvas not found");
          return;
        }

        const ctx = canvas.getContext("2d");

        console.log("Canvas Debug Info:", {
          element: canvas,
          width: canvas.width,
          height: canvas.height,
          offsetWidth: canvas.offsetWidth,
          offsetHeight: canvas.offsetHeight,
          context: ctx,
          canvasRenderer: canvasRenderer,
          appState: getAppState(),
        });

        // Test drawing something simple (avoid getImageData due to CORS taint)
        ctx.fillStyle = "#ff0000";
        ctx.fillRect(100, 100, 200, 200);
        console.log("Drew red test rectangle at (100,100) 200x200");

        return {
          canvas: canvas,
          canvasRenderer: canvasRenderer,
        };
      }

      // Debug function to force render and export
      async function debugExport() {
        console.log("=== DEBUG EXPORT START ===");

        // Force update preview
        console.log("Forcing preview update...");
        await updatePreview();

        // Wait a bit
        await new Promise((resolve) => setTimeout(resolve, 1000));

        // Check canvas content
        const debugInfo = debugCanvas();

        if (!debugInfo.hasContent) {
          console.log("Canvas is empty, forcing manual render...");
          if (canvasRenderer) {
            canvasRenderer.renderLayout1(null, null);
          }
        }

        // Try export
        console.log("Attempting export...");
        const result = await exportBackground();

        console.log("=== DEBUG EXPORT END ===");
        return result;
      }

      // Mobile Optimization Class
      class MobileOptimizer {
        constructor() {
          this.isMobile = window.innerWidth < 768;
          this.collapsedSections = new Set();
          this.touchStartY = 0;
          this.touchStartX = 0;
          this.init();
        }

        init() {
          this.setupCollapsibleSections();
          this.setupTouchOptimizations();
          this.setupResizeHandler();
          this.optimizeForMobile();

          console.log("Mobile optimizer initialized, isMobile:", this.isMobile);
        }

        setupCollapsibleSections() {
          if (!this.isMobile) return;

          const controlSections = document.querySelectorAll(".control-section");

          controlSections.forEach((section, index) => {
            const title = section.querySelector(".section-title");
            const content =
              section.querySelector(".section-content") ||
              this.wrapSectionContent(section);

            if (!title || !content) return;

            // Add click handler to section title
            title.addEventListener("click", () => {
              this.toggleSection(section, title, content);
            });

            // Add keyboard support
            title.addEventListener("keydown", (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                this.toggleSection(section, title, content);
              }
            });

            // Make title focusable and add ARIA attributes
            title.setAttribute("tabindex", "0");
            title.setAttribute("role", "button");
            title.setAttribute("aria-expanded", "true");
            title.setAttribute("aria-controls", `section-content-${index}`);
            content.setAttribute("id", `section-content-${index}`);

            // Collapse all sections except the first one by default
            if (index > 0) {
              this.collapseSection(section, title, content);
            }
          });
        }

        wrapSectionContent(section) {
          const title = section.querySelector(".section-title");
          const content = document.createElement("div");
          content.className = "section-content";

          // Move all children except title into content wrapper
          const children = Array.from(section.children);
          children.forEach((child) => {
            if (child !== title) {
              content.appendChild(child);
            }
          });

          section.appendChild(content);
          return content;
        }

        toggleSection(section, title, content) {
          if (section.classList.contains("collapsed")) {
            this.expandSection(section, title, content);
          } else {
            this.collapseSection(section, title, content);
          }
        }

        collapseSection(section, title, content) {
          section.classList.add("collapsed");
          title.setAttribute("aria-expanded", "false");
          this.collapsedSections.add(section);

          // Add haptic feedback on supported devices
          if (navigator.vibrate) {
            navigator.vibrate(50);
          }
        }

        expandSection(section, title, content) {
          section.classList.remove("collapsed");
          title.setAttribute("aria-expanded", "true");
          this.collapsedSections.delete(section);

          // Add haptic feedback on supported devices
          if (navigator.vibrate) {
            navigator.vibrate(50);
          }
        }

        setupTouchOptimizations() {
          // Improve touch interactions for mobile
          document.addEventListener(
            "touchstart",
            (e) => {
              this.touchStartY = e.touches[0].clientY;
              this.touchStartX = e.touches[0].clientX;
            },
            { passive: true }
          );

          // Add touch feedback to interactive elements
          const interactiveElements = document.querySelectorAll(
            ".btn, .layout-card, .asset-item, .position-option, .color-toggle-btn"
          );

          interactiveElements.forEach((element) => {
            element.addEventListener(
              "touchstart",
              () => {
                element.style.transform = "scale(0.98)";
                element.style.transition = "transform 0.1s ease";
              },
              { passive: true }
            );

            element.addEventListener(
              "touchend",
              () => {
                setTimeout(() => {
                  element.style.transform = "";
                  element.style.transition = "";
                }, 100);
              },
              { passive: true }
            );

            element.addEventListener(
              "touchcancel",
              () => {
                element.style.transform = "";
                element.style.transition = "";
              },
              { passive: true }
            );
          });

          // Prevent double-tap zoom on buttons
          const buttons = document.querySelectorAll(
            ".btn, .layout-card, .asset-item, .position-option"
          );
          buttons.forEach((button) => {
            button.addEventListener("touchend", (e) => {
              e.preventDefault();
              button.click();
            });
          });
        }

        setupResizeHandler() {
          let resizeTimeout;

          window.addEventListener("resize", () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
              const wasMobile = this.isMobile;
              this.isMobile = window.innerWidth < 768;

              if (wasMobile !== this.isMobile) {
                this.handleViewportChange();
              }

              this.optimizeForMobile();
            }, 250);
          });

          // Handle orientation change
          window.addEventListener("orientationchange", () => {
            setTimeout(() => {
              this.optimizeForMobile();
              this.adjustCanvasSize();
            }, 500);
          });
        }

        handleViewportChange() {
          if (this.isMobile) {
            // Switching to mobile
            this.setupCollapsibleSections();
          } else {
            // Switching to desktop/tablet
            this.resetCollapsibleSections();
          }

          console.log("Viewport changed, isMobile:", this.isMobile);
        }

        resetCollapsibleSections() {
          const controlSections = document.querySelectorAll(".control-section");

          controlSections.forEach((section) => {
            section.classList.remove("collapsed");
            const title = section.querySelector(".section-title");
            if (title) {
              title.setAttribute("aria-expanded", "true");
            }
          });

          this.collapsedSections.clear();
        }

        optimizeForMobile() {
          if (this.isMobile) {
            this.optimizeMobileLayout();
            this.optimizeMobileInputs();
            this.optimizeMobileCanvas();
          } else {
            this.resetMobileOptimizations();
          }
        }

        optimizeMobileLayout() {
          // Ensure proper mobile layout
          const mainLayout = document.querySelector(".main-layout");
          if (mainLayout) {
            mainLayout.style.gridTemplateColumns = "1fr";
          }

          // Optimize scroll behavior
          document.body.style.overscrollBehavior = "contain";

          // Add mobile-specific classes
          document.body.classList.add("mobile-optimized");
        }

        optimizeMobileInputs() {
          // Prevent zoom on input focus for iOS
          const inputs = document.querySelectorAll("input, select, textarea");
          inputs.forEach((input) => {
            if (input.style.fontSize !== "16px") {
              input.style.fontSize = "16px";
            }
          });

          // Optimize virtual keyboard behavior
          const viewport = document.querySelector('meta[name="viewport"]');
          if (viewport && this.isMobile) {
            viewport.setAttribute(
              "content",
              "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
            );
          }
        }

        optimizeMobileCanvas() {
          const canvas = document.getElementById("preview-canvas");
          const container = document.querySelector(".preview-container");

          if (canvas && container && this.isMobile) {
            // Ensure canvas is properly sized for mobile
            this.adjustCanvasSize();

            // Add touch gesture support for canvas (optional future enhancement)
            this.addCanvasTouchSupport(canvas);
          }
        }

        adjustCanvasSize() {
          const canvas = document.getElementById("preview-canvas");
          const container = document.querySelector(".preview-container");

          if (!canvas || !container) return;

          // Force canvas to maintain aspect ratio on mobile
          const containerWidth = container.offsetWidth;
          const aspectRatio = 16 / 9;
          const containerHeight = containerWidth / aspectRatio;

          container.style.height = `${containerHeight}px`;

          // Trigger canvas resize if needed
          if (window.canvasRenderer) {
            setTimeout(() => {
              window.canvasRenderer.updateCanvasSize();
              updatePreview();
            }, 100);
          }
        }

        addCanvasTouchSupport(canvas) {
          // Basic touch support for canvas (for future enhancements)
          let isPinching = false;
          let lastTouchDistance = 0;

          canvas.addEventListener(
            "touchstart",
            (e) => {
              if (e.touches.length === 2) {
                isPinching = true;
                lastTouchDistance = this.getTouchDistance(
                  e.touches[0],
                  e.touches[1]
                );
              }
            },
            { passive: true }
          );

          canvas.addEventListener(
            "touchmove",
            (e) => {
              if (isPinching && e.touches.length === 2) {
                e.preventDefault();
                const currentDistance = this.getTouchDistance(
                  e.touches[0],
                  e.touches[1]
                );
                // Future: implement zoom functionality
              }
            },
            { passive: false }
          );

          canvas.addEventListener(
            "touchend",
            () => {
              isPinching = false;
            },
            { passive: true }
          );
        }

        getTouchDistance(touch1, touch2) {
          const dx = touch1.clientX - touch2.clientX;
          const dy = touch1.clientY - touch2.clientY;
          return Math.sqrt(dx * dx + dy * dy);
        }

        resetMobileOptimizations() {
          document.body.classList.remove("mobile-optimized");
          document.body.style.overscrollBehavior = "";

          // Reset viewport for desktop
          const viewport = document.querySelector('meta[name="viewport"]');
          if (viewport) {
            viewport.setAttribute(
              "content",
              "width=device-width, initial-scale=1.0"
            );
          }
        }

        // Public methods
        isMobileDevice() {
          return this.isMobile;
        }

        expandAllSections() {
          const controlSections = document.querySelectorAll(".control-section");
          controlSections.forEach((section) => {
            const title = section.querySelector(".section-title");
            const content = section.querySelector(".section-content");
            if (title && content) {
              this.expandSection(section, title, content);
            }
          });
        }

        collapseAllSections() {
          const controlSections = document.querySelectorAll(".control-section");
          controlSections.forEach((section) => {
            const title = section.querySelector(".section-title");
            const content = section.querySelector(".section-content");
            if (title && content) {
              this.collapseSection(section, title, content);
            }
          });
        }
      }

      // Global mobile optimizer instance
      let mobileOptimizer = null;

      // Initialize export controls
      function initializeExportControls() {
        // Get export control elements
        const exportBtn = document.getElementById("export-btn");
        const exportBtnText = document.getElementById("export-btn-text");
        const exportFilename = document.getElementById("export-filename");
        const exportQuality = document.getElementById("export-quality");
        const exportQualityValue = document.getElementById(
          "export-quality-value"
        );
        const exportInfo = document.getElementById("export-info");

        if (
          !exportBtn ||
          !exportFilename ||
          !exportQuality ||
          !exportQualityValue
        ) {
          console.error("Export control elements not found");
          return;
        }

        // Initialize filename display
        function updateFilenameDisplay() {
          if (exportManager) {
            const filename = exportManager.generateFilename();
            exportFilename.value = filename;
          }
        }

        // Initialize quality display
        function updateQualityDisplay() {
          const quality = parseFloat(exportQuality.value);
          const percentage = Math.round(quality * 100);
          exportQualityValue.textContent = percentage + "%";

          // Update state
          updateAppState("export.quality", quality);
        }

        // Set up event listeners with comprehensive error handling
        exportBtn.addEventListener("click", async () => {
          try {
            // Validate prerequisites
            if (!exportManager) {
              throw new Error("Export system not initialized");
            }

            if (exportManager.isExportInProgress()) {
              notificationManager.warning(
                "Export In Progress",
                "Please wait for the current export to complete."
              );
              return;
            }

            // Validate form data before export
            const isFormValid = formValidator.validateForm("text-form");
            if (!isFormValid) {
              notificationManager.error(
                "Invalid Form Data",
                "Please fix the form errors before exporting.",
                { duration: 5000 }
              );
              return;
            }

            // Check required fields
            const fullName = getAppState("text.fields.fullName");
            if (!fullName || !fullName.trim()) {
              notificationManager.error(
                "Missing Information",
                "Full name is required for export.",
                { duration: 4000 }
              );
              return;
            }

            // Update button state
            exportBtn.disabled = true;
            exportBtnText.textContent = "Preparing Export...";

            // Start export process
            const success = await exportManager.exportAndDownload();

            if (success) {
              exportBtnText.textContent = "Export Successful!";
              exportInfo.textContent =
                "Download started • Check your downloads folder";
              exportInfo.className =
                exportInfo.className.replace(/\b(success|error)\b/g, "") +
                " success";

              // Reset button after 3 seconds
              setTimeout(() => {
                exportBtnText.textContent = "Export Background (1920×1080)";
                exportInfo.textContent =
                  "High-quality PNG format • Ready for video conferencing";
                exportInfo.className = exportInfo.className.replace(
                  /\b(success|error)\b/g,
                  ""
                );
              }, 3000);
            } else {
              throw new Error("Export process returned failure");
            }
          } catch (error) {
            console.error("Export error:", error);

            // Update button state to show error
            exportBtnText.textContent = "Export Failed";
            exportInfo.textContent = "Export failed • Please try again";
            exportInfo.className =
              exportInfo.className.replace(/\b(success|error)\b/g, "") +
              " error";

            // Show detailed error notification
            notificationManager.error(
              "Export Failed",
              errorBoundary.getUserFriendlyMessage(error, "Export"),
              {
                duration: 8000,
                actions: [
                  {
                    id: "retry",
                    label: "Try Again",
                    handler: () => exportBtn.click(),
                  },
                  {
                    id: "help",
                    label: "Get Help",
                    handler: () => {
                      notificationManager.info(
                        "Export Troubleshooting",
                        "Try refreshing the page, using a different browser, or reducing image quality.",
                        { duration: 10000 }
                      );
                    },
                  },
                ],
              }
            );

            // Handle specific error types
            if (error.message.includes("canvas")) {
              notificationManager.warning(
                "Browser Compatibility",
                "Your browser may not support all export features. Try using Chrome or Firefox.",
                { duration: 8000 }
              );
            } else if (
              error.message.includes("memory") ||
              error.message.includes("quota")
            ) {
              notificationManager.warning(
                "Memory Issue",
                "Try reducing export quality or closing other browser tabs.",
                { duration: 8000 }
              );
            }

            // Reset button after 5 seconds (longer for errors)
            setTimeout(() => {
              exportBtnText.textContent = "Export Background (1920×1080)";
              exportInfo.textContent =
                "High-quality PNG format • Ready for video conferencing";
              exportInfo.className = exportInfo.className.replace(
                /\b(success|error)\b/g,
                ""
              );
            }, 5000);

            errorBoundary.handleError(error, "Export");
          } finally {
            exportBtn.disabled = false;
          }
        });

        exportQuality.addEventListener("input", updateQualityDisplay);

        // Listen for text field changes to update filename
        stateEvents.on(
          "stateChange:text.fields.fullName",
          updateFilenameDisplay
        );

        // Initialize displays
        updateFilenameDisplay();
        updateQualityDisplay();

        console.log("Export controls initialized");
      }

      // Global error recovery mechanisms
      window.addEventListener("beforeunload", (event) => {
        // Save current state before page unload
        try {
          saveStateToStorage();
        } catch (error) {
          console.error("Failed to save state before unload:", error);
        }
      });

      // Periodic health check
      setInterval(() => {
        try {
          // Check if critical systems are still working
          if (typeof updatePreview !== "function") {
            console.warn("Preview system appears to be broken");
            notificationManager.warning(
              "System Check",
              "Some features may not be working properly. Consider refreshing the page.",
              { duration: 5000 }
            );
          }

          // Check if state is still valid
          const currentState = getAppState();
          if (!currentState || !currentState.text || !currentState.assets) {
            console.warn("Application state appears to be corrupted");
            notificationManager.error(
              "Data Integrity Issue",
              "Application data may be corrupted. Consider refreshing the page.",
              {
                persistent: true,
                actions: [
                  {
                    id: "refresh",
                    label: "Refresh Page",
                    handler: () => window.location.reload(),
                  },
                ],
              }
            );
          }
        } catch (error) {
          console.error("Health check failed:", error);
        }
      }, 30000); // Check every 30 seconds

      // Show initialization complete notification after everything is loaded
      document.addEventListener("DOMContentLoaded", () => {
        setTimeout(() => {
          if (notificationManager) {
            notificationManager.success(
              "Application Ready",
              "DDAM Meeting Background Generator is loaded and ready to use.",
              { duration: 3000 }
            );
          }
        }, 2000);
      });

      // Run comprehensive browser tests in development mode
      if (
        window.location.hostname === "localhost" ||
        window.location.hostname === "127.0.0.1" ||
        window.location.search.includes("debug=true")
      ) {
        // Run tests after everything is loaded
        setTimeout(async () => {
          try {
            console.log("Running development mode browser tests...");
            await runComprehensiveBrowserTests();
          } catch (error) {
            console.error("Development browser tests failed:", error);
          }
        }, 2000);
      }

      // Final Integration Testing System
      class FinalIntegrationTester {
        constructor() {
          this.testResults = [];
          this.errors = [];
          this.warnings = [];
          this.startTime = Date.now();
        }

        log(message, type = "info") {
          const timestamp = new Date().toISOString();
          const logEntry = { timestamp, message, type };

          console.log(`[${timestamp}] ${type.toUpperCase()}: ${message}`);

          switch (type) {
            case "error":
              this.errors.push(logEntry);
              break;
            case "warning":
              this.warnings.push(logEntry);
              break;
            default:
              this.testResults.push(logEntry);
          }
        }

        async runAllTests() {
          this.log("Starting Final Integration and Testing Suite");

          try {
            await this.testHTMLStructure();
            await this.testStateManagement();
            await this.testLayoutSelection();
            await this.testTextInputs();
            await this.testTypographyControls();
            await this.testAssetManagement();
            await this.testCanvasPreview();
            await this.testTextPositioning();
            await this.testExportFunctionality();
            await this.testResponsiveDesign();
            await this.testErrorHandling();
            await this.testCrossBrowserCompatibility();
            await this.testAccessibilityCompliance();
            await this.testPerformance();

            return this.generateFinalReport();
          } catch (error) {
            this.log(
              `Critical error during testing: ${error.message}`,
              "error"
            );
            throw error;
          }
        }

        async testHTMLStructure() {
          this.log("Testing HTML structure and component integration...");

          const requiredElements = [
            "header",
            ".control-panel",
            ".preview-panel",
            "#preview-canvas",
            "#text-form",
            "#export-btn",
          ];

          for (const selector of requiredElements) {
            const element = document.querySelector(selector);
            if (!element) {
              this.log(`Missing required element: ${selector}`, "error");
            } else {
              this.log(`✓ Found required element: ${selector}`);
            }
          }

          const layoutCards = document.querySelectorAll(".layout-card");
          if (layoutCards.length !== 2) {
            this.log(
              `Expected 2 layout cards, found ${layoutCards.length}`,
              "error"
            );
          } else {
            this.log("✓ Layout cards present");
          }

          const requiredInputs = [
            "fullName",
            "nickname",
            "positionEn",
            "positionJp",
          ];
          for (const inputId of requiredInputs) {
            const input = document.getElementById(inputId);
            if (!input) {
              this.log(`Missing required input: ${inputId}`, "error");
            } else {
              this.log(`✓ Found required input: ${inputId}`);
            }
          }
        }

        async testStateManagement() {
          this.log("Testing application state management...");

          if (typeof window.appState === "undefined") {
            this.log("Application state not initialized", "error");
            return;
          }

          const requiredStateKeys = ["layout", "text", "assets", "export"];
          for (const key of requiredStateKeys) {
            if (!window.appState[key]) {
              this.log(`Missing state key: ${key}`, "error");
            } else {
              this.log(`✓ State key present: ${key}`);
            }
          }

          if (typeof window.updateAppState === "function") {
            try {
              const originalValue = window.appState.text.fields.fullName;
              window.updateAppState("text.fields.fullName", "Test Name");

              if (window.appState.text.fields.fullName === "Test Name") {
                this.log("✓ State update function working");
                window.updateAppState("text.fields.fullName", originalValue);
              } else {
                this.log("State update function not working properly", "error");
              }
            } catch (error) {
              this.log(`State update error: ${error.message}`, "error");
            }
          } else {
            this.log("updateAppState function not found", "error");
          }
        }

        async testLayoutSelection() {
          this.log("Testing layout selection functionality...");

          const layoutCards = document.querySelectorAll(".layout-card");

          for (const card of layoutCards) {
            const layoutType = card.dataset.layout;
            card.click();
            await new Promise((resolve) => setTimeout(resolve, 100));

            if (card.classList.contains("active")) {
              this.log(`✓ Layout ${layoutType} selection working`);
            } else {
              this.log(`Layout ${layoutType} selection not working`, "error");
            }
          }
        }

        async testTextInputs() {
          this.log("Testing text input functionality and real-time updates...");

          const textInputs = [
            { id: "fullName", testValue: "Test User" },
            { id: "nickname", testValue: "テスト" },
            { id: "positionEn", testValue: "Test Position" },
            { id: "positionJp", testValue: "テストポジション" },
          ];

          for (const { id, testValue } of textInputs) {
            const input = document.getElementById(id);
            if (!input) {
              this.log(`Input ${id} not found`, "error");
              continue;
            }

            const originalValue = input.value;
            input.value = testValue;
            input.dispatchEvent(new Event("input", { bubbles: true }));
            await new Promise((resolve) => setTimeout(resolve, 200));

            const stateValue = window.appState?.text?.fields?.[id];
            if (stateValue === testValue) {
              this.log(`✓ Text input ${id} working`);
            } else {
              this.log(`Text input ${id} state update failed`, "warning");
            }

            input.value = originalValue;
            input.dispatchEvent(new Event("input", { bubbles: true }));
          }
        }

        async testTypographyControls() {
          this.log("Testing typography controls...");

          const fontSelectors = ["japaneseFont", "englishFont"];
          for (const selectorId of fontSelectors) {
            const select = document.getElementById(selectorId);
            if (!select) {
              this.log(`Font selector ${selectorId} not found`, "error");
              continue;
            }

            const originalValue = select.value;
            const options = select.querySelectorAll("option");

            if (options.length > 1) {
              select.value = options[1].value;
              select.dispatchEvent(new Event("change", { bubbles: true }));
              await new Promise((resolve) => setTimeout(resolve, 100));
              this.log(`✓ Font selector ${selectorId} working`);

              select.value = originalValue;
              select.dispatchEvent(new Event("change", { bubbles: true }));
            }
          }

          const fontSizeSlider = document.getElementById("fontSize");
          if (fontSizeSlider) {
            const originalValue = fontSizeSlider.value;
            fontSizeSlider.value = "20";
            fontSizeSlider.dispatchEvent(new Event("input", { bubbles: true }));
            await new Promise((resolve) => setTimeout(resolve, 100));
            this.log("✓ Font size slider working");

            fontSizeSlider.value = originalValue;
            fontSizeSlider.dispatchEvent(new Event("input", { bubbles: true }));
          }

          const colorButtons = document.querySelectorAll(".color-toggle-btn");
          if (colorButtons.length >= 2) {
            colorButtons[1].click();
            await new Promise((resolve) => setTimeout(resolve, 100));
            this.log("✓ Color toggle buttons working");
            colorButtons[0].click();
          }
        }

        async testAssetManagement() {
          this.log("Testing asset management system...");

          const logoItems = document.querySelectorAll(
            '.logo-item, .asset-item[data-type="logo"]'
          );
          if (logoItems.length > 0) {
            this.log(`✓ Found ${logoItems.length} logo items`);
            logoItems[0].click();
            await new Promise((resolve) => setTimeout(resolve, 100));

            if (logoItems[0].classList.contains("active")) {
              this.log("✓ Logo selection working");
            }
          } else {
            this.log("No logo items found", "warning");
          }

          const backgroundItems = document.querySelectorAll(
            '.background-item, .asset-item[data-type="background"]'
          );
          if (backgroundItems.length > 0) {
            this.log(`✓ Found ${backgroundItems.length} background items`);
          } else {
            this.log("No background items found", "warning");
          }

          const uploadArea = document.querySelector(".upload-area");
          if (uploadArea) {
            this.log("✓ Upload area present");
          } else {
            this.log("Upload area not found", "warning");
          }
        }

        async testCanvasPreview() {
          this.log("Testing canvas preview system...");

          const canvas = document.getElementById("preview-canvas");
          if (!canvas) {
            this.log("Preview canvas not found", "error");
            return;
          }

          const ctx = canvas.getContext("2d");
          if (!ctx) {
            this.log("Canvas context not available", "error");
            return;
          }

          this.log("✓ Canvas preview system initialized");

          if (canvas.width > 0 && canvas.height > 0) {
            this.log(`✓ Canvas dimensions: ${canvas.width}x${canvas.height}`);
          } else {
            this.log("Canvas dimensions not set properly", "error");
          }

          if (typeof window.updatePreview === "function") {
            try {
              window.updatePreview();
              this.log("✓ Preview update function working");
            } catch (error) {
              this.log(`Preview update error: ${error.message}`, "error");
            }
          } else {
            this.log("Preview update function not found", "error");
          }
        }

        async testTextPositioning() {
          this.log("Testing text positioning controls...");

          const positionSections = document.querySelectorAll(
            ".position-control-section"
          );

          for (const section of positionSections) {
            const radioButtons = section.querySelectorAll(
              'input[type="radio"]'
            );

            if (radioButtons.length > 0) {
              for (const radio of radioButtons) {
                radio.checked = true;
                radio.dispatchEvent(new Event("change", { bubbles: true }));
                await new Promise((resolve) => setTimeout(resolve, 50));
              }

              this.log(`✓ Position controls working for ${section.id}`);
            }
          }
        }

        async testExportFunctionality() {
          this.log("Testing export functionality...");

          const exportBtn = document.getElementById("export-btn");
          if (!exportBtn) {
            this.log("Export button not found", "error");
            return;
          }

          if (typeof html2canvas === "undefined") {
            this.log("HTML2Canvas library not loaded", "error");
            return;
          }

          this.log("✓ Export button and HTML2Canvas available");

          if (typeof window.exportManager !== "undefined") {
            this.log("✓ Export manager initialized");

            if (typeof window.exportManager.generateFilename === "function") {
              const filename = window.exportManager.generateFilename();
              if (filename && filename.includes(".png")) {
                this.log(`✓ Filename generation working: ${filename}`);
              } else {
                this.log("Filename generation not working properly", "error");
              }
            }
          } else {
            this.log("Export manager not found", "error");
          }
        }

        async testResponsiveDesign() {
          this.log("Testing responsive design...");

          const originalWidth = window.innerWidth;

          // Test mobile breakpoint
          Object.defineProperty(window, "innerWidth", {
            writable: true,
            configurable: true,
            value: 600,
          });

          window.dispatchEvent(new Event("resize"));
          await new Promise((resolve) => setTimeout(resolve, 100));
          this.log("✓ Mobile responsive test completed");

          // Test tablet breakpoint
          Object.defineProperty(window, "innerWidth", {
            writable: true,
            configurable: true,
            value: 800,
          });

          window.dispatchEvent(new Event("resize"));
          await new Promise((resolve) => setTimeout(resolve, 100));
          this.log("✓ Tablet responsive test completed");

          // Restore original width
          Object.defineProperty(window, "innerWidth", {
            writable: true,
            configurable: true,
            value: originalWidth,
          });

          window.dispatchEvent(new Event("resize"));
        }

        async testErrorHandling() {
          this.log("Testing error handling and user feedback...");

          if (typeof window.notificationManager !== "undefined") {
            this.log("✓ Notification manager available");

            try {
              window.notificationManager.info(
                "Test",
                "Integration test notification"
              );
              this.log("✓ Notification system working");

              setTimeout(() => {
                window.notificationManager.hideAll();
              }, 1000);
            } catch (error) {
              this.log(`Notification system error: ${error.message}`, "error");
            }
          } else {
            this.log("Notification manager not found", "error");
          }

          if (typeof window.errorBoundary !== "undefined") {
            this.log("✓ Error boundary available");
          } else {
            this.log("Error boundary not found", "error");
          }

          if (typeof window.formValidator !== "undefined") {
            this.log("✓ Form validator available");

            const isValid = window.formValidator.validateForm("text-form");
            this.log(`✓ Form validation result: ${isValid}`);
          } else {
            this.log("Form validator not found", "error");
          }
        }

        async testCrossBrowserCompatibility() {
          this.log("Testing cross-browser compatibility features...");

          if (typeof window.browserCompatibility !== "undefined") {
            const browserInfo = window.browserCompatibility.getBrowserInfo();
            this.log(
              `✓ Browser detected: ${browserInfo.name} ${browserInfo.version}`
            );

            const features = window.browserCompatibility.getFeatureSupport();
            const supportedFeatures = Object.keys(features).filter(
              (key) => features[key]
            );
            this.log(
              `✓ Supported features: ${supportedFeatures.length}/${
                Object.keys(features).length
              }`
            );
          } else {
            this.log("Browser compatibility manager not found", "warning");
          }

          if (typeof window.fontLoadingManager !== "undefined") {
            this.log("✓ Font loading manager available");
          } else {
            this.log("Font loading manager not found", "warning");
          }
        }

        async testAccessibilityCompliance() {
          this.log("Testing accessibility compliance...");

          const elementsNeedingAria = document.querySelectorAll(
            "button, input, select"
          );
          let ariaCompliant = 0;

          for (const element of elementsNeedingAria) {
            if (
              element.getAttribute("aria-label") ||
              element.getAttribute("aria-labelledby") ||
              element.getAttribute("aria-describedby") ||
              element.closest("label")
            ) {
              ariaCompliant++;
            }
          }

          const ariaPercentage = Math.round(
            (ariaCompliant / elementsNeedingAria.length) * 100
          );
          this.log(
            `✓ ARIA compliance: ${ariaPercentage}% (${ariaCompliant}/${elementsNeedingAria.length})`
          );

          const focusableElements = document.querySelectorAll(
            'button, input, select, textarea, [tabindex]:not([tabindex="-1"])'
          );

          if (focusableElements.length > 0) {
            this.log(`✓ Found ${focusableElements.length} focusable elements`);
          }

          const colorElements = document.querySelectorAll(
            ".color-toggle-btn, .btn"
          );
          this.log(
            `✓ Color contrast elements checked: ${colorElements.length}`
          );
        }

        async testPerformance() {
          this.log("Testing performance with various scenarios...");

          const performanceTests = [];

          const startTime = performance.now();

          if (typeof window.updatePreview === "function") {
            for (let i = 0; i < 10; i++) {
              window.updatePreview();
              await new Promise((resolve) => setTimeout(resolve, 10));
            }

            const renderTime = performance.now() - startTime;
            performanceTests.push({
              test: "Canvas Rendering",
              time: renderTime,
            });
            this.log(
              `✓ Canvas rendering performance: ${renderTime.toFixed(
                2
              )}ms for 10 updates`
            );
          }

          const stateStartTime = performance.now();

          for (let i = 0; i < 100; i++) {
            if (typeof window.updateAppState === "function") {
              window.updateAppState("text.fields.fullName", `Test ${i}`);
            }
          }

          const stateTime = performance.now() - stateStartTime;
          performanceTests.push({ test: "State Updates", time: stateTime });
          this.log(
            `✓ State update performance: ${stateTime.toFixed(
              2
            )}ms for 100 updates`
          );

          if (performance.memory) {
            const memoryInfo = performance.memory;
            this.log(
              `✓ Memory usage: ${Math.round(
                memoryInfo.usedJSHeapSize / 1024 / 1024
              )}MB`
            );
          }

          return performanceTests;
        }

        generateFinalReport() {
          const endTime = Date.now();
          const totalTime = endTime - this.startTime;

          this.log("=".repeat(60));
          this.log("FINAL INTEGRATION TEST REPORT");
          this.log("=".repeat(60));

          this.log(`Total test time: ${totalTime}ms`);
          this.log(`Total tests run: ${this.testResults.length}`);
          this.log(`Errors found: ${this.errors.length}`);
          this.log(`Warnings: ${this.warnings.length}`);

          if (this.errors.length > 0) {
            this.log("\nERRORS:");
            this.errors.forEach((error) => {
              this.log(`  - ${error.message}`);
            });
          }

          if (this.warnings.length > 0) {
            this.log("\nWARNINGS:");
            this.warnings.forEach((warning) => {
              this.log(`  - ${warning.message}`);
            });
          }

          const totalIssues = this.errors.length + this.warnings.length;
          const healthScore = Math.max(
            0,
            100 - this.errors.length * 10 - this.warnings.length * 5
          );

          this.log(`\nOVERALL HEALTH SCORE: ${healthScore}%`);

          if (healthScore >= 90) {
            this.log("✅ EXCELLENT - Application is ready for production");
          } else if (healthScore >= 75) {
            this.log("✅ GOOD - Application is functional with minor issues");
          } else if (healthScore >= 60) {
            this.log("⚠️ FAIR - Application needs attention before production");
          } else {
            this.log(
              "❌ POOR - Application has significant issues that need fixing"
            );
          }

          this.log("=".repeat(60));

          return {
            totalTime,
            testCount: this.testResults.length,
            errorCount: this.errors.length,
            warningCount: this.warnings.length,
            healthScore,
            errors: this.errors,
            warnings: this.warnings,
          };
        }
      }

      // Make available globally
      window.FinalIntegrationTester = FinalIntegrationTester;

      // Manual test runner
      window.runFinalIntegrationTests = async function () {
        const tester = new FinalIntegrationTester();
        return await tester.runAllTests();
      };

      // Auto-run final integration tests in development mode
      if (
        window.location.hostname === "localhost" ||
        window.location.hostname === "127.0.0.1" ||
        window.location.search.includes("test=final")
      ) {
        setTimeout(async () => {
          console.log("Auto-running final integration tests...");
          const tester = new FinalIntegrationTester();

          try {
            const report = await tester.runAllTests();

            // Show completion notification
            if (notificationManager && report.healthScore >= 75) {
              notificationManager.success(
                "Integration Tests Complete",
                `Health Score: ${report.healthScore}% - Application ready for use!`,
                { duration: 5000 }
              );
            } else if (notificationManager) {
              notificationManager.warning(
                "Integration Tests Complete",
                `Health Score: ${report.healthScore}% - Some issues detected. Check console for details.`,
                { duration: 8000 }
              );
            }
          } catch (error) {
            console.error("Integration tests failed:", error);
            if (notificationManager) {
              notificationManager.error(
                "Integration Tests Failed",
                "Critical errors detected. Check console for details.",
                { duration: 10000 }
              );
            }
          }
        }, 3000);
      }
    </script>
  </body>
</html>
